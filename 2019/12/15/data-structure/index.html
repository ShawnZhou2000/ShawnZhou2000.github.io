<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="博客,前端博客,JavaScript,html5,css3,html,css,js,acm,noip,橙果工作室,shawnzhou,shawn zhou" />
   
  <meta name="description" content="ShawnZhou的小站" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    基础数据结构归档 |  ShawnZhou的小站
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="ShawnZhou的小站" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-data-structure"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  基础数据结构归档
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/12/15/data-structure/" class="article-date">
  <time datetime="2019-12-15T11:50:14.000Z" itemprop="datePublished">2019-12-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">26.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">98 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>这里是一些基础数据结构知识点的整理，有基本概念，线性表，链表，树，图，哈希表等。该部分内容是曾在2018年和2019年发布的。</p>
<p>当前博客显示的发布时间非真实时间，而是这些内容在当时发布时的最后发布时间。</p>
<p><img src="https://i.loli.net/2018/08/10/5b6d26f3edb0e.png"></p>
<a id="more"></a>

<h2 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h2><p>利用计算机进行数据处理是计算机应用的一个重要领域。在进行数据处理时，实际需要处理的元素一般会有很多，而这些大量的数据都要存放在计算机中。因此，大量的数据元素在计算机中如何组织，提高数据处理的效率，并且尽量节省存储空间，是进行数据处理的关键问题。</p>
<p>数据结构主要研究和讨论以下三个方面的问题，目的是提高数据据处理的效率。所谓提高效率主要体现在两个方面：一是提高数据处理的速度，二是尽量节省数据处理过程中所站的计算机存储空间。</p>
<p>1.数据的逻辑结构</p>
<p>2.数据的存储结构</p>
<p>3.对各种数据结构的运算</p>
<p>简单来说，数据结构是指相互有关联的数据元素的集合。数据元素具有广泛的含义，一般来说，现实世界中客观存在的一切个体都可以作为数据元素。</p>
<h3 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h3><p>对于一个给定的数据结构，它应该包含表示数据元素的信息，以及表示各个数据间的前后关系。这里数据间的前后关系是指的它们的逻辑关系，而与它们在计算机中存储的物理位置无关。所以，数据的逻辑结构一般有两个要素，一是数据元素的集合，二是它们之间的逻辑关系。</p>
<p>举个例子，对于图这种数据结构，通常我们用G来表示一个图，一张图通常由两个集合构成，一个是点集V，另一个是边集E。则这个图就可以表示成：</p>
<p><em>G = {V,E}</em></p>
<p>要注意，对于一些复杂的数据结构，它的数据元素也可以是一种数据结构。</p>
<h3 id="数据的存储结构"><a href="#数据的存储结构" class="headerlink" title="数据的存储结构"></a>数据的存储结构</h3><p>前面说到，一个数据结构中的各个数据元素在计算机存储空间中的位置关系与逻辑关系是极有可能不相同的。实际上，数据的逻辑结构在计算机存储空间中的存放形式称为数据的存储结构。在数据的存储结构中，不仅要存放各种数据元素的信息，还需要存放各种数据元素间的前后关系。</p>
<h3 id="线性结构和非线性结构"><a href="#线性结构和非线性结构" class="headerlink" title="线性结构和非线性结构"></a>线性结构和非线性结构</h3><p>通常的，我们根据数据结构中各个元素之间的前后关系的复杂程度，一般将数据结构分成两大类型：线性结构和非线性结构。</p>
<p>如果一个非空的数据结构满足有且只有一个根节点，并且每一个节点最多只有一个前驱或者后继，那么这样的数据结构我们称之为线性结构，有的资料或文献中也称作“线性表”。在线性结构中各个数据元素之间的前后关系都是比较简单的。需要特别说明的是，在一个线性结构中插入或删除任何一个节点后应该还是线性结构，不满足该特性的数据结构也不是线性结构。比如下图所展示的数据结构，就不是一个线性数据结构。</p>
<p><img src="https://i.loli.net/2018/08/09/5b6bfe11a8e9f.png"></p>
<p>不满足线性数据结构定义或特性的，统称为非线性数据结构。</p>
<p>非线性数据结构要比线性数据结构复杂得多，因为它通常会包含更多的前后关系。线性结构与非线性结构都可以是空的数据结构。</p>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>一种最简单并且最常用的数据结构。它由一组数据元素构成。数据元素既可以是简单的，又可以是复杂的。比如矩阵，我们可以把矩阵理解为一个线性表，其中每一行/每一列的数据就可以作为一个数据元素。在这种复杂的线性表中，由若干数据项组成的数据元素称之为记录。总的来说，线性表是一个具有n个元素的一个有限序列。它满足线性数据结构的性质，也就是对于任何一个结点，只会有最多一个前驱和一个后继。</p>
<p>数据元素在线性表中的位置只取决于它们自己的序号，而 <strong>不一定</strong> 取决于它们的物理位置。此外，一个非空的线性表有如下的结构特征：</p>
<p>1.有且只有一个根结点，它没有前驱。</p>
<p>2.有且只有一个尾结点，它没有后继。</p>
<p>3.中间的结点有且只有一个前驱和后继。</p>
<p>在线性表中，结点的个数n代表线性表的长度。当n = 0时，称为空表。</p>
<h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h3><p>这是最简单的存放线性表的方法。它也被称为顺序分配。</p>
<p>线性表的顺序存储结构具有以下两个基本特点：</p>
<p>1.所占存储空间是连续的。</p>
<p>2.各数据元素在存储空间中是按照逻辑顺序依次存放的。</p>
<p>如果采用了线性表的顺序存储结构，那么对于某个元素，它的前驱和后继在存储空间（物理位置）中是紧邻的。对于顺序存储结构，如果各个数据元素所占的存储空间相等，那么查找元素是比较方便的。（其实大多数情况下这个条件是满足的）</p>
<p>对，其实就是一维数组……</p>
<p>在顺序存储结构中，线性表中每一个数据元素在计算机存储空间中的存储地址由该元素在线性表中的位置序号唯一确定。这句话怎么解释呢？我们可以想一想，一维数组在硬件里是怎么存储的？</p>
<p><img src="https://i.loli.net/2018/08/10/5b6cff66cf293.png"></p>
<p>借助这张图来了解是比较直观的。</p>
<p>实际上，头结点所对应的地址称作为首地址，后续的结点地址是连续的，那么自然就会产生一个相对于首地址的位置差值，这个差值我一般称之为“偏移量”。也就是说，在这样的线性表中，每个数据元素都可以用“首地址+偏移量”来表示。</p>
<p>但是要注意的是，上图中的每一个值都只占一个字节，所以地址会按照1,2,3，……这样的顺序来变化。实际上，如果每一个数据元素占k个字节的话，偏移量也是按照k的倍数来变化的。</p>
<p>对于一个线性表，它的操作一般有如下几种：</p>
<pre><code>1. 在指定位置插入新元素
2. 删除指定位置的元素
3. 查找某个元素
4. 排序
5. 分解线性表
6. 合并线性表
7. 复制线性表
8. 逆转线性表</code></pre>
<p>计算机二级考察插入和删除操作。</p>
<h3 id="线性表的插入操作"><a href="#线性表的插入操作" class="headerlink" title="线性表的插入操作"></a>线性表的插入操作</h3><p>刚才说到，顺序存储结构的线性表可以用一维数组来表示，那么这个问题其实就是如何在一个一维数组中插入一个元素的问题。</p>
<p>通常的，在定义一维数组时，数组的长度要比实际用到的长度要长一些。如果长度太短，会导致存储空间不够而无法进行操作，但是长度太长的话又会造成浪费。具体要开多大，自己掂量着来。</p>
<p>插入操作大致的分三步。</p>
<pre><code>1. 找到要插的位置
2. 让后面的元素全部后挪一位，腾出空来
3. 插♂ 进去</code></pre>
<p>特殊的，如果要在线性表的末尾插入元素，那么直接第三步就好。</p>
<p>不难看出，在大多数情况下，进行插入操作都要进行元素的移动。一般的，如果要在i位置插入一个元素，那么第i个元素（包括他本身）以及之后的元素都要做对应的移动。在平均情况下，要在线性表中插入一个元素，需要移动大约一半的元素。这个效率其实是很低的，尤其是在线性表比较大的时候。</p>
<p>此外要注意，当存储空间已满，整个数组的所有位置都存放了数据时，插入操作无法进行。该操作一定要在编写代码时体现出来。</p>
<p>移动操作是倒着来的。即先从尾结点开始，向后移动一个偏移量，之后尾结点之前的每一个元素都要向后移动一个偏移量，一直到插入位置为止。</p>
<p>最后，在腾出来的空位上插入新元素，线性表长度+1。</p>
<h3 id="线性表的删除操作"><a href="#线性表的删除操作" class="headerlink" title="线性表的删除操作"></a>线性表的删除操作</h3><p>删除操作也是三步。</p>
<pre><code>1. 找到要删除的位置
2. 该位置之后的元素全部前移一位（本质上是一种复制后的覆盖）
3. 多余的尾结点清空</code></pre>
<p>特殊的，如果要在线性表的末尾删除元素，那么直接清空尾结点就好。</p>
<p>该操作的效率也比较低，道理同上。</p>
<p>此外，当线性表为空表时，不能进行删除操作，如果试图删除一个不存在的结点，也是不可以的。</p>
<p>一定注意不要忘了第三步，清空尾结点。清空的同时线性表长度-1。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于顺序存储结构的线性表，其优点在于定义方便，易于操作，但是缺点也是很明显的，插入和删除操作的效率很低。</p>
<p>那么它适用于什么情况呢？</p>
<p>对于数据量小的问题，或者是元素不经常变动的问题来说，使用顺序存储结构的线性表是比较简单的。如果数据量大，并且元素还要经常变动，那么可以考虑使用链式存储结构的线性表（链表）。</p>
<p>之前介绍的线性表的顺序存储结构具有一定的不足之处。比如插入或删除元素的效率较低，同时，它的大小是固定的，在操作时需要注意空间的限制。今天要介绍的链表就能很好的解决这些问题。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表这种数据结构其实也是一种线性表，但它并不是顺序存储结构，而是一种链式存储结构。</p>
<p>链式存储结构的基本单元称为结点。每一个存储单元都可以存放若干数据。</p>
<p>在链式存储结构中，通常要求每个结点包括两个信息。一是数据域，记录该结点的数据， 二是指针域，用来存放指向下一个结点或者前一个结点的指针。</p>
<p>之前我们说到，顺序存储结构要求地址必须是连续的，但是链式存储结构不需要。它们之间由指针域连接在一起，所以存储空间可以不连续（也就是说可以是连续的，这点一定注意）。</p>
<p>链式存储结构既可以用来表示线性结构，也可以用来表示非线性结构。在使用链式存储结构存储比较复杂的数据结构时，它的指针域的个数要稍微多一些。</p>
<h3 id="线性链表"><a href="#线性链表" class="headerlink" title="线性链表"></a>线性链表</h3><p>顾名思义，这就是线性表的链式存储结构。其实我们通常说“链表”，指的就是这个。</p>
<p>线性链表与链表在特性上是相似的。在存储链表时，计算机会将一个结点分成两部分：一部分用来存储数据元素的值，另一部分存储指向下一个结点的指针，或者，下一个数据元素的存储序号。</p>
<p>画一下示意图：</p>
<p><img src="https://i.loli.net/2018/08/12/5b6ff1dcc3767.png"></p>
<p>在线性链表中，使用一个专门的指针HEAD指向链表中第一个数据元素的结点（注意并不是指向数据域）。</p>
<p>尾指针不指向任何位置，可以设为NULL或者0。</p>
<p>对于线性链表，可以从头指针开始，沿着各个结点的指针扫描到链表中的所有结点。</p>
<p>其实完全可以给出一个思路。使用for循环来遍历整个链表，循环的初值是头结点，边界是还存在下一个结点，每循环一层，就沿着指针域跑到下一个结点。循环体输出当前结点数据域的信息即可。</p>
<p>这种链表也叫做单向链表，它只能找到后继而不能找到前驱（或者只能找到前驱而不能找到后继），如果想要找到它的前驱，必须再次从头结点进行寻找。</p>
<p>所以为了弥补这个缺点，人们开发出了双向链表。</p>
<p>双向链表的每一个结点具有两个指针域，一个指向前驱一个指向后继。</p>
<p><img src="https://i.loli.net/2018/08/12/5b6ff8302110d.png"></p>
<p>图中L指的是左指针域 R指的是右指针域，D指的是数据域。</p>
<h3 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h3><p>其实就是把顺序存储的栈变成链式存储的栈。</p>
<p><img src="https://i.loli.net/2018/08/12/5b6ffab421e0d.png"></p>
<p>对栈的操作都在头结点上进行。在实际的应用中，带链的栈可以收集计算机存储空间中所有空闲的存储结点。这种链式栈称为可利用栈。由于可利用栈连接了计算机存储空间中所有的空闲结点，因此，当计算机系统或者用户程序需要存储结点时，就可以从中取出栈顶结点。同样，释放一个结点时将返回栈顶。随着其他线性链表的插入与删除，可利用栈处于动态变化之中。即可利用栈经常要进行退栈与入栈操作。</p>
<p>对于一个链式栈，它的基本操作和普通栈是差不多的。</p>
<p>1.初始化。建立一个空栈。</p>
<p>2.入栈。在栈顶插入一个新结点。它分为两步。</p>
<p>第一步，将新节点的指针域指向原头结点。</p>
<p><img src="https://i.loli.net/2018/08/12/5b7020a9b8b28.png"></p>
<p>第二步，头指针上移至新结点。栈长度+1。</p>
<p><img src="https://i.loli.net/2018/08/12/5b702144b88f1.png"></p>
<p>3.出栈。也是分两步。</p>
<p>第一步，头指针指向第二个结点。</p>
<p><img src="https://i.loli.net/2018/08/12/5b7025a28235a.png"></p>
<p>第二步，第一个结点的指针域指向空。</p>
<p><img src="https://i.loli.net/2018/08/12/5b702615e3ceb.png"></p>
<p>4.读栈顶元素</p>
<p>很简单，因为头指针就直接指向栈顶，所以只需要访问头指针所指的结点即可。</p>
<h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><p>和链式栈类似。队首是头结点，队尾是尾结点。</p>
<p>图我就不画了，和链式栈是一样的，只不过头结点指针变成了队首指针，尾结点加一个队尾指针即可。</p>
<p>链式队列的操作也和通常队列几乎一样。</p>
<p>1.初始化队列。</p>
<p>2.入队。在队尾添加一个新结点就好。</p>
<p>第一步，原尾结点的空指针改为指向新结点。</p>
<p>第二步，新节点的指针域指向空。（如果原来就是空的那就不需要这一步）</p>
<p>3.出队。与出栈相同。</p>
<h3 id="线性链表的基本运算"><a href="#线性链表的基本运算" class="headerlink" title="线性链表的基本运算"></a>线性链表的基本运算</h3><p>线性链表的基本运算有很多，比如插入、删除、合并、分解、逆转、复制、排序、查找等。这里主要说一下查找，插入和删除。</p>
<p>1.查找元素</p>
<p>这是删除和插入的基础。因为在链表中，要想在中间插入或删除中间的某个元素，必须要先通过遍历找到它们的位置。</p>
<p>遍历整个列表，在每个结点看值是多少，有就返回已找到，已经到头都找不着就返回没找到。</p>
<p>2.删除元素</p>
<p>思路和上文所述是一致的，遍历一遍整个链表，每次遍历到某个结点，就通过它的指针域看一下下一个结点的数据域是啥，如果是我要删除的元素，那么，我就把当前结点的指针域指向当前指针域指向的结点的指针域指向的下一个结点，然后把要删除的结点的指针域设为空即可。</p>
<p>（有点晕是吧……慢慢捋一下</p>
<p>当前结点是我要删除的结点的前驱结点。我要删除我的后继，我就要把我的后继“孤立”起来。那么我分两步去做这件事。第一步，我要把我的指针域连到跳过这个要删除的结点的位置，也就是我后继的后继。可是我是无法访问我的后继的后继的，我只能通过我的后继去访问我的后继。我有一个通向我后继的指针，当我到达我的后继时，我会再通过我的后继的指针域找到我后继的后继，这个指向我后继的后继的指针域我就找到了，我就可以把我的指针域连在上面。那么我后继的指针怎么处理呢？孤立啊，指向空位置就好。</p>
<p>3.插入元素</p>
<p>我们默认是插入到某结点之后。这个就比较简单了。首先遍历找到这个结点，然后让新结点的指针域指向它的后继，最后让这个结点的指针域指向新结点。</p>
<p>为什么不能先让这个结点的指针域指向新结点呢？</p>
<p>先指过去你的后继不就全没了吗……你还怎么连后边的结点啊……</p>
<p>总结一下，对于链式结构的插入和删除，只需要改变指针域，而不需要移动数据元素。这一点就比线性结构优秀很多。另外，对于删除后被孤立的结点，我们不应让它浪费掉，应该把它送回可利用栈。</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>其实刚才所说的链表还存在一个问题。对于空结点和头结点的插入和删除操作，没法通过循环实现，必须加特判。而且，线性单链表的访问不是自由的，必须从头结点开始，如果想要从中间的结点开始遍历整个链表，可能比较麻烦。这时候，循环链表就可以解决这个问题。</p>
<p>实现很简单。尾结点原本是指空的，只需要指向头结点就可以。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>（PS：栈与队列可以配合<a target="_blank" rel="noopener" href="https://www.cnblogs.com/OIerShawnZhou/p/7277322.html">https://www.cnblogs.com/OIerShawnZhou/p/7277322.html</a>食用）</p>
<p>栈也是线性表的一种。它是一种特殊的线性表。它限定在一段插入或删除。你可以把栈形象地理解为一个任何有底无盖的容器，我们每次对栈进行操作都是在顶部进行。对于这个“容器”，它的顶部我们称之为栈顶，它的底部我们称之为栈底。不难得出一个性质，对于栈顶元素，它总是最后一个被插入，总是最先被删除。我们一般把栈的插入操作叫做入栈，相应的，删除操作叫做出栈(有的也叫退栈)。</p>
<p>栈是按照先进后出（FILO）的原则组织数据的，因此，栈也被称作“先进后出”表或者“后进先出”表。</p>
<p>通常的，我们用一个指针top来表示栈顶的位置。</p>
<p><img src="https://i.loli.net/2018/08/11/5b6e33543ab87.png"></p>
<h3 id="栈在系统中的用途"><a href="#栈在系统中的用途" class="headerlink" title="栈在系统中的用途"></a>栈在系统中的用途</h3><p>举一个简化后的例子好了。比如说一个嵌套调用的程序，计算机怎么处理呢？</p>
<p>先看一下（伪）代码示意：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> main&#123;  </span><br><span class="line">	<span class="comment">//do something.  </span></span><br><span class="line">	f1();  </span><br><span class="line">	<span class="comment">//f1返回后会到达这里，记录返回点地址为A   </span></span><br><span class="line">	<span class="comment">//do something.  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;  </span><br><span class="line">	<span class="comment">//do something.  </span></span><br><span class="line">	f2();  </span><br><span class="line">	<span class="comment">//f2返回后会到达这里，记录返回点地址为B  </span></span><br><span class="line">	<span class="comment">//do something.  </span></span><br><span class="line">	<span class="keyword">return</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;  </span><br><span class="line">	<span class="comment">//do something.  </span></span><br><span class="line">	f3();  </span><br><span class="line">	<span class="comment">//f3返回后会到达这里，记录返回点地址为C  </span></span><br><span class="line">	<span class="comment">//do something.  </span></span><br><span class="line">	<span class="keyword">return</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;  </span><br><span class="line">	<span class="comment">//do something.  </span></span><br><span class="line">	f4();  </span><br><span class="line">	<span class="comment">//f4返回后会到达这里，记录返回点地址为D  </span></span><br><span class="line">	<span class="comment">//do something.  </span></span><br><span class="line">	<span class="keyword">return</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span></span>&#123;  </span><br><span class="line">	<span class="comment">//do something.  </span></span><br><span class="line">	<span class="keyword">return</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>计算机在执行这样的程序的时候，要一层一层地调用函数。而且还要做到进得去，出的来。这就需要一个辅助性的工具来帮助计算机记住进去了哪个函数，从这个函数出来要去哪。</p>
<p>此时，计算机就会使用线性表。它会这样做：</p>
<pre><code>1. 开始执行程序前，计算机申请了一个空表。
2. 当发生函数调用时，计算机会找到它的返回点地址，并且塞到那个线性表的最后面。
3. 当程序从某个子程序返回时，计算机会从线性表中把最后插进去的返回点地址取出，并使用该地址。</code></pre>
<p>模拟一下线性表的工作过程：</p>
<pre><code>1. 一开始是空表[]
2. 进入main函数，遇到了f1，表变成了[A]
3. 进入f1，遇到了f2，表变成了[B]
4. 进入f2，遇到了f3，表变成了[ABC]
5. 进入f3，遇到了f4，表变成了[ABCD]
6. f4执行完毕，要退回f3，f3在哪啊？线性表告诉他，从f4出去要去D位置，于是线性表把D取出来给程序使用，表变成了[ABC]
7. 和上一步一样，从f3出去要到C位置，于是线性表把C取出来。表变成了[AB]
8. 同理，表变成了[A]
9. 程序执行完毕，表又空了[]</code></pre>
<p>这便是一个最简单的栈。</p>
<h3 id="栈的运算"><a href="#栈的运算" class="headerlink" title="栈的运算"></a>栈的运算</h3><p>和线性表一样，在程序设计中，我们也是要使用一维数组设定一个栈，同时要设定一个指针来表示栈顶。</p>
<p>其实有些时候，这里所谓的“指针”，可以不使用真正的指针而是使用一个变量代替，该变量所代表的值即为数组下标，该下标所标注的位置就是栈顶。</p>
<p>1.入栈</p>
<p>之前有说到，入栈运算是指的在栈顶位置插入一个新元素。</p>
<p>首先判断栈满，即判断线性表最后一个位置的指针和栈顶指针是否重合。如果重合，那么说明栈的存储空间已满，是无法进行入栈操作的。</p>
<p>如果栈不满，则栈顶指针上移，入栈。</p>
<p>2.出栈</p>
<p>首先判断栈空，如果栈顶指针与数组头指针重合（或者说，为0），此时是空栈，出栈操作没有意义。</p>
<p>然后（该操作可选）读栈顶元素，并用来做一些其他的事情。</p>
<p>最后栈顶指针-1。</p>
<p>3.访问栈顶元素</p>
<p>仍然需要先判断栈空。如果非空，则返回栈顶元素。这个操作不会删除栈顶元素。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>和排队处理任务时那样，大家都在一条线上等待，早来的早处理。在计算机系统中，如果计算机只能同时做一件事，那么当有多件事需要处理时，其他待做的事情就要“排队等候”。操作系统也会使用一种特殊的线性表来处理这样的排队事件。</p>
<p>这种特殊的线性表就是队列。它允许在一段进行插入，但是删除是在另一端。允许插入的一端称作队尾。（不是队头，一想就明白）允许删除的一端<br>称作队头。显然，在队列中，最先进来的元素一定是最先出去的，所以它是一种先进先出（FIFO）的线性表。</p>
<p><img src="https://i.loli.net/2018/08/11/5b6e490c0f82c.png"></p>
<h3 id="队列的运算"><a href="#队列的运算" class="headerlink" title="队列的运算"></a>队列的运算</h3><p>和栈差不多，入队，出队，读队首。我们假设数组是从左往右走的。</p>
<p>1.入队</p>
<p>首先判断队列有没有满。这里说“队列满”是比较特殊的，它是指队尾指针到达数组尽头。如果不满，则队尾指针+1，入队。</p>
<p>2.出队  </p>
<p>队首指针+1即可，读队首操作也是可选的。</p>
<p>3.访问队首元素</p>
<p>先判断队空，再访问即可。</p>
<p>这里为什么说队列满是特殊的呢？实际上，这里的满是指队尾已到达数组尽头，但是队首可能并不在数组的开始位置，也就是说，这个数组可能是有一部分的空闲的，但此时仍然不能进行入队操作，这是通常队列的一个缺点。</p>
<p>所以，为了解决这个缺点，人们开发出了循环队列。</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>与通常队列很相似，这也是实际应用比较广泛的一种队列，它的空间使用效率较高。</p>
<p>对于循环队列，当队尾已经到达数组尽头而又接收到入队指令时，它会判断队首之前是不是还有空位置，如果有，那么队尾就会跑到数组的前面，形成一个逻辑上的圈。</p>
<p>在循环队列中，队尾指针指向队列中的队尾元素，队首指针指向队首元素的前一个位置。</p>
<p>每进行一次入队运算，队尾指针+1，如果队尾指针=数组长度+1时，让队尾变成0。出队运算也是这样的。</p>
<p>不难得出，循环队列满的时候会有队首指针=队尾指针，但是队空时也满足这个性质。为了区别时队满还是队空，我们有时候会设置一个标记flag，它为0时表示队空，1表示非空。</p>
<p>不难得出，队空满足条件flag = 0。</p>
<p>队满满足条件flag = 1并且队首指针 = 队尾指针</p>
<p>入队运算分三步。  </p>
<p>1.首先判断队列是否为满。当flag = 1并且队尾指针 = 队首指针时，说明队列满，不可以入队。若不满，进入第2步。</p>
<p>2.队尾指针+1，并判断是不是需要变换队尾指针。</p>
<p>3.新元素入队，flag变成1。</p>
<p>出队运算也分三步。如果同时需要取队首元素则是4步。</p>
<p>1.判断队空。如果flag = 0则队空，出队操作无意义。</p>
<p>2.队首指针+1，并判断是不是需要变换队首指针。</p>
<p>3.（可选）返回队首指针所指的元素，可以用来做其他事情。</p>
<p>4.判断出队后队列是否变为空。如果此时队首指针=队尾指针，则说明队列已空，把flag设成0。</p>
<h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><p>在介绍二叉树之前，先介绍一下树是什么。</p>
<p>它是一种一对多的数据结构，对于每一个结点，它只可能有一个前驱或者没有前驱，但是后继可以有一个也可以有多个，当然也可以没有后继。画出来比较像一棵倒长的树。</p>
<p>（图片来自网络）</p>
<p><img src="https://i.loli.net/2018/08/13/5b70fce515831.jpg"></p>
<p>可以看出，它具有很明显的层次关系。在描述各个结点之间的关系时，我们常用一些血缘关系中的术语。</p>
<p>对于一个结点，我们称它的前驱结点为它的父结点。对于最上面的那个没有父结点的结点，我们称之为树的根结点。对于一个结点，它的所有后继都是它的儿子，也就是子结点。</p>
<p>在一棵树中，一个结点所拥有的后继的个数称为该结点的度。这棵树中所有结点的最大的度称为这棵树的度。换句话说，如果一个结点的度数为n，那么就表示这个结点具有n个子结点。在树中，除根结点外，每一个结点都有一个唯一的分支指向它。由此不难得出，树中的结点数等于所有结点的度数+1。</p>
<p>树是按照一定的原则进行分层的。根结点在第一层，同一层上所有结点的子结点都在下一层。其中最底部的结点（叶节点）的层数是最深的。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>一种非常常用也非常有名的数据结构。树结构的术语完全适用于二叉树。</p>
<p>对于一棵二叉树，有且只有一个根节点，并且每一个结点最多有两棵子树，分别称为左子树和右子树。所以，二叉树中每一个结点的最大的度为2。当一个结点没有任何后继时，它是叶结点。</p>
<p>（图片来自网络）</p>
<p><img src="https://i.loli.net/2018/08/13/5b7110c34abfb.jpg"></p>
<h3 id="二叉树的基本性质"><a href="#二叉树的基本性质" class="headerlink" title="二叉树的基本性质"></a>二叉树的基本性质</h3><pre><code>1. 在二叉树的第k层上，最多有2k-1(k≥1)个结点。
2. 深度为m的二叉树最多有2m-1个结点。
3. 在任意一棵二叉树中，度为0的结点总是比度为2的结点多1个。
4. 具有n个结点的二叉树，它的深度至少是[log2n]+1。其中[log2n]是指的是log2n的整数部分。</code></pre>
<h3 id="完全二叉树与满二叉树"><a href="#完全二叉树与满二叉树" class="headerlink" title="完全二叉树与满二叉树"></a>完全二叉树与满二叉树</h3><p>这是两种特殊形式的二叉树。</p>
<p>对于满二叉树，每一层上的结点都会达到它的最大值。也就是说，在第k层，一定有2k-1个结点。深度为m的满二叉树具有2m-1个结点。</p>
<p>完全二叉树只有一点不同。完全二叉树可以在最后一层的最右边缺少一些结点。对于完全二叉树来说，叶结点只有可能在层次最深的两层出现。</p>
<p>所以，满二叉树也算是一种特殊的完全二叉树。但是完全二叉树不一定是满二叉树。</p>
<p>完全二叉树还具有的性质：</p>
<p>具有n个结点的完全二叉树的深度为[log2n]+1。</p>
<p>如果设一个完全二叉树具有n个结点，从根节点开始，按层序用自然数进行编号，那么对于这些编号还具有以下结论：</p>
<pre><code>1. 如果k=1，则这个结点是根节点。如果k&gt;1，那么它的父节点编号是[k/2]。
2. 如果2k≤n，则编号为k的结点的左儿子的编号是2k，否则就没有左子结点。（由于完全二叉树的定义，当一个结点没有左子结点时，一定没有右子结点）
3. 如果2k+1≤n，则编号为k的子结点的右子结点的编号为2k+1，否则该子结点没有右子结点。</code></pre>
<p>根据这些性质，如果按照从上到下，从左到右的顺序给一个完全二叉树进行编号，那么就很容易确定各个结点之间的编号关系。</p>
<h3 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h3><p>和线性链表很类似。对于每个结点要设立两个指针域，一个指向左儿子，一个指向右儿子，如果它没有对应的儿子结点就指空。</p>
<p>要设立头指针指向二叉树的根节点。</p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>所谓二叉树的遍历，即是指不重复地访问二叉树中的所有结点。</p>
<p>由于二叉树是一种非线性结构，因此，对二叉树的遍历要比遍历线性表复杂得多。在遍历到二叉树的某个结点后，要面临两个选择：向左走和向右走。也就是说，遍历二叉树的方法实际上是确定访问各个结点的顺序，以便于不重不漏的访问到所有结点。</p>
<p>通常我们使用三种遍历方法。它们分别是前序遍历，中序遍历和后序遍历。</p>
<pre><code>1. 前序遍历</code></pre>
<p>所谓前序遍历，其实就是先访问根节点，再访问左子树，最后访问右子树。这是一个递归的过程，在每一个子树也要重复这样的过程。</p>
<p>比如还是用这张图来说一下：</p>
<p><img src="https://i.loli.net/2018/08/13/5b7110c34abfb.jpg"></p>
<p>如果二叉树为空则返回，否则先根，再左，最后右。</p>
<p>首先遍历根结点是A，然后是左子树BDEH，然后是右子树CFG。对于左子树再执行一样的操作，遍历出根节点是B，左子树D，右子树EH。对于左子树再执行一样的操作，遍历出左子树是空，右子树是空。对于左子树再执行一样的操作。发现是空，返回。对于右子树再执行一样的操作，发现是空，返回。此时返回到D，对于右子树再执行一样的操作，遍历出根节点是E，左子树是H，右子树是空。对于左子树再执行一样的操作，根节点是H，左右为空，然后去H的左子树，发现是空的，返回，右也是空的，返回。这样以A为根整个的左子树访问完毕，再考虑右子树。右子树根节点是C，左子树是F，右子树是G，F和G没有后继。</p>
<p>这样遍历出一个序列，该序列是ABDEHCFG，它叫做二叉树的前序序列。</p>
<pre><code>2. 中序遍历</code></pre>
<p>中序遍历是指的先访问左子树，再访问根节点，再访问右子树。它也是一个递归的过程。</p>
<p>从A出发，A是根节点，BDEH是左子树。CFG是右子树。去左子树，B是根节点，D是左子树，EH是右子树。去左子树，根节点是D，左右子树为空，去左子树，空，返回，去根节点，是D，去右子树，空，返回。访问完左子树到达根节点B，访问右子树EH。根节点是E，左子树是H，右子树空。访问左子树H，左子树为空，根节点是H，右子树空。访问完左子树，访问根节点E，右子树空。访问根节点A，访问右子树CFG，左子树是F，根节点是C，右子树是G。先访问F，F的左子树为空，右子树为空，再访问根节点C，最后是右子树G，左右子树为空。</p>
<p>这样遍历出一个序列，该序列是DBHEAFCG，它叫做二叉树的中序序列。</p>
<pre><code>3. 后序遍历</code></pre>
<p>后序遍历先访问左子树，再访问右子树，最后是根节点。</p>
<p>从A出发，左子树BDEH，右子树CFG。先遍历左子树，左子树是D，右子树是EH，根节点是B，遍历到D，左右子树为空，回到右子树，左子树是H，右子树空，根节点是E，访问H，再访问E。最后是根节点B。然后是右子树CFG，左子树是F，右子树是G，根节点是C，左子树根节点是F，没有左右子树，右子树根节点是G，没有左右子树。最后是根节点C。然后右子树遍历完毕，最后就是总的根节点A。</p>
<p>这样遍历出一个序列，该序列是DHEBFGCA，它叫做二叉树的后序序列。</p>
<p>直接给出结论，如果知道某二叉树的前序序列和中序序列，那么可以唯一地恢复该二叉树。同样，只要知道后序序列和中序序列也可以唯一地恢复该二叉树，但是只知道前序序列和后序序列是不可以唯一地恢复该二叉树的。</p>
<p>比较绕，要多消化一下。</p>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>为什么要学习这个*东西呢？先来想想二叉树的那三个遍历方法吧。</p>
<p>二叉树的遍历是很多人比较熟悉的，实际上，二叉树的遍历操作就是一个把非线性结构变成线性结构的过程。在线性序列中，每个结点有一个唯一的前驱和唯一的后继（头和尾这种就是有一个没有的）。在这个过程中，我们通过降维打击把树变成了线性表，这破坏了树的结构。有没有一种方法可以做到不进行降维打击也能存储前驱和后继的信息？</p>
<p>其实前驱和后继的信息只需要遍历就能得到的，还是那句话，查询次数多了总有你T的时候。所以还得想个靠谱的办法。</p>
<p>这看起来也许很简单，我在每个结点都保存一个前驱和后继的信息不就可以了？</p>
<p><del>嗯这确实可以，本题结束。</del></p>
<p>此时恰巧一位强迫症的路人经过，他会发现这个结构存储密度特别低，然后感觉非常不适。这是因为什么呢？有结论表明，有n个结点的二叉链表必然存在n+1个空链域。那么问题来了，这n+1个空链域能不能利用起来呢？</p>
<p><del>啊当然这么问的话肯定是能利用的起来是吧</del></p>
<p>实际上，考虑利用这些空链域来存放遍历后结点的前驱和后继信息，这就是线索二叉树构成的思想。采用既可以指示其前驱又可以指示后继的双向链接结构的二叉树被称为线索二叉树。</p>
<p>等等，双向链接结构？二叉链表一般是单向的，这意味着只能通过祖先访问子孙。既然要能够查找前驱，这肯定是不足够的。既然链表可以双向，那二叉链表为什么不可以？这是完全没问题的嘛。</p>
<p>假如这样规定：若结点有左子树，则其lchild表示左孩子，否则令其指示其前驱，若结点有右子树，则其rchild表示右孩子，否则令其指示其后继。同时为了避免混淆（lchild，rchild虽然指示了区域，但是并不知道到底指示的是什么），还需要增加ltag和rtag这两个字段，其中值为0时表示指示孩子，值为1时表示指示前驱或后继。</p>
<pre><code>typedef struct BiThrNode &#123;  
    TElemType data; // TElemType是抽象数据类型啦，它是什么都可以的  
    BiThrNode *lchild, *rchild;  
    int ltag, rtag;  
&#125;BiThrNode, *BiThrTree;  </code></pre>
<p>以这种结点结构构成的二叉链表作为二叉树的存储结构，称为线索链表。其中指向结点前驱和后继的指针称为线索。使用此结点构筑的二叉链表（二叉树）就叫做线索二叉树。对二叉树以某种次序使其变为线索二叉树的过程叫做二叉树的线索化。</p>
<p><img src="https://s2.ax1x.com/2019/11/15/MacExP.png"></p>
<p><img src="https://s2.ax1x.com/2019/11/15/MacOoQ.png" alt="MacOoQ.png"></p>
<p><img src="https://s2.ax1x.com/2019/11/15/Macjij.png" alt="Macjij.png"></p>
<p><img src="https://s2.ax1x.com/2019/11/15/MacvJs.png" alt="MacvJs.png"></p>
<p><img src="https://s2.ax1x.com/2019/11/15/MagFwF.png"></p>
<h3 id="线索二叉树的构造"><a href="#线索二叉树的构造" class="headerlink" title="线索二叉树的构造"></a>线索二叉树的构造</h3><p>由于线索二叉树构造的实质是将二叉链表中的空指针改为指向前驱或后继的线索，而前驱或后继的信息只有在遍历时才能得到，因此线索化的过程即为在遍历的过程中修改空指针的过程。显然，对二叉树按照不同的遍历次序进行线索化得到的线索二叉树是不同的。</p>
<p>为了记下遍历过程中访问结点的先后关系，附设一个指针pre始终指向刚刚访问过的结点，指针p指向当前访问的结点，由此记录下遍历过程中的访问先后关系。</p>
<h4 id="以结点p为根的子树中序线索化"><a href="#以结点p为根的子树中序线索化" class="headerlink" title="以结点p为根的子树中序线索化"></a>以结点p为根的子树中序线索化</h4><pre><code>1. 如果p非空，左子树递归线索化。
2. 如果p的lchild为空，则给p加上左线索，ltag置为1，p的左孩子指针指向pre（前驱），否则将p的ltag置为0.
3. 如果pre的rchild为空，则给pre加上右线索，rtag置为1，pre的右孩子指针指向p（后继），否则将pre的rtag置为0.
4. 将pre指向刚访问过的结点p，即`pre = p;`

void InThreading(BiThrTree p) &#123;  
    if (p) &#123;  
        InThreading(p-&gt;lchild);  
        if (!p-&gt;lchild) &#123;  
            p-&gt;ltag = 1;  
            p-&gt;lchild = pre;  
        &#125;  
    &#125;  
    else &#123;  
        p-&gt;ltag = 0;  
    &#125;  
    if (!pre-&gt;rchild) &#123;  
        pre-&gt;rtag = 1;  
        pre-&gt;rchild = p;  
    &#125;  
    else &#123;  
        p-&gt;rtag = 0;  
    &#125;  
    pre = p;  
    InThreading(p-&gt;rchild);  
&#125;  
/*  
pre是全局变量，初始化时其右孩子指针为空，便于在树的最左点开始建立线索  
*/  </code></pre>
<h4 id="带头结点的二叉树中序线索化"><a href="#带头结点的二叉树中序线索化" class="headerlink" title="带头结点的二叉树中序线索化"></a>带头结点的二叉树中序线索化</h4><pre><code>void InOrderThreading(BiThrTree &amp;thrt, BiThrTree T) &#123;  
    thrt = new BiThrNode;  
    thrt-&gt;ltag = 0;  
    thrt-&gt;rtag = 1;  
    thrt-&gt;rchild = thrt;  
    if (!T)  
        thrt-&gt;lchild = thrt;  
    else &#123;  
        thrt-&gt;lchild = T;  
        pre = thrt;  
        InThreading(T);  
        pre-&gt;rchild=Thrt;  
        pre-&gt;rtag = 1;  
        thrt-&gt;rchild=pre;  
    &#125;  
&#125;  
/*  
pre仍然是全局变量。首先建立头结点，头结点有左孩子，若树非空，则其左孩子为树根，头结点的右孩子指针为右线索。初始化时右指针指向自己，若树为空，则左指针也指向自己。  
头结点的左孩子指向根，pre初值指向头结点。然后调用中序线索化的算法，算法结束后，pre为最右结点，pre的右线索指向头结点。  
*/  </code></pre>
<h3 id="线索二叉树的遍历"><a href="#线索二叉树的遍历" class="headerlink" title="线索二叉树的遍历"></a>线索二叉树的遍历</h3><p>现在我们已经构造好了线索二叉树。好了，现在好像是可以不通过降维打击也能方便查到某个结点的前驱和后继了。</p>
<h4 id="在中序线索二叉树中查找"><a href="#在中序线索二叉树中查找" class="headerlink" title="在中序线索二叉树中查找"></a>在中序线索二叉树中查找</h4><pre><code>1. 查找前驱的方法：

* 若`p-&gt;ltag == 1`，则p的左链指示其前驱
* 若`p-&gt;ltag == 0`，则说明p有左子树，结点的前驱是遍历左子树时最后访问的一个结点（左子树中最右下的结点）。

2. 查找后继的方法：

* 若`p-&gt;rtag == 1`，则p的右链指示其后继
* 若`p-&gt;rtag == 0`，则说明p有右子树。根据中序遍历的规律可知，结点的后继应该是遍历其右子树时访问的第一个结点，即右子树中最左下的结点。</code></pre>
<h4 id="遍历中序线索二叉树"><a href="#遍历中序线索二叉树" class="headerlink" title="遍历中序线索二叉树"></a>遍历中序线索二叉树</h4><p>首先指针p指向根结点，p为非空树或遍历未结束时，循环执行下面的操作：沿左孩子向下，到达最左下结点<code>*p</code>，它是中序的第一个结点；访问<code>*p</code>；沿右线索反复查找当前结点*p的后继结点并访问后继结点，直至右线索为0或者遍历结束；转向p的右子树。</p>
<pre><code>void InOrderTraverse_Thr(BiThrTree T) &#123;  
    p = T-&gt;rchild;  
    while (p != T) &#123;  
        while (p-&gt;ltag == 0)  
            p = p-&gt;lchild;  
        cout &lt;&lt; p-&gt;data;  
        while (p-&gt;rtag == 1 &amp;&amp; p-&gt;rchild != T) &#123;  
            p = p-&gt;rchild;  
            cout &lt;&lt; p-&gt;data;  
        &#125;  
        p = p-&gt;rchild;  
    &#125;  
&#125;  </code></pre>
<p>遍历线索二叉树的时间复杂度为O(n)，空间复杂度为O(1)，这是因为线索二叉树的遍历不需要使用栈来递归操作。</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><p>数据结构课程设计用，简单学一下，不过好像有点难。。？</p>
<p>我想我需要纠正一下这个数据结构的名称，此前我一直称它为B树，但有些教程把它叫做B-树或者B_树，其实它们都是一样的。</p>
<h3 id="B-树的基本概念"><a href="#B-树的基本概念" class="headerlink" title="B-树的基本概念"></a>B-树的基本概念</h3><p>B-树中所有结点中孩子结点个数的最大值成为B-树的阶，通常用m表示，从查找效率考虑，一般要求m&gt;=3。一棵m阶B-树，或者是一棵空树，需要满足下面的特性：</p>
<ul>
<li>树中每个结点至多有 m 棵子树，每个结点最多有m个分支（子树），而最少分支数要看是否为根节点。</li>
<li>除根之外的所有非终端结点至少有两棵子树；根非叶节点至少有ceil(m/2)个分支。（ceil代表向上取整）</li>
<li>所有的非终端结点中包含下列信息数据：（n，A0，K1，A1，K2，A2，…，Kn，An）；</li>
</ul>
<p>其中n为该结点中关键字的个数；ki为该结点的关键字且满足ki &lt; ki+1；Ai为该结点的孩子结点指针，且满足Ai所指结点上的关键字 &gt; Ki 且 &lt;<br>Ki+1，A0所指结点上的关键字小于K1，An所指结点上的关键字 &gt; Kn</p>
<ul>
<li>结点内各关键字互不相等且按从小到大排列，如果一个结点有n-1个关键组，那么该结点有n个分支。</li>
<li>叶子结点处于同一层；可以用空指针表示，是查找失败到达的位置。</li>
</ul>
<p>简单来说，B树的阶是人为定义的，假如有一个4阶的B树，则除了叶结点都是NULL外，其他的结点最多保存3个信息和4个连接域，而且这是互相关联的。如果要保存2个信息则必须是3个连接域，保存1个信息则必须是2个连接域。B树本身也就是一种二叉排序树，所以也适用二叉排序树的一些性质。</p>
<p>下图展示了一个4阶的B树。解释一下每个结点，最左边的数字代表的是这个结点的元素个数，4阶的话元素个数最多是3。对于只有1个元素的结点，应该有2个连接域，对于只有2个元素的结点应该有3个连接域，3个元素的结点应该有4个连接域，多个元素存在的情况下应该保持有序。</p>
<p><img src="http://data.biancheng.net/uploads/allimg/171024/2-1G024101S02K.png"></p>
<p>由于B-树具有分支多层数少的特点，使得它更多应用在数据库系统中。将大型数据库文件存储在硬盘上，为了减少访问次数，就可以使用B-树。它的检索效率很不错。</p>
<p>B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;</p>
<h3 id="B-树的查找操作"><a href="#B-树的查找操作" class="headerlink" title="B-树的查找操作"></a>B-树的查找操作</h3><p>以上图为例，演示一下查找的过程。B树的查找是二叉排序树的扩展，区别在于二叉排序树是二路查找，而B树是多路查找。</p>
<p>又因为B树某结点内部元素是有序的，在结点内查找时可以二分查找来提升速度（确信</p>
<p>假如我们要查找53和20，在查找53的时候，先从根结点开始，比较大小，如果比根大则去右子树，否则去左子树。（二叉排序树性质）</p>
<p>重点来了，现在到了43和78的结点，查找的53要比43大，所以是不会到达39的结点的。然后对比78，如果比78大的话则肯定去了99所在的结点，不过我们查找的53在43和78之间，所以会进47<br>53 64的结点，此时再从左到右进行查找，就可以找到53。</p>
<p>如果要查找20，首先从根节点往左子树出发，发现18，然后往右子树出发，右子树发现27，往左子树出发，发现NULL，表示查找失败，这个B树里没有20。</p>
<blockquote>
<p>叶子结点不保存任何信息，如果某次查找跑到了叶子结点，则表示查找失败。</p>
</blockquote>
<p>B树的标准的查找规则如下，假设查找key：</p>
<pre><code>1. 先让key与根结点中的关键字比较，如果key等于K[i]（K[]为结点内的关键字数组），则查找成功
2. 若key &lt; K[1]，则到A[0]所指示的子树中进行继续查找（A[]为结点内的指针数组），这里要注意B-树中每个结点的内部结构。
3. 若key &gt; K[n]，则到A[n]所指示的子树中继续查找。
4. 若K[i] &lt; key &lt; K[i+1]，则沿着指针A[I]所指示的子树继续查找。
5. 如果最后遇到空指针，则证明查找不成功。</code></pre>
<h3 id="B-树的插入与构筑操作"><a href="#B-树的插入与构筑操作" class="headerlink" title="B-树的插入与构筑操作"></a>B-树的插入与构筑操作</h3><p>B-树也是从空树开始，不断插入新的数据元素构筑的。但是B-<br>树构建的过程与前面的二叉排序树和AVL树不同，B-树在插入新的数据元素时并不是每次都向树中插入新的结点。因为对于m阶的B-<br>树来说，在定义中规定所有的非终端结点（终端结点即叶结点，关键字个数为0）包含关键字个数范围是<code>[ceil(m / 2) - 1, m - 1]</code>，所以在插入新的数据元素时，首先向最底层的某个非终端结点中添加，如果该结点中的关键字个数没有超过m-1，则直接插入成功，否则还需要继续对该结点进行处理。</p>
<p>对于关键字的插入，需要找到插入为位置。在B-<br>树的查找过程中，当遇到空指针时，则证明查找不成功，同时也找到了插入位置，即根据空指针可以确定在最底层非叶节点中的插入位置。由此可见，B树的结点插入总是在终端结点上。但是，在插入过程中有可能会破坏B-<br>树的特征，比如一个4阶的B-树出现了一个结点保存4个数据+5个连接域的情况，这种情况就需要一个“裂开”操作，即拆分结点。</p>
<p>假设有关键字序列<code>&#123;1,2,6,7,11,4,8,13,10,5,17,9,16,20,3,12,14,18,19,15&#125;</code>，以此构筑一棵5阶B-树，过程如下。</p>
<h4 id="确定结点中关键字个数的范围"><a href="#确定结点中关键字个数的范围" class="headerlink" title="确定结点中关键字个数的范围"></a>确定结点中关键字个数的范围</h4><p>由于要求5阶，则关键字个数的范围为2-4。</p>
<p>2是怎么算出来的？因为根非叶节点至少有ceil(m/2)个分支，所以5阶的话最少要有3个分支，3个分支则必定有2条关键字。</p>
<p>4是怎么算出来的？因为是5阶，所以每个结点最多有5个连接域，所以最多有4个关键字。</p>
<h4 id="确定根节点"><a href="#确定根节点" class="headerlink" title="确定根节点"></a>确定根节点</h4><p>由于根节点可以最多容纳4个信息，则根节点应该是下图这样：</p>
<p><img src="https://s2.ax1x.com/2019/12/15/QfCiKf.png"></p>
<h4 id="插入后续节点-拆分操作"><a href="#插入后续节点-拆分操作" class="headerlink" title="插入后续节点 拆分操作"></a>插入后续节点 拆分操作</h4><p>当准备插入11时，11是不可以再插入到根节点了，因为这样关键字的个数变成了5，超出了范围，此时需要进行拆分操作。</p>
<p>拆分时需要取关键字数组的中间位置，这里由于11的加入，关键字的个数会变成5，取中间位置应该是3而不是2。我们让k[3] =<br>6作为一个新的根节点，6左右的关键字分别做成两个结点，作为新结点的两个分支。此时变成了这样。</p>
<p><img src="https://s2.ax1x.com/2019/12/15/QfPiWR.png"></p>
<p>新关键字总是插在叶子结点上。当插入4 8 13后，树变成了：</p>
<p><img src="https://s2.ax1x.com/2019/12/15/QfiFAg.png"></p>
<p>插入关键字10需要插在8和11之间，此时又会出现需要拆分的情况，拆分时需要把10放入根节点，并把10左右的关键字拆成两个新结点连在根节点上。</p>
<p>（图我不画了，太麻烦了QAQ）</p>
<p>按照上述步骤，插入过程中不超范围就直接插，超出范围就让它裂开，最后它会变成这样：</p>
<p>（手画了个，将就着看吧x）</p>
<p><img src="https://s2.ax1x.com/2019/12/15/Qfk861.jpg"></p>
<p>需要注意一个事，插入最后一个关键字15,15应该插入在14之后，此时会出现关键字个数超出范围的情况，则需要拆分，13并入根节点，13并入根节点后，根节点超出范围，需要再次拆分，10作为新的根节点，并将10左右的关键字做成两个新节点连接到新的根节点。这种插入一个关键字后出现多次拆分的情况称为连锁反应。</p>
<h3 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B-树的删除"></a>B-树的删除</h3><p>对于删除，我们需要先找到待删除的关键字，但是直接的删除是不可以的，因为这有可能会破坏B-<br>树的特性。比如旧关键字删除之后结点的个数不再满足定义，此时需要做出一些调整。可能需要向其兄弟结点借一些关键字或者和其孩子结点进行关键字的交换，也可能需要进行结点的合并，其中，和当前结点的孩子进行关键字交换的操作可以保证删除操作总是发生在终端结点上。</p>
<p>删除关键字8和16，关键字8在终端结点上，并且删除后所在结点关键字个数不会超出限制，所以可以直接删除。关键字16不在终端结点上，但是可以用17覆盖16，然后把原来的17删除掉。这里便是与孩子结点进行关键字交换的操作。这里不能用15和16进行关键字交换，因为这样会导致15所在结点中关键字的个数小于2。</p>
<p><img src="https://s2.ax1x.com/2019/12/15/QfEKz9.jpg"></p>
<p>删除关键字15，15虽然也在终端结点上，但是不能直接删除，因为删除后当前结点中关键字的个数小于2，这样不满足5阶B树的定义。此时需要向其兄弟结点借关键字，显然应该向其右兄弟来借关键字，因为左兄弟的关键字个数已经是下限2。借关键字不能直接将18移到15所在的结点上，因为这样会使得15所在的结点上出现比17大的关键字，所以正确的借法应该是先用17覆盖15，再用18覆盖原来的17，最后删除原来的18。<br><img src="https://s2.ax1x.com/2019/12/15/QfEtiD.jpg"></p>
<p>删除关键字4，4在终端结点上，但是此时4所在的结点的关键字个数已经到下限，需要借关键字。不过可以看到其左右兄弟结点已经没有多余的关键字可借。所以就需要进行关键字的合并。可以先将关键字4删除，然后将关键字5、6、7、9进行合并作为一个结点链接在关键字3右边的指针上，也可以将关键字1、2、3、5合并作为一个结点链接在关键字6左边的指针上。但是这样单纯的合并后仍然不可以，因为会出现非根的双分支结点（我就不画图了这个），这样需要继续进行合并。</p>
<p><img src="https://s2.ax1x.com/2019/12/15/QfEToT.jpg"></p>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Index</span> &#123;</span>  </span><br><span class="line">	<span class="built_in">string</span> id;  </span><br><span class="line">	<span class="keyword">int</span> loc;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//B-Tree 结点  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTreeNode</span> &#123;</span>  </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">	<span class="comment">//string *keys;//存储关键字的数据  </span></span><br><span class="line">	Index* keys;  </span><br><span class="line">	<span class="keyword">int</span> t; <span class="comment">//最小度 (决定了key的数量范围)  </span></span><br><span class="line">	BTreeNode** C; <span class="comment">//存储孩子结点的数组  </span></span><br><span class="line">	<span class="keyword">int</span> n; <span class="comment">//现在key的个数  </span></span><br><span class="line">	<span class="keyword">bool</span> leaf; <span class="comment">//如果这个结点是一个叶子 则为TRUE , 否则 为FALSE  </span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">	BTreeNode(<span class="keyword">int</span> <span class="keyword">_t</span>, <span class="keyword">bool</span> _leaf);  </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">()</span></span>; <span class="comment">//遍历以该结点为根的子树中所有结点  </span></span><br><span class="line">	<span class="function">BTreeNode* <span class="title">search</span><span class="params">(Index k)</span></span>;<span class="comment">//在以该节点为根的子树中查找键为k的结点  </span></span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insertNonFull</span><span class="params">(Index k)</span></span>;  </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">splitChild</span><span class="params">(<span class="keyword">int</span> i, BTreeNode* y)</span></span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BTree</span>;</span>  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTree</span> &#123;</span>  </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">	BTreeNode* root; <span class="comment">//根节点的指针  </span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="comment">//最小度  </span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">	BTree(<span class="keyword">int</span> <span class="keyword">_t</span>) &#123;  </span><br><span class="line">		root = <span class="literal">NULL</span>; t = <span class="keyword">_t</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">		<span class="keyword">if</span> (root != <span class="literal">NULL</span>) root-&gt;traverse();  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="function">BTreeNode* <span class="title">search</span><span class="params">(Index k)</span> </span>&#123;  </span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> root-&gt;search(k);  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Index _k)</span></span>;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">BTreeNode::BTreeNode(<span class="keyword">int</span> <span class="keyword">_t</span>, <span class="keyword">bool</span> _leaf) &#123;  </span><br><span class="line">	t = <span class="keyword">_t</span>;  </span><br><span class="line">	leaf = _leaf;  </span><br><span class="line">	keys = <span class="keyword">new</span> Index[<span class="number">2</span> * t - <span class="number">1</span>]; <span class="comment">//一个结点key最多有2*t-1个  </span></span><br><span class="line">	C = <span class="keyword">new</span> BTreeNode * [<span class="number">2</span> * t]; <span class="comment">//一个结点孩子最多有2*t个  </span></span><br><span class="line">	n = <span class="number">0</span>; <span class="comment">//新建结点当前key的数量为0  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BTreeNode::traverse</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="comment">// 有n个key和n+1个子key，遍历n个key  </span></span><br><span class="line">	<span class="comment">// 还有前n个子key  </span></span><br><span class="line">	<span class="keyword">int</span> i;  </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;  </span><br><span class="line">		<span class="comment">// 如果这不是叶节点，在打印key[i]之前先遍历以C[i]为根的子树  </span></span><br><span class="line">		<span class="keyword">if</span> (leaf == <span class="literal">false</span>)  </span><br><span class="line">			C[i]-&gt;traverse();  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; keys[i].id;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">// 打印最后一个子树的根  </span></span><br><span class="line">	<span class="keyword">if</span> (leaf == <span class="literal">false</span>)  </span><br><span class="line">		C[i]-&gt;traverse();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function">BTreeNode* <span class="title">BTreeNode::search</span><span class="params">(Index k)</span> </span>&#123;  </span><br><span class="line">	<span class="comment">// 找到第一个大于等于k的key  </span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">while</span> (i &lt; n &amp;&amp; k.id &gt; keys[i].id)  </span><br><span class="line">		i++;  </span><br><span class="line">	<span class="comment">//如果找到的key值等于k，则返回此结点  </span></span><br><span class="line">	<span class="keyword">if</span> (keys[i].id == k.id)  </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;  </span><br><span class="line">	<span class="comment">// 如果这里没有找到key而这里是一个叶节点  </span></span><br><span class="line">	<span class="keyword">if</span> (leaf == <span class="literal">true</span>)  </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">	<span class="comment">// 去找一个适当的子树继续查询  </span></span><br><span class="line">	<span class="keyword">return</span> C[i]-&gt;search(k);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BTree::insert</span><span class="params">(Index k)</span> </span>&#123;  </span><br><span class="line">	<span class="comment">//如果树为空  </span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">		root = <span class="keyword">new</span> BTreeNode(t, <span class="literal">true</span>);  </span><br><span class="line">		root-&gt;keys[<span class="number">0</span>] = k; <span class="comment">//插入 key  </span></span><br><span class="line">		root-&gt;n = <span class="number">1</span>; <span class="comment">//更新当前root结点的key的个数为1  </span></span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">else</span> &#123;<span class="comment">//树不为空  </span></span><br><span class="line">		<span class="comment">// 如果树的根结点已满，则树的高度会增加  </span></span><br><span class="line">		<span class="keyword">if</span> (root-&gt;n == <span class="number">2</span> * t - <span class="number">1</span>) &#123;  </span><br><span class="line">			BTreeNode* s = <span class="keyword">new</span> BTreeNode(t, <span class="literal">false</span>);  </span><br><span class="line">			<span class="comment">// 旧的根结点成为新的根节点的孩子  </span></span><br><span class="line">			s-&gt;C[<span class="number">0</span>] = root;  </span><br><span class="line">			<span class="comment">// 拆分旧根结点并将一个key移动到新根结点上  </span></span><br><span class="line">			s-&gt;splitChild(<span class="number">0</span>, root);  </span><br><span class="line">			<span class="comment">// 新的根节点现在有了两个子结点。现在决定两个子结点中的哪一个会有新的key  </span></span><br><span class="line">			<span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">			<span class="keyword">if</span> (s-&gt;keys[<span class="number">0</span>].id &lt; k.id)  </span><br><span class="line">				++i;  </span><br><span class="line">			s-&gt;C[i]-&gt;insertNonFull(k);  </span><br><span class="line">			<span class="comment">//改变根节点  </span></span><br><span class="line">			root = s;  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">else</span>  </span><br><span class="line">			root-&gt;insertNonFull(k);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 在此结点中插入新key  </span></span><br><span class="line"><span class="comment">// 假设在调用这个函数时，结点必须是非满的  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BTreeNode::insertNonFull</span><span class="params">(Index k)</span> </span>&#123;  </span><br><span class="line">	<span class="comment">//将index初始化为最右边元素的索引  </span></span><br><span class="line">	<span class="keyword">int</span> i = n - <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 如果这是一个叶节点  </span></span><br><span class="line">	<span class="keyword">if</span> (leaf == <span class="literal">true</span>) &#123;  </span><br><span class="line">		<span class="comment">// 下面的循环做两件事  </span></span><br><span class="line">		<span class="comment">// a) 查找要插入新key的未知  </span></span><br><span class="line">		<span class="comment">// b) 将所有较大的key移动到前方一个位置  </span></span><br><span class="line">		<span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; keys[i].id &gt; k.id) &#123;  </span><br><span class="line">			keys[i + <span class="number">1</span>] = keys[i];  </span><br><span class="line">			i--;  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="comment">// 在找到的位置插入新的key  </span></span><br><span class="line">		keys[i + <span class="number">1</span>] = k;  </span><br><span class="line">		n = n + <span class="number">1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">// 如果这个结点不是叶节点  </span></span><br><span class="line">		<span class="comment">// 找到将拥有新key的子结点  </span></span><br><span class="line">		<span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; keys[i].id &gt; k.id)  </span><br><span class="line">			i--;  </span><br><span class="line">  </span><br><span class="line">		<span class="comment">// 查看找到的子元素是否已满  </span></span><br><span class="line">		<span class="keyword">if</span> (C[i + <span class="number">1</span>]-&gt;n == <span class="number">2</span> * t - <span class="number">1</span>) &#123;  </span><br><span class="line">			<span class="comment">// 如果某个子结点已满，则需要对子结点进行拆分  </span></span><br><span class="line">			<span class="comment">// 机翻：如果孩子吃饱了，就把它切开（草 我裂开了  </span></span><br><span class="line">			splitChild(i + <span class="number">1</span>, C[i + <span class="number">1</span>]);  </span><br><span class="line">  </span><br><span class="line">			<span class="comment">// 执行拆分操作后，C[i]中间的key会上升一级，并且C[i]会一分为二  </span></span><br><span class="line">			<span class="comment">// 看看哪一个会得到新key  </span></span><br><span class="line">			<span class="keyword">if</span> (keys[i + <span class="number">1</span>].id &lt; k.id)  </span><br><span class="line">				i++;  </span><br><span class="line">		&#125;  </span><br><span class="line">		C[i + <span class="number">1</span>]-&gt;insertNonFull(k);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 分割此结点的子结点y  </span></span><br><span class="line"><span class="comment">// 注意，当调用这个函数时，y必须是满的  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BTreeNode::splitChild</span><span class="params">(<span class="keyword">int</span> i, BTreeNode* y)</span> </span>&#123;  </span><br><span class="line">	<span class="comment">// 创建一个将要存储y结点的t-1个key的新结点  </span></span><br><span class="line">	BTreeNode* z = <span class="keyword">new</span> BTreeNode(y-&gt;t, y-&gt;leaf);  </span><br><span class="line">	z-&gt;n = t - <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 复制y中最后t-1个key到z  </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t - <span class="number">1</span>; j++)  </span><br><span class="line">		z-&gt;keys[j] = y-&gt;keys[j + t];  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 复制y中最后t的子结点到z  </span></span><br><span class="line">	<span class="keyword">if</span> (y-&gt;leaf == <span class="literal">false</span>) &#123;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t; ++j)  </span><br><span class="line">			z-&gt;C[j] = y-&gt;C[j + t];  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 减少y中的key数量  </span></span><br><span class="line">	y-&gt;n = t - <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 因为这个结点将有一个新的子结点，所以要给新的子结点开辟空间  </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= i + <span class="number">1</span>; --j)  </span><br><span class="line">		C[j + <span class="number">1</span>] = C[j];  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 将新的子结点链接到此结点  </span></span><br><span class="line">	C[i + <span class="number">1</span>] = z;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 一个y的key将会移动到这个结点，找到新key的位置并将所有较大的key移动一个位置。  </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= i; --j)  </span><br><span class="line">		keys[j + <span class="number">1</span>] = keys[j];  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 将y中间的key复制到这个结点  </span></span><br><span class="line">	keys[i] = y-&gt;keys[t - <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 此结点中的键数量增加1  </span></span><br><span class="line">	n++;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="function">BTree <span class="title">t</span><span class="params">(<span class="number">3</span>)</span></span>;  </span><br><span class="line">	t.insert(&#123; <span class="string">&quot;10&quot;</span>,<span class="number">1</span> &#125;);  </span><br><span class="line">	t.insert(&#123; <span class="string">&quot;20&quot;</span>,<span class="number">2</span> &#125;);  </span><br><span class="line">	t.insert(&#123; <span class="string">&quot;5&quot;</span>,<span class="number">3</span> &#125;);  </span><br><span class="line">	t.insert(&#123; <span class="string">&quot;6&quot;</span>,<span class="number">4</span> &#125;);  </span><br><span class="line">	t.insert(&#123; <span class="string">&quot;12&quot;</span>,<span class="number">5</span> &#125;);  </span><br><span class="line">	t.insert(&#123; <span class="string">&quot;30&quot;</span>,<span class="number">6</span> &#125;);  </span><br><span class="line">	t.insert(&#123; <span class="string">&quot;7&quot;</span>,<span class="number">7</span> &#125;);  </span><br><span class="line">	t.insert(&#123; <span class="string">&quot;17&quot;</span>,<span class="number">8</span> &#125;);  </span><br><span class="line">  </span><br><span class="line">	t.traverse();  </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">	Index k = &#123; <span class="string">&quot;20&quot;</span>,<span class="number">2</span> &#125;;  </span><br><span class="line">	<span class="keyword">if</span> (t.search(k) != <span class="literal">NULL</span>)  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;exist&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">	<span class="keyword">else</span>  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not exist&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>B-树及其基本操作（插入和删除）详解 <a target="_blank" rel="noopener" href="http://data.biancheng.net/view/60.html">http://data.biancheng.net/view/60.html</a></p>
<p>B-树（B树）详解 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7dedb7ebe033">https://www.jianshu.com/p/7dedb7ebe033</a></p>
<p>平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27700617">https://zhuanlan.zhihu.com/p/27700617</a></p>
<p>代码是我同学给的，我把里面的注释给翻译了一下</p>
<h2 id="哈希与哈希表"><a href="#哈希与哈希表" class="headerlink" title="哈希与哈希表"></a>哈希与哈希表</h2><p>曾经也是学过的东西，现在重新学一遍。其实就是通过一个人为制造的函数H，把一些比较大的数字或者字符串转化成能直接通过变量或者数组下标表示的东西，这个函数就是哈希函数。通过哈希函数转化得到的数值一般称之为哈希值。通过哈希值可以快速查找和匹配。</p>
<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><p>用来解决子串类问题。一个比较常见的问题是寻找长度为n的主串上出现了多少次长度为m的子串，这类问题可以使用kmp解决，也可以使用字符串哈希解决。但是如果是这种问题：从主串中每次选取两个子串，问是否匹配（可能相当大），此时便只能使用字符串哈希。</p>
<p>具体操作？哈希函数并不是一个具体的函数，它是可以进行人为定义的，任何一种可以离散化的方法都可以作为一个哈希函数使用。一个比较简单直观的方法是取余法，令hash(k)<br>= k % m，m代表哈希表的大小，取决于你的空间。m越小哈希冲突概率越大， m越大空间开销越大，所以m的值要合理分配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> seed = (随便一个数);  </span><br><span class="line">    <span class="keyword">int</span> m = HASH_SIZE;  </span><br><span class="line">    <span class="keyword">int</span> Hash = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> len = s.length();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;  </span><br><span class="line">        Hash = (Hash * seed + x[i] - <span class="string">&#x27;0&#x27;</span>) % m;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> Hash;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这样可以在O(n)的复杂度内完成哈希操作。但是这样做缺点是明显的，极有可能哈希冲突，也就是不同的串得到了相同的哈希值，这样可能会导致错误。解决哈希冲突的方法有多种，这里介绍双哈希。其实就是把哈希函数再写一遍，这次换一个不同的种子，只有两个哈希值都相等才能断定两个字符串相等。实际证明这个方法实用性不错。</p>
<p>下面介绍一下滚动哈希的优化技巧。选取两个合适的互质常数b和h(b &lt; h)，假设有字符串C = c1c2…cm，那么定义哈希函数Hash(C) =<br>(c1bm-1+c2bm-2+…+cmb0) % h</p>
<p>正常的数字是十进制的，这里相当于把字符串C看成一个b进制的“数”，用b做基数。这一过程是递推计算的，设Hash(C,k)为前k个字符构成的字符串的哈希值，则有H(C,k+1)<br>= H(C,k) × b + ck+1 （暂不考虑取模）</p>
<p>通常，题目要求的是判断主串的一段字符与另一个字符串是否匹配，即判断字符串C = c1c2…cm从k+1位置的长度n的子串C’ =<br>ck+1ck+2…ck+n的哈希值与另一匹配字符串S = s1s2…sn的哈希值是否相等，于是有Hash(C’) = Hash(C,k+n) -<br>Hash(C,k) × bn</p>
<p>（代码有问题，debug中）</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表是一种高效的数据结构，它的优点同字符串哈希一样，查找的算法时间效率几乎就是常数，同时也很容易实现，多产生的代价仅仅是消耗较多内存。</p>
<p>假设现在有一个线性表A(1,75,324,1353,43,91,40)，用n代表元素个数，存储它很简单，只需要一个一维数组。但是这样的数据结构为查找带来了麻烦。如果是顺序存放还好说，我们可以使用二分查找，但是大部分情况下序列是无序的，我们只能使用线性复杂度的算法进行查找。但当n非常大时，速度依然会变得很慢。</p>
<p>我们考虑使用“桶”，开一个特殊的数组，其下标最大值为序列A中的最大值，也就是有一个数组b[1354]（C/C++中数组从0开始，长度为n的话最大值到n-1，这里应该是1354而不是1353）,然后我们令A中的所有元素都在这个b数组里“对号入座”，将数值作为下标，值只有0和1两种（其实不拘泥于这两个数，只是比较常用，只要能区分“有”和“没有”就可以），这样根据这个“桶”来进行查找，时间复杂度变成了常数。但这样仍然会存在一个问题，数组下标并不能很大，这样对于大数据来说仍然是不太合适的。并且这样会造成很大的空间浪费。不过我们可以采用哈希技术，为每个数设置一个哈希值。人为构造哈希函数Hash(x)<br>= x % 123，这样所有的数都变成了0到122之间的数，空间变小了很多。</p>
<p>实际上，这样做仍然存在问题。单纯的进行取模操作会导致大量的数据经过哈希操作后有重复，这就是哈希冲突。那么在查询时就有概率出现错误。哈希表与字符串哈希有所不同，有时题目的测试数据足够大，导致无论如何选择哈希函数都无法避免冲突，而且为了避免冲突去刻意构造一个复杂的哈希函数也得不偿失。这里我们的做法是使用链表。当发生冲突时把这个值挂在链表的下一个结点上，这样虽然查找时的复杂度不是严格的O(1)，但是期望仍然是O(1)，实际复杂度取决于链表长度，也就是冲突的程度。</p>
<p>假设以6为模数，哈希表应该是类似于下面这样：</p>
<p><img src="https://i.loli.net/2019/01/25/5c4b0e213f608.png"></p>
<p>（实际上，实际使用的模数一般要比6大得多，而且一般都是质数，这里仅是举例）</p>
<p>显然，如何构造哈希函数是决定哈希表查找效率的关键。因为只要哈希值的分布足够平均，链表查找的复杂度就会变小。下面是三种比较常用的哈希函数构造方法，</p>
<p>1.取余法</p>
<p>选择一个适当的正整数m，用原数据对m取模的结果作为哈希值，也就是Hash(x) = x %<br>m，这个方法应用是比较广泛的，使用率也比较高。这个方法的关键在于如何选取合适的m，一般是选择一个比较大的质数，这里给出一个从网上找的常用取模质数表，可供参考：</p>
<blockquote>
<p>61, 83, 113, 151, 211, 281, 379, 509, 683, 911 / 一千以下</p>
</blockquote>
<blockquote>
<p>1217, 1627, 2179, 2909, 3881, 6907, 9209, /一万以下</p>
</blockquote>
<blockquote>
<p>12281, 16381, 21841, 29123, 38833, 51787, 69061, 92083, /十万以下</p>
</blockquote>
<blockquote>
<p>122777, 163729, 218357, 291143, 388211, 517619, 690163, 999983, /百万以下</p>
</blockquote>
<blockquote>
<p>1226959, 1635947, 2181271, 2908361, 3877817, 5170427, 6893911, 9191891,<br>/千万以下</p>
</blockquote>
<blockquote>
<p>12255871, 16341163, 21788233, 29050993, 38734667, 51646229,68861641,<br>91815541,/一亿以下</p>
</blockquote>
<blockquote>
<p>1e9+7 和 1e9+9 //十亿左右</p>
</blockquote>
<blockquote>
<p>122420729,163227661,217636919,290182597,386910137,515880193,687840301,917120411,/十亿以下</p>
</blockquote>
<blockquote>
<p>1222827239,1610612741, 3221225473ul, 4294967291ul /十亿以上</p>
</blockquote>
<p>一般来说，如果m的约数越多，造成冲突的概率就会越大，所以尽量选择质数。</p>
<p>2.乘积取整法</p>
<p>用值乘以一个在(0,1)中的实数A（最好是无理数，(√5 -<br>1)/2是一个实际效果很不错的数），这样能得到一个(0,k)之间的实数，取其小数部分再乘以哈希表的大小M，再向下取整，然后得到在哈希表中的位置。</p>
<p>这个听起来就挺麻烦的（摊）</p>
<p>3.基数转换法</p>
<p>类似于字符串哈希使用的方法：将值看成是另一种进制的数，然后把它转化成十进制数，然后用取余法。一般取大于10的数作为转换基数，并且最好和原来进制的10互质。比如将一个十进制数强行看作是13进制，然后按照进制转换规则转成10进制，就得到一个值。</p>
<p>听起来也好麻烦。。。</p>
<p>事实上，哈希函数的构造方法有很多，并没有硬性规定，能避免冲突就可以。</p>
<p>取余法代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500000  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m 999983  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> tot, adj[maxn], nxt[maxn], num[maxn];  </span><br><span class="line"><span class="keyword">int</span> top, stk[maxn];  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="comment">//初始化哈希表，在多组数据时用来清空哈希表  </span></span><br><span class="line">	<span class="comment">//用一个栈存储出现过的哈希值，每次只要把出现过的哈希值的链表清零就可以，节省时间  </span></span><br><span class="line">	tot = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">while</span> (top) &#123;  </span><br><span class="line">		adj[stk[top--]] = <span class="number">0</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;  </span><br><span class="line">	<span class="comment">//使用取余法进行插入  </span></span><br><span class="line">	<span class="keyword">int</span> h = key % m;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> e = adj[h]; e; e = nxt[e]) &#123;  </span><br><span class="line">		<span class="keyword">if</span> (num[e] == key)  </span><br><span class="line">			<span class="keyword">return</span>;   <span class="comment">//遍历链表如果已经出现过这个值就没必要再存一遍  </span></span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">if</span> (!adj[h])   <span class="comment">// 如果能走到这里说明这个值没存过，要进行存储，把第一次出现的哈希值入栈  </span></span><br><span class="line">		stk[++top] = h;  </span><br><span class="line">	nxt[++tot] = adj[h];  </span><br><span class="line">	adj[h] = tot;  </span><br><span class="line">	num[tot] = key; <span class="comment">//用类似于建立邻接表的方式建立链表，存储下所有哈希值等于h的数字  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;  </span><br><span class="line">	<span class="comment">//查询操作  </span></span><br><span class="line">	<span class="comment">//先求哈希值再遍历链表，查找到则表示存在  </span></span><br><span class="line">	<span class="keyword">int</span> h = key % h;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> e = adj[h]; e; e = nxt[e]) &#123;  </span><br><span class="line">		<span class="keyword">if</span> (num[e] == key)  </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="comment">//此处请自由发挥  </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>一种时间复杂度为log级别的数据结构，支持单点维护和求区间和。树状数组可以在大数据下快速计算区间和以及维护最大值最小值。</p>
<p>lowbit操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m&amp;(-m);<span class="comment">//位运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求前缀区间和：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumele</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        sum += c[n];</span><br><span class="line">        n -= lowbit(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单点更新：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=n)&#123;</span><br><span class="line">        c[i] += val;</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它只是一种维护的手段，实质上还是求区间和。</p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>本能反应是想到一个菊花型的结构。</p>
<p><img src="https://i.loli.net/2018/11/19/5bf2ad9da9236.png"></p>
<p>这其实是用路径压缩形成的一种很特殊的树形结构，每棵树的根节点都是一个代表元素。</p>
<p>并查集初始化时，集合的每个元素都是自己是自己的代表元素，所以</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    father[i] = i;</span><br></pre></td></tr></table></figure>

<p>用它就可以初始化一个并查集。</p>
<p>合并集合很简单，把一棵树上的根节点变成另一棵树上的子结点就好。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x = find(x);</span><br><span class="line">    y = find(y);</span><br><span class="line">    father[y] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并查集的路径压缩的查找祖先方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (father[x] == x)</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">    father[x] = find(father[x]);<span class="comment">//如果当前节点的father并不是代表元素，那就递归地更新老祖宗</span></span><br><span class="line">    <span class="keyword">return</span> father[x];<span class="comment">//返回老祖宗</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断两个元素是否在同一集合：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x = find(x);</span><br><span class="line">    y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (x==y)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><p>图是一种多对多的数据结构，通俗的来讲，有一些点，点和点之间由各种边相连，就是一个图。精准的定义：图是一种这样的数据结构，假如把图记作G，则有G =<br>(V,E)，V是图上的点构成的集合，E是点与点之间的关系构成的集合，即边集合。可以看出，图其实是由两个集合构成的数据结构。</p>
<p>简单来区分的话，图分为有向图和无向图。有向图的边是有方向的，如果有A→B，则并不一定有B→A。但如果是无向图，则当A和B之间存在边时，一定是A↔B，即当A能走到B时，B也能走到A。</p>
<p>方便起见，引入一些基本术语：</p>
<blockquote>
<p>结点的度：无向图中与结点相连的边的数目，称为结点的度。</p>
<p>结点的入度：在有向图中，以这个结点为终点的有向边的数目。</p>
<p>结点的出度：在有向图中，以这个结点为起点的有向边的数目。</p>
<p>权值：边的“费用”，可以形象地理解为边的长度。</p>
<p>连通：如果图中结点U，V之间存在一条从U通过若干条边、点到达V的通路，则称U、V 是连通的。</p>
<p>回路：起点和终点相同的路径，称为回路，或“环”。</p>
<p>完全图：一个n 阶的完全无向图含有n×(n-1)/2 条边；一个n 阶的完&gt; &gt; 全有向图含有n×(n-1)条边；</p>
<p>稠密图：一个边数接近完全图的图。</p>
<p>稀疏图：一个边数远远少于完全图的图。</p>
</blockquote>
<p>需要注意，只有有向图才存在入度和出度的概念，在无向图中只有度而没有入度和出度。</p>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><p>一般有两种实现方式，一种是邻接矩阵，另一种是邻接表。邻接邻接，相邻连接，连者为邻，互利互通。这个名字还是不难理解的。</p>
<p>邻接矩阵比较适合理解图的结构，具有直观，好写的优点。</p>
<p>定义二维数组G[][]，对任意的G[i][j]，代表从点i到点j的边的权值。如果该图的边无权，则只需要定义成0-1型就好。对于无向图，满足G[i][j] =<br>G[j][i]。如果i与j之间不存在边，则定义为INF或者-1。（INF：infinity，即无穷，无限大，一般为2147483647，即int范围的最大值）</p>
<p>举例：</p>
<p><img src="https://i.loli.net/2019/01/28/5c4ef5d2caf29.png"></p>
<p>它们所对应的邻接矩阵如下：</p>
<p><img src="https://i.loli.net/2019/01/28/5c4ef77d58535.png"></p>
<p>建立邻接矩阵的代码模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2333  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> g[maxn][maxn];  </span><br><span class="line"><span class="keyword">int</span> n, m;  </span><br><span class="line"><span class="keyword">int</span> edgeNum;  </span><br><span class="line"><span class="keyword">int</span> from, to, dis;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; edgeNum;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;  </span><br><span class="line">			g[i][j] = INF;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">//初始化邻接矩阵，初始全部为INF表示全都不连通  </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= edgeNum; i++) &#123;  </span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; from &gt;&gt; to &gt;&gt; dis;  </span><br><span class="line">		g[from][to] = dis;  </span><br><span class="line">		g[to][from] = dis; <span class="comment">// 如果是有向图，这个语句就不能有  </span></span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">//此处请自由发挥  </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>快速初始化的方法：使用ctsdlib里面的memset函数对数组进行初始化，使用memset(g, 0x7f,<br>sizeof(g))可以把数组全都初始化成一个很大的数，memset(g, 0, sizeof(g))全部初始化为0，memset(g, 0xaf,<br>sizeof(g))初始化为一个很小的数。</p>
<p>然而，实际应用中邻接表使用的并不是很广泛，反而是邻接表使用较为广泛。</p>
<p>前置知识：链表的使用</p>
<p>邻接表存储法又叫图的链式存储法，它的原理是根据图上的每一个结点建立一个链表，在图上这个点每连接一个其他点，就把这个点的编号塞到链表后面，这样一个点与其连接的所有点就连成了一条链，将一张图上所有点的这个链弄出来排在一起，成为一个表状结构，就是邻接表。</p>
<p>举例：</p>
<p><img src="https://i.loli.net/2019/01/28/5c4ef5d2caf29.png"></p>
<p>这里只说下图A吧，B和C类似。对于V1，它连接V2,V3,V4，那么以V1为首的链表后面连接的结点就是V2,V3,V4（顺序不一定非得是这个，顺序只能表明先连的哪个点后连的哪个点。）对于V2，连接V1和V4和V3，对于V3，连接V2和V1，对于V4，连接V1和V2。画出图来大概是这样：</p>
<p><img src="https://i.loli.net/2019/01/28/5c4efe5ca4f90.png"></p>
<p>建立邻接表需要使用到结构体，它记录边的信息，一般是记录起止点和权值。然后开一个该结构体类型的数组代表的就是边集。你问点集怎么表示？点集不用表示。（想一想，为什么）</p>
<p>然后我们需要一个head数组，对于任意的head[i]，代表的是以i点开头的链表的“位置”，这个位置是虚拟的，也正是这个数组模拟链表的关键所在。初学者在这里比较难以理解，简单来讲这可以用来代替链表的“指针域”进行存储。进行加边操作的时候需要对边数进行计数，from对应的是head[from]，因为一个点为首的只有一条链表，这一步是找到这个链表的头，然后是to对to，dis对dis，最后更新一下head[from]为当前边数即可。严格来讲这个理解可能并不是很严谨，如果想深入理解可以查阅其他资料，或者选择基于实用主义，不求甚解。</p>
<p>建立邻接表的代码模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2333  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span>  </span><br><span class="line">	<span class="keyword">int</span> from, to, dis;  </span><br><span class="line">&#125;;  </span><br><span class="line">Edge edge[maxn];  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> head[maxn], from, to, dis;  </span><br><span class="line"><span class="keyword">int</span> totEdge = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">int</span> n, m;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dis)</span> </span>&#123;  </span><br><span class="line">	edge[++totEdge].from = head[from];  </span><br><span class="line">	edge[totEdge].to = to;  </span><br><span class="line">	edge[totEdge].dis = dis;  </span><br><span class="line">	head[from] = totEdge;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;  </span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; from &gt;&gt; to &gt;&gt; dis;  </span><br><span class="line">		addEdge(from, to, dis);  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">//此处请自由发挥  </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><p>引入带权图和无权图的概念。对于边有权值的图我们叫做带权图，否则叫做无权图。边的权值可以理解为两点之间的距离，或者移动的代价，花费等等。一张图中可能会有很多带有权值的路径把点连接起来，对于图的最短路，分为单源最短路和多源最短路。单源最短路指的是从一点出发到达图中某点的最短路径，多源最短路指的是任意两点之间的最短路。解决最短路径的算法有很多，但是每种算法都有一定的适用范围。</p>
<h4 id="多源最短路：Floyed算法"><a href="#多源最短路：Floyed算法" class="headerlink" title="多源最短路：Floyed算法"></a>多源最短路：Floyed算法</h4><p>多适用于邻接矩阵，时间复杂度O(n³)，适用负边权</p>
<p>令dis[u][v]表示从u到v的最短路径长度，w[u][v]表示连接u，v边的长度。</p>
<p>首先初始化所有的dis，如果对于任意u,v有边相连则dis[u][v] = w[u][v]，如果没有则dis[u][v] = INF。</p>
<p>算法过程：</p>
<pre><code>for (int k = 1; k &lt;= n; k++) &#123; //这层循环必须放在最外面  
    for (int i = 1; i &lt;= n; i++) &#123;  
        for (int j = 1; j &lt;= n; j++) &#123;  
            if (dis[i][j] &gt; dis[i][k] + dis[k][j])  
                dis[i][j] = dis[i][k] + dis[k][j];  
        &#125;  
    &#125;  
&#125;  </code></pre>
<p>嗯，浑身上下散发着动态规划的味道。这的确是个动态规划，三层循环，第一层循环中间点k，第二第三层循环起点终点i、j，算法的思想很容易理解：如果点i到点k的距离加上点k到点j的距离小于原先点i到点j的距离，那么就用这个更短的路径长度来更新原先点i到点j的距离。</p>
<p>假设现在有一无向图。有一条从点1到点2的带权边为6，有一条从点1到点3的带权边为2，有一条从点3到点2的带权边为1，可以知道dis[1][2] =<br>6,dis[1][3] = 2,dis[2][3] =<br>1，这是初状态。因为dis[1][3]+dis[3][2]&lt;dis[1][2]，所以就用dis[1][3]+dis[3][2]来更新原先1到2的距离。如果两者之间有最短路径的话，就会更新成最短路径的长度。</p>
<p>变形：</p>
<pre><code>for (int k = 1; k &lt;= n; k++) &#123; //这层循环必须放在最外面  
    for (int i = 1; i &lt;= n; i++) &#123;  
        for (int j = 1; j &lt;= n; j++) &#123;  
             dis[i][j] = dis[i][j] || (dis[i][k] &amp;&amp; dis[k][j]);  
        &#125;  
    &#125;  
&#125;  </code></pre>
<p>如果是一个没有边权的图，把相连的两点间的距离设为dis[i][j]=true，不相连的两点设为dis[i][j]=false,用这个办法可以判断一张图中的两点是否相连。</p>
<h4 id="单源最短路：Dijkstra算法"><a href="#单源最短路：Dijkstra算法" class="headerlink" title="单源最短路：Dijkstra算法"></a>单源最短路：Dijkstra算法</h4><p>多适用于邻接表，时间复杂度O(n2)（未经优化），O((n+m)logm)（加入堆优化），不适用负边权</p>
<p>也就是所谓的迪杰斯特拉算法。它是基于一个贪心的思想。从起点V0开始，每次新扩展一个距离最短的点，然后再以这个点为中间点去更新起点到其他所有点的距离。它无法处理边权有负的情况。由于所有的边权都是正，所以不会存在一个距离更短的没有扩展过的点。也就是说每次扩展都要保证路径是当前最短，所以当前这个点到起点的距离永远不会再被改变一次，从而保证算法的正确性。</p>
<p>设起点为s，dis[v]表示从s到v的最短路径，pre[v]为v的前驱节点，用来输出路径。首先初始化：dis[v]=∞(v≠s); dis[s]=0;<br>pre[s]=0;</p>
<p>然后是伪代码：</p>
<pre><code>for (i = 1 to n) &#123;
    在没有被访问过的点中找一个顶点u使得dis[u]是最小的
    u标记为已确定最短路径
    for 与u相连的每个未确定最短路径的顶点v
        if (dis[u]+w[u][v] &lt; dis[v]) &#123;
            dis[v] = dis[u] + w[u][v];
            pre[v] = u;
        &#125;
&#125;</code></pre>
<p>算法结束后，dis[v]为s到v的最短距离；pre[v]为v的前驱节点，用来输出路径。如果不需要pre数组的话可以不加。</p>
<p>这里为什么只给出了伪代码？因为实际使用的Dijkstra大多是优化之后的算法。</p>
<p>（以下文字摘自信息学奥赛一本通课件）</p>
<p>算法思想：从起点到一个点的最短路径一定会经过至少一个“中转点”（例如下图1到5的最短路径，中转点是2。特殊地，我们认为起点1也是一个“中转点”）。显而易见，如果我们想求出起点到一个点的最短路径，那我们必然要先求出中转点的最短路径（例如我们必须先求出点2<br>的最短路径后，才能求出从起点到5的最短路径）。换句话说，如果起点1到某一点V0的最短路径要经过中转点Vi，那么中转点Vi一定是先于V0被确定了最短路径的点。</p>
<p><img src="https://i.loli.net/2019/01/28/5c4f10843d6e9.png"></p>
<p>我们把点分为两类，一类是已确定最短路径的点，称为“白点”，另一类是未确定最短路径的点，称为“蓝点”。如果我们要求出一个点的最短路径，就是把这个点由蓝点变为白点。从起点到蓝点的最短路径上的中转点在这个时刻只能是白点。</p>
<p>Dijkstra的算法思想，就是一开始将起点到起点的距离标记为0，而后进行n次循环，每次找出一个到起点距离dis[u]最短的点u，将它从蓝点变为白点。随后枚举所有的蓝点vi，如果以此白点为中转到达蓝点vi的路径dis[u]+w[u][vi]更短的话，这将它作为vi的“更短路径”dis[vi]（此时还不确定是不是vi的最短路径）。</p>
<p>就这样，我们每找到一个白点，就尝试着用它修改其他所有的蓝点。中转点先于终点变成白点，故每一个终点一定能够被它的最后一个中转点所修改，而求得最短路径。</p>
<p>模拟这个过程，算法开始时，作为起点的dis[1] = 0，其他的点dis[i] = INF。</p>
<p>第一轮循环找到dis[1]最小，将1变成白点。对所有的蓝点做出修改，使得dis[2]=2,dis[3]=4,dis[4]=7。</p>
<p>第二轮循环找到dis[2]最小，将2变成白点。对所有的蓝点做出修改，使得dis[3]=3,dis[5]=4。这时dis[2]，dis[3]，dis[4]被它的最后一个中转点1修改为了最短路径。</p>
<p>第三轮循环找到dis[3]最小，将3变成白点。对所有的蓝点做出修改，使得dis[4]=4。发现以3为中转不能修改5，说明3不是5的最后一个中转点。这时dis[3]，dis[5]被它们的最后一个中转点2修改为了最短路径。</p>
<p>接下来的两轮循环将4、5也变成白点。N轮循环结束后，所有的点的最短路径即能求出。这时dis[4]也被它的最后一个中转点3修改为了最短路径。</p>
<p>Dijkstra无法处理边权为负的情况。 比如下图这样的图：</p>
<p><img src="https://i.loli.net/2019/01/28/5c4f12447246e.png"></p>
<p>2到3的边权值为-4，显然从起点1到3的最短路径是-2（1→2→3），但是dijskstra在第二轮循环开始时会找到当前dis[i]最小的点3，并标记它为白点。这时的dis[3]=1，然而1却不是从起点到点3的最短路径。因为3已被标记为白点，最短路径值dis[3]不会再被修改了，所以我们在边权存在负数的情况下得到了错误的答案。</p>
<p>堆优化：使用堆来优化查找操作。</p>
<p>堆优化之后的Dijkstra:（陈年老代码了，代码风格与现在略有不同）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">int</span> n,m,s,head[<span class="number">50010</span>],cnt;  </span><br><span class="line">ll dis[<span class="number">10010</span>];   </span><br><span class="line"><span class="keyword">bool</span> used[<span class="number">10010</span>];  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> to,from,dis;  </span><br><span class="line">&#125;edge[<span class="number">500010</span>];  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> dis)</span></span>&#123;  </span><br><span class="line">    edge[cnt].to=v;  </span><br><span class="line">    edge[cnt].from=head[u];  </span><br><span class="line">    edge[cnt].dis=dis;  </span><br><span class="line">    head[u]=cnt++;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;  </span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt; q;  </span><br><span class="line">    fill(dis,dis+n+<span class="number">1</span>,INF);  </span><br><span class="line">    fill(used,used+n+<span class="number">1</span>,<span class="literal">false</span>);  </span><br><span class="line">    dis[s]=<span class="number">0</span>;  </span><br><span class="line">    q.push(P(<span class="number">0</span>,s));  </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;  </span><br><span class="line">        P p=q.top();q.pop();  </span><br><span class="line">        <span class="keyword">int</span> u=p.second;  </span><br><span class="line">        <span class="keyword">if</span>(used[u]) <span class="keyword">continue</span>;  </span><br><span class="line">        used[u]=<span class="literal">true</span>;  </span><br><span class="line">        <span class="keyword">int</span> pp=head[u];  </span><br><span class="line">        <span class="keyword">while</span>(pp!=<span class="number">-1</span>)&#123;  </span><br><span class="line">            <span class="keyword">int</span> v=edge[pp].to;  </span><br><span class="line">            <span class="keyword">if</span>(!used[v]&amp;&amp;dis[v]&gt;dis[u]+edge[pp].dis)&#123;  </span><br><span class="line">                dis[v]=dis[u]+edge[pp].dis;  </span><br><span class="line">                q.push(P(dis[v],v));  </span><br><span class="line">            &#125;  </span><br><span class="line">            pp=edge[pp].from;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));  </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;  </span><br><span class="line">        <span class="keyword">int</span> u,v,d;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;d);  </span><br><span class="line">        add_edge(u,v,d);  </span><br><span class="line">    &#125;  </span><br><span class="line">    dijkstra(s);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,dis[i]);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<h4 id="单源最短路：Bellman-Ford算法"><a href="#单源最短路：Bellman-Ford算法" class="headerlink" title="单源最短路：Bellman-Ford算法"></a>单源最短路：Bellman-Ford算法</h4><p>（经过队列优化后的中国叫法是SPFA），多适用于邻接表，时间复杂度O(NE)（未经优化，N为点数，E为边数），O(kE)（k是常数，加入队列优化），适用负边权</p>
<p>同样是用来计算从一个点到其他所有点的最短路径的算法，也是一种单源最短路径算法。能够处理存在负边权的情况，但无法处理存在负权回路的情况。经过改造后的SPFA算法是笔者最喜欢也是最常用，同时也是最容易被卡的最短路算法。</p>
<p>（以下文字摘自信息学奥赛一本通课件）</p>
<p>设s为起点，dis[v]即为s到v的最短距离，pre[v]为v前驱。w[j]是边j的长度，且j连接u、v。初始化：dis[s]=0,dis[v]=∞（v≠s），pre[s]=0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= E; j++)    <span class="comment">//注意要枚举所有边，不能枚举点。</span></span><br><span class="line">       <span class="keyword">if</span> (dis[u]+w[j]&lt;dis[v]) &#123;  <span class="comment">//u、v分别是这条边连接的两个点。</span></span><br><span class="line">           dis[v] =dis[u] + w[j];</span><br><span class="line">           pre[v] = u;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>Bellman-Ford算法的思想很简单。一开始认为起点是白点(dis[1]=0)，每一次都枚举所有的边，必然会有一些边，连接着白点和蓝点。因此每次都能用所有的白点去修改所有的蓝点，每次循环也必然会有至少一个蓝点变成白点。在下面这个简单的模拟中能看到白点的“蔓延”情况。</p>
<p><img src="https://i.loli.net/2019/01/28/5c4f16f7d2a95.png"></p>
<p>虽然Bellman-<br>Ford算法可以求出存在负边权情况下的最短路径，却无法解决存在负权回路的情况。负权回路指一个环，这个环上所有的权值都为负，也可以理解成是指边权之和为负数的一条回路。如果图中出现负环会发生什么？</p>
<p><img src="https://i.loli.net/2019/01/28/5c4f17620d151.png"></p>
<p>负权回路是指边权之和为负数的一条回路，上图中②-④-⑤-③-<br>②这条回路的边权之和为-3。在有负权回路的情况下，从1到6的最短路径是多少？答案是无穷小，因为我们可以绕这条负权回路走无数圈，每走一圈路径值就减去3，最终达到无穷小。<br>所以说存在负权回路的图无法求出最短路径，Bellman-Ford算法可以在有负权回路的情况下输出错误提示。<br>如果在Bellman-Ford算法的两重循环完成后，还是存在某条边使得：dis[u]+w&lt;dis[v]，则存在负权回路：</p>
<pre><code>for 每条边(u,v) 
    if (dis[u]+w&lt;dis[v])  
        return false</code></pre>
<p>优化：SPFA算法</p>
<p>SPFA算法在国际上通称为“经过队列优化的Bellman-Ford算法”，仅在中国流行SPFA这种名字。</p>
<p>设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路估计值对u点所指向的结点v进行松弛操作。如果v点的最短路估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断地从队列中取出结点来进行松弛操作，直到队列为空。这个算法保证只要最短路存在，SPFA算法必定能求出最小值。SPFA算法同样可以判断负环。额外设立一个inq数组，某个点入队的次数超过n次时，可以判断负环存在并且提前退出。</p>
<p>这个算法，简单的说就是队列优化的bellman-ford，利用了每个点不会更新次数太多的特点发明的此算法。</p>
<p>SPFA<br>在形式上和广度优先搜索非常类似，不同的是广度优先搜索中一个点出了队列就不可能重新进入队列，但是SPFA中一个点可能在出队列之后再次被放入队列，也就是说一个点修改过其它的点之后，过了一段时间可能会获得更短的路径，于是再次用来修改其它的点，这样反复进行下去。<br>算法时间复杂度：O(kE)，E是边数。K是常数，平均值为2。</p>
<p>SPFA代码模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 5000015  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(x) memset(x,0,sizeof(x));  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> from,to,dis;  </span><br><span class="line">&#125;;  </span><br><span class="line">Edge edge[maxn];  </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n,m,s,u,v,d;  </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> head[maxn];  </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> dis[maxn];  </span><br><span class="line"><span class="keyword">bool</span> inq[maxn];  </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> from,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> to,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> dis)</span></span>&#123;  </span><br><span class="line">    edge[++cnt].from = head[from];  </span><br><span class="line">    edge[cnt].to = to;  </span><br><span class="line">    edge[cnt].dis = dis;  </span><br><span class="line">    head[from] = cnt;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt; q;  </span><br><span class="line">    q.push(s);  </span><br><span class="line">    ms(inq);  </span><br><span class="line">    inq[s] = <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)  </span><br><span class="line">        dis[i] = INF;  </span><br><span class="line">    dis[s] = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;  </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> u = q.front();  </span><br><span class="line">        q.pop();  </span><br><span class="line">        inq[s] = <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=head[u];i!=<span class="number">0</span>;i=edge[i].from)&#123;  </span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> v = edge[i].to;  </span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> w = edge[i].dis;  </span><br><span class="line">            <span class="keyword">if</span> (dis[u]+w &lt; dis[v])&#123;  </span><br><span class="line">                dis[v] = w+ dis[u];  </span><br><span class="line">                <span class="keyword">if</span> (!inq[v])&#123;  </span><br><span class="line">                    q.push(v);  </span><br><span class="line">                    inq[v] = <span class="literal">true</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;  </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; d;  </span><br><span class="line">        add_edge(u,v,d);  </span><br><span class="line">    &#125;  </span><br><span class="line">    spfa();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>该算法的速度非常之快，但当该算法运行在稠密图或者人为构造的网格图上，该算法的复杂度极有可能退化成O(NE)。</p>
<h3 id="最小生成树-MST"><a href="#最小生成树-MST" class="headerlink" title="最小生成树(MST)"></a>最小生成树(MST)</h3><p>生成树的定义：在一个有n个点的无向图中，取其中n-1条边，连接所有的顶点，得到一个子图，这个子图便是原图的一个生成树。</p>
<p>为什么说子图是树？实际上，树是图的一种特殊形态。这里便扩充了一下图的定义：</p>
<p>图G是树当且仅当下面的任意一个条件成立：</p>
<p>1.G有n-1条边，不存在环</p>
<p>2.G有n-1条边，连通</p>
<p>3.G的任意两点之间只有唯一的简单路径。</p>
<p>4.G连通，但任意删除一条边后就不再连通。</p>
<p>引入最小生成树的概念：在一个带权的无向连通图中，各边权和最小的一棵生成树即为原图的最小生成树。</p>
<p>最小边原则：图中权值最小的边（如果唯一）一定在最小生成树上。</p>
<p>图的最小生成树的唯一性定理：对于一个图G，如果图中的边权值互不相同，则图中的最小生成树一定是唯一的，反之则不然。</p>
<p>最小生成树用来解决类似于使用最小代价用n-1条边连接n个点的问题。比如架设快速道路或者架设网线要求花费最少。</p>
<h3 id="Prim算法-时间复杂度O-n²"><a href="#Prim算法-时间复杂度O-n²" class="headerlink" title="Prim算法 时间复杂度O(n²)"></a>Prim算法 时间复杂度O(n²)</h3><p>（以下文字摘自信息学奥赛一本通课件）</p>
<p>Prim算法采用与Dijkstra、Bellman-Ford算法一样的“蓝白点”思想：白点代表已经进入最小生成树的点，蓝点代表未进入最小生成树的点。</p>
<p>算法描述：</p>
<p>以1为起点生成最小生成树，min[v]表示蓝点v与白点相连的最小边权。</p>
<p>MST表示最小生成树的权值之和。</p>
<pre><code>a）初始化：min[v]= ∞(v≠1); min[1]=0;MST=0;
b）for (i = 1; i&lt;= n; i++)
1.寻找min[u]最小的蓝点u。
2.将u标记为白点
3.MST+=min[u]
4.for 与白点u相连的所有蓝点v  
    if (w[u][v]&lt;min[v]) 
        min[v]=w[u][v];
c）算法结束： MST即为最小生成树的权值之和</code></pre>
<p>算法分析&amp;思想讲解：</p>
<p>Prim算法每次循环都将一个蓝点u变为白点，并且此蓝点u与白点相连的最小边权min[u]还是当前所有蓝点中最小的。这样相当于向生成树中添加了n-1次最小的边，最后得到的一定是最小生成树。</p>
<p>算法证明：</p>
<p>①当只取了一个点K时（边集为空），一定存在一个MST，包含当前的点集和边集。</p>
<p>②假设存在一个MST包含当前的点集和边集。当前点集为S，剩下的点集为S’。设跨越S-S’的最小代价的边为(u,v)。</p>
<p>反证法：假设取的是跨越S-S’的某边(u’,v’)，删除(u’,v’)加入(u,v)，S和S’分别连通，且S-S’通过(u,v)也能连通，这样会得到一个更小权值的MST，所以新加入的边一定是代价最小的边(u,v)。</p>
<p>Q.E.D</p>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>时间复杂度O(ElogE)（E为边数）</p>
<p>前置知识：并查集</p>
<p>Kruskal（克鲁斯卡尔）算法是一种巧妙利用并查集来求最小生成树的算法。我们把无向图中相互连通的一些点称为处于同一个连通块中。Kruskal算法将一个连通块当做一个集合。Kruskal首先将所有的边按从小到大顺序排序（一般使用快排），并认为每一个点都是孤立的，分属于n个独立的集合。然后按顺序枚举每一条边。如果这条边连接着两个不同的集合，那么就把这条边加入最小生成树，这两个不同的集合就合并成了一个集合；如果这条边连接的两个点属于同一集合，就跳过。直到选取了n-1条边为止。</p>
<p>算法描述:</p>
<pre><code>初始化并查集。father[x]=x。
tot=0
将所有边用快排从小到大排序。
计数器 k=0;
for (i=1; i&lt;=M; i++)      //循环所有已从小到大排序的边
  if  这是一条u,v不属于同一集合的边(u,v)&#123; (因为已经排序，所以必为最小)，
    　①合并u,v所在的集合，相当于把边(u,v)加入最小生成树。
　    ②tot=tot+W(u,v)
      ③k++
      ④如果k=n-1,说明最小生成树已经生成，则break; 
  &#125;
结束，tot即为最小生成树的总权值之和。</code></pre>
<p>Kruskal在初始时认为所有的点都是孤立的。然后它枚举所有边（已按边权排好序），枚举到某边的时候会判断这条边连接的两点是否在同一集合里，如果不是则说明这条边一定在最小生成树里，则加入这一条边。一张n个点的图总共选取n-1次边。因为每次我们选的都是最小的边，所以最后的生成树一定是最小生成树。每次我们选的边都能够合并两个集合，最后n个点一定会合并成一个集合。通过这样的策略，Kruskal算法就能得到一棵有n-1条边，连接着n个点的最小生成树。</p>
<p>Kruskal模板：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
#include &lt;algorithm&gt;  
#define maxn 5005  
#define maxm 200005  
using namespace std;  
struct Edge&#123;  
    int from,to,dis;  
    bool operator &lt;(const Edge &amp;rhs)const&#123;  
        return dis &lt; rhs.dis;  
    &#125;  
&#125;;  
Edge edge[maxm];  
int father[maxm];  
int n,m;  
int totedge = 0;  
int k = 0;  
int ans = 0;  
inline int read()&#123;  
    int num = 0;  
    char c;  
    bool flag = false;  
    while ((c = getchar()) == &#39; &#39; || c == &#39;\n&#39; || c == &#39;\r&#39;);  
    if (c == &#39;-&#39;)  
        flag = true;  
    else  
        num = c - &#39;0&#39;;  
    while (isdigit(c = getchar()))  
        num = num * 10 + c - &#39;0&#39;;  
    return (flag ? -1 : 1) * num;  
&#125;      
void init()&#123;  
    for (register int i=1;i&lt;=m;i++)  
        father[i] = i;  
&#125;  
int find(int x)&#123;  
    if (father[x] == x)  
        return father[x];  
    father[x] = find(father[x]);  
    return father[x];  
&#125;  

void merge(int x,int y)&#123;  
    father[find(x)]  = find(y);  
&#125;  

int main()&#123;  
    n = read();m = read();  
    for (register int i=1;i&lt;=m;i++)&#123;  
        edge[i].from = read();  
        edge[i].to = read();  
        edge[i].dis = read();  
    &#125;  
    sort(edge+1,edge+m+1);  
    init();  
    while (totedge &lt; n-1)&#123;  
        if (find(edge[++k].from) != find(edge[k].to))&#123;  
            ans += edge[k].dis;  
            merge(edge[k].from,edge[k].to);  
            totedge++;  
        &#125;  
    &#125;  
    printf(&quot;%d\n&quot;,ans);  
    return 0;  
&#125;  </code></pre>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>啥叫拓扑？百度百科这样说：</p>
<blockquote>
<p>拓扑是研究几何图形或空间在连续改变形状后还能保持不变的一些性质的一个学科。它只考虑物体间的位置关系而不考虑它们的形状和大小。拓扑英文名是Topology，直译是地志学，最早指研究地形、地貌相类似的有关学科。几何拓扑学是十九世纪形成的一门数学分支，它属于几何学的范畴。有关拓扑学的一些内容早在十八世纪就出现了。那时候发现的一些孤立的问题，在后来的拓扑学的形成中占着重要的地位。</p>
</blockquote>
<p>简单来讲，拓扑研究的是图形的位置关系。而拓扑排序也就是指对一张有向无环图的所有点的次序进行排序，最后得到一个序列，而这个排序的规则便就是按照相连的先后顺序进行排序，这个排序就叫做拓扑排序。更简单的说，拓扑排序是把一个图变成一个序列。做成的这个序列就叫做拓扑序列。</p>
<p>引入新概念。</p>
<blockquote>
<p>有向无环图（DAG）：在图论中，如果一个有向图无法从某个顶点出发经过若干条边回到该点，则这个图是一个有向无环图（DAG图）。</p>
</blockquote>
<p>对拓扑排序的讨论均是建立在有向无环图上的。所以本栏目里面所说的图，如果不加特殊注明，均指有向无环图。构造拓扑序列可以帮助我们合理安排一个工程的进度，由DAG构造拓扑序列具有很高的实际应用价值。</p>
<p>举个最简单的例子，游戏的技能树就是一个很简单的有向无环图（之前说到，树也是图的一种）。假设有这么一个设定：所有的后续技能学习都需要一些前置技能的要求，也就是说如果你要学习一个新技能，必须要满足之前的某些技能是掌握的。那么对这个技能树进行拓扑排序，得到的就是一个拓扑序列，它代表着你先学了什么后学了什么。</p>
<p>而构造拓扑排序算法很简单。假如使用邻接表，需要稍稍改动一下加边函数，在里面统计一下某个点的入度，比如from a to<br>b的一条边，一旦成立，b的入度就会+1。这样建图后我们可以得到一个数组，里面保存着各个点的入度信息。</p>
<p>然后我们扫描一下这个数组，寻找入度为0的点（如果保证原图是DAG，则这样的点一定存在）。把所有入度为0的点压入一个队列（不要只找到一个就结束这个操作，因为在DAG里可能存在多个入度为0的点）。</p>
<p>然后我们用一个while(!q.empty())控制循环。每次从队首取出一个结点（并且将这个结点弹出），这是当前遍历到的结点，将它输出（这里的输出并不是说非得要输出，因为题和题不一样，这里也有可能是其他操作，或者说是保存起来方便下一步操作），然后遍历所有与这个点连接的点（直接邻接表遍历操作就可以），把扫描到的点都入度-1，如果-1后入度变成了0，说明这应该是下一步要进行遍历的结点，就把这个结点入队。重复操作，直到队空为止，最后生成的序列就是拓扑序列。</p>
<p><img src="https://i.loli.net/2019/01/30/5c5191b87f551.png"></p>
<p>比如说这个图，首先找到入度为0的点是只有A，把A入队。取队头是A，输出，弹出，然后遍历队头A的连接点，先找到B，入度-1后是0，入队，找到C，入度-1后是0，入队，D也是这样。一遍找完了，再回到开头取找队头，取队头是B，输出，弹出，然后遍历队头B的连接点，找到E，入度-1后变成2，不入队。找完B了找下一个队头是C，遍历C的连接点，找到E，入度-1后变成1。然后是D，这里再进行一步减入度的操作E的入度就变成了0，这里E就可以入队了。最后就是E。这样它的拓扑序列就是ABCDE。</p>
<p>Tips:使用队列那里并不强求，其实使用栈也是可以的。这也就意味着，一个DAG的拓扑序列可能不是唯一的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 23333  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span>  </span><br><span class="line">	<span class="keyword">int</span> from, to, dis;  </span><br><span class="line">&#125;;  </span><br><span class="line">Edge edge[maxn];  </span><br><span class="line"><span class="keyword">int</span> n, m, s, u, v, d;  </span><br><span class="line"><span class="keyword">int</span> inDegree[maxn];  </span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">int</span> head[maxn];  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dis)</span> </span>&#123;  </span><br><span class="line">	edge[++tot].from = head[from];  </span><br><span class="line">	edge[tot].to = to;  </span><br><span class="line">	edge[tot].dis = dis;  </span><br><span class="line">	head[from] = tot;  </span><br><span class="line">	inDegree[to]++;  <span class="comment">// update in-degree  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;  </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  </span><br><span class="line">		<span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>)  </span><br><span class="line">			q.push(i);  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;  </span><br><span class="line">		<span class="keyword">int</span> u = q.front();  </span><br><span class="line">		q.pop();  </span><br><span class="line">		output(u);  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = edge[i].from) &#123;  </span><br><span class="line">			<span class="keyword">int</span> v = edge[i].to;  </span><br><span class="line">			inDegree[v]--;  </span><br><span class="line">			<span class="keyword">if</span> (inDegree[v] == <span class="number">0</span>)  </span><br><span class="line">				q.push(v);  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;  </span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; d;  </span><br><span class="line">		addEdge(u, v, d);  </span><br><span class="line">	&#125;  </span><br><span class="line">	topoSort();  </span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://shawnzhou.world/2019/12/15/data-structure/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%BE/" rel="tag">图</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="tag">并查集</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" rel="tag">树状数组</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" rel="tag">线性表</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2020/01/14/html5/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            html5学习笔记
          
        </div>
      </a>
    
    
      <a href="/2019/09/02/opencv-collection/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">OpenCV相关图形操作整合</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "YolIyMzPHjxT49twQAhzxsQ8-gzGzoHsz",
    app_key: "Dtrq0zAmtB8CqcKdwVCk7JBn",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2018-2022
        <i class="ri-heart-fill heart_icon"></i> Shawn Zhou
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 框架强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://v1.cnzz.com/z_stat.php?id=1279352967&amp;web_id=1279352967'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/avatar1.png" alt="ShawnZhou的小站"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">图集</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://friends.shawnzhou.world/">友链站</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://dev.shawnzhou.world/">开发站</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://sources.shawnzhou.world/">资源站</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>感谢打赏~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://shawnzhou.world/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://shawnzhou.world/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>