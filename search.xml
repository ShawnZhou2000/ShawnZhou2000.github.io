<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vue2.x与3.x的变化侦测原理分析</title>
    <url>/2022/01/20/vue-change-detect/</url>
    <content><![CDATA[<p>Vue 的一大特性是可以由数据的变化引起DOM的变化，这得益于它设计精巧的响应式系统。一个 Vue 应用程序在运行时会因为数据的变化而不断进行重新渲染，Vue 的响应式系统就赋予了框架重新渲染的能力。</p>
<p>变化侦测是实现响应式系统的核心，实习结束，拿起去年看不懂的《深入浅出 Vue.js 》开始二刷，记录一下心得体会。</p>
<p>书中介绍的是 Vue 2 版本的变化侦测原理，本篇文章同时也会将 Vue 3版本的变化侦测原理补充进去。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/03beb31eae77c48735c5cef42762dc8a.jpg"></p>
<a id="more"></a>

<h2 id="Vue-2-的变化侦测"><a href="#Vue-2-的变化侦测" class="headerlink" title="Vue 2 的变化侦测"></a>Vue 2 的变化侦测</h2><p>Vue 使用 “推” 的方式侦测状态变化，相比于 React 的“拉” 来说，拥有更细的粒度。“推”类型的变化侦测可以在状态变化时立刻得知变化内容，并且可以进行视图更新操作。</p>
<p>在 Vue 2 中，对 Object 和 Array 的变化侦测方式是不一样的。</p>
<h3 id="Object-的变化侦测原理"><a href="#Object-的变化侦测原理" class="headerlink" title="Object 的变化侦测原理"></a>Object 的变化侦测原理</h3><p>Vue 2 中侦测 Object 变化的核心方法是<code>Object.defineProperty</code>，对数据的读取和写入做一层劫持，即每当从这个对象的一个键中读取一个值时，就触发这个组合上的 get 方法，每当设置一个新的键值对或者更改已有的键值对时，就触发这个组合上的 set 方法。在 Vue 中，这个操作由 <code>defineReactive</code> 方法封装。</p>
<p>首先我们需要能对一个对象中的一个属性进行劫持，即让这个属性的读写操作都必须经过一次我们自己设定的方法，这样我们才可以方便进行下一步操作。思考一下 Vue ，当在一个<code>&lt;template&gt;</code>中使用到了多个<code>&#123;&#123; name &#125;&#125;</code>，那么当 data 中的 name 变化时，我们必须让所有用到name的地方都进行变化，这其实就是我们劫持数据的目的，需要在变化时通知使用了这些数据的地方，那些地方就是我们的<strong>依赖</strong>。</p>
<p>对于依赖，无非是两种操作：收集依赖和触发依赖。Vue 是这么做的：在 get 方法中收集依赖，在 set 方法中触发依赖。收集依赖的意思是找到所有用到这个数据的地方，触发依赖的意思是将所有找到的依赖进行更新。</p>
<p>你倒是可以直接在原来的代码基础上直接进行依赖收集操作，但不如把“依赖”这个东西直接抽象成一个类，因为会经常用到，这样减少一下耦合。依赖要怎么保存呢？首先想到的就是一个数组，收集依赖就是将多个依赖依次装入数组中，触发依赖则遍历数组，将每个依赖的值进行更新。</p>
<p>我们取依赖的单词 dependency，声明一个 Dep 类，并把添加依赖，删除依赖，通知依赖更新的操作都封装起来，然后只需要修改一下原有的<code>defineReactive</code>方法，在<code>Object.defineProperty</code>之前 new 一个 Dep 类，然后在 set 和 get 里面分别调用一下通知依赖更新和添加依赖就可以了。</p>
<p>等等，“通知依赖”这个操作是不是还有些不明确？我们是可以通知<code>&lt;template&gt;</code>中的<code>&#123;&#123; name &#125;&#125;</code>了，但是不要忘了我们还有<code>computed</code>，<code>watch</code>等其他地方也有可能用到 name！所以，通知依赖还应该有一个专门的类去完成这个工作（为什么？因为直接写到 set 中属于耦合了）。在 Vue 中，有一个专门的 Watcher 类去处理这件事，可以把流程这样解释：</p>
<ul>
<li>依赖收集时，只收集 Watcher 提供的封装好的依赖</li>
<li>通知依赖更新时，只通知 Watcher ，由 Watcher 再去通知其他地方。</li>
</ul>
<p>有点代理模式的味道。</p>
<p>来模拟一下 Watcher 的工作流程吧，它要监听一个对象的属性，且当这个对象的属性发生变化时，需要触发设定好的回调函数。这里的设计确实太精妙了，所以我要贴一下代码再进行分析。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (vm, expOrFn, callback) &#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="built_in">this</span>.getter = parsePath(expOrFn);</span><br><span class="line">    <span class="built_in">this</span>.callback = callback;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">  &#125;</span><br><span class="line">  get() &#123;</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="built_in">this</span>; <span class="comment">// 假设依赖都存放在window.target里</span></span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.getter.call(<span class="built_in">this</span>.vm, <span class="built_in">this</span>.vm);</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="keyword">const</span> oldVal = <span class="built_in">this</span>.value;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">    <span class="built_in">this</span>.callback.call(<span class="built_in">this</span>.vm, <span class="built_in">this</span>.value, oldVal);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parsePath</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bailRE = <span class="regexp">/[^\w.$]/</span>;</span><br><span class="line">  <span class="keyword">if</span> (bailRE.test(path)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> segments = path.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!obj) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      obj = obj[segments[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码可以把自己主动添加到<code>expOrFn</code>所指的属性的 Dep 中去，具体原因是：</p>
<ul>
<li>get 方法中会将<code>window.target</code>设置为当前 Watcher 实例，在构造函数中读取一下<code>expOrFn</code>中的内容，就会触发getter，然后就会触发依赖收集的逻辑。</li>
<li>由于收集依赖是从<code>window.target</code>中读取依赖添加到 Dep 中，所以只需要先把 this 赋给 <code>window.target</code>，再读一下<code>window.target</code>的值，就可以触发 getter，把 this 主动添加到<code>expOrFn</code>的 Dep 中。</li>
<li>这样，每当<code>expOrFn</code>所指的属性值发生变化时，就会让依赖列表中所有的依赖触发 Watcher 的 update 方法，update 方法又可以执行参数中的回调函数，把新值和旧值传回到回调中。</li>
</ul>
<p>现在我们可以实现对某一个对象的属性的变化侦测了，那么还差最后一步，我们要把所有的对象属性都这样做一下侦测，要怎么做？</p>
<p>我们需要一个角色来帮助我们完成这个工作，把对象中所有的属性和子属性都侦测到（也就是转换成 getter / setter）的形式，Vue 中使用了一个 Observer 类来完成这个操作。</p>
<p>Observer 类用于将一个正常的 Object 转换成被侦测的 Object。这个类会附加到每一个被侦测的 Object 上，一旦附加成功，它就会把对象里面的所有属性都转换成 getter  / setter 的形式。</p>
<p>Observer 类有一个 walk 方法，只有在数据类型为 Object 时才会调用，它首先使用<code>Object.keys</code>获取到所有可枚举的属性，然后遍历对象，对每个属性应用<code>defineReactive</code>方法。<code>defineReactive</code>也需要修改一下，即如果当前的值是 Object 属性，则递归建立 Observer。这样，只要定义响应式数据的data中的任何一个属性或者子属性发生改变，与这个属性的对应的依赖都会收到通知。</p>
<p>这种方式看起来没什么问题，但其实有一个缺点。由于数据变化是通过 getter / setter 来追踪的，它追踪的是数据的修改，无法对新增属性和删除属性做出响应。这就会导致实际使用 Vue 中出现的双向绑定失效问题。举个例子来说，我在 data 中定义了一个空对象，然后通过 methods 对这个对象添加一些属性，然后在<code>&lt;template&gt;</code>中打印出来，这样的数据是无法被响应式系统追踪到的，也就是数据变化后视图无法跟着一起变化。（这个坑我在实习时遇到过，接口数据存储到了一个空对象中，这样直接修改接口数据就不能触发视图更新）</p>
<p>下图简单描述了这个过程（Watcher那个线画错了，边框应该是实线。。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png"></p>
<p>总体来说，data 通过 Observer 变成了带有 getter / setter 的形式追踪变化。外界通过 Watcher 读取数据时，会触发 getter 从而将 Watcher 添加到依赖中。当数据发生了变化时，会触发 setter，从而向 Dep 中的依赖（Watcher）发送通知。Watcher 接收到通知后，会向外界发送通知，变化通知到外界后触发视图更新等操作。</p>
<h3 id="Array-的变化侦测原理"><a href="#Array-的变化侦测原理" class="headerlink" title="Array 的变化侦测原理"></a>Array 的变化侦测原理</h3><p>为什么 Array 的变化侦测要单独拿出来说呢？其实，当你使用 Array 的方法操作数组时，比如 push 和 pop，并不能触发 getter / setter，所以之前那种拦截的方法是行不通的。</p>
<p>那我们把 push，pop 等操作做个拦截不就可以了么？但挺可惜，ES6 之前的 JS 没有这种能力。这样就没有办法处理 Array 了吗？并不，我们有原型和原型链，我们可以把 Array.prototype 改写一下，也就是在原型上做一层拦截。之后我们每当使用 Array 上的方法时，其实使用的并不是原生方法，而是经过我们包装过的方法，它会做一些依赖收集和更新的操作，同时使用原生的 Array 方法完成原来的操作。</p>
<p>那么这个拦截器要如何实现呢？它其实也是一个 Object，和 Array.prototype 一模一样，但是其中的改变数组自身内容的方法都需要我们处理过。</p>
<p>引入一个结论：Array 原型中可以改变数组自身内容的方法有 7 个。它们分别是：</p>
<ul>
<li>push，尾部插入</li>
<li>pop，尾部弹出</li>
<li>shift，头部弹出</li>
<li>unshift，头部插入</li>
<li>splice，删除，替换，或添加新元素</li>
<li>sort，排序</li>
<li>reverse，逆序</li>
</ul>
<p>我们先从 Array.prototype 新建一个原型，再新建一个数组，存一下这七个操作的字符串。然后遍历一下，对每个操作做一次<code>Object.defineProoerty</code>，也就是对每个操作进行一次封装，将它的 value 属性设定为一个自定义的函数<code>mutator</code>，在这个函数里面就可以做一些其他事情，最后 return 一下原生的对应操作就可以了。</p>
<p>我们现在拥有了拦截器，那是不是可以直接改写掉 Array 的原型了？很显然是不可以的，这样会污染全局，拦截器应当只应用在被变化侦测的数组上。所以还要再改写一下原有的 Observer，当在构造函数中发现当前的 value 是 Array 时，就不再使用原来的遍历操作，而是直接使用<code>value.__proto__ = arrMethods</code>覆盖原型。还有一种很特殊的情况，如果有的浏览器不支持<code>__proto__</code>，那这样改写的方式就行不通，Vue 解决这个问题的方法是直接将拦截器中改写方法设置到被侦测的数组上，这样就可以让数组执行这些方法时直接使用这些新挂载的方法。</p>
<blockquote>
<p>当访问一个对象上的方法时，只有它自身不存在这个方法，才会沿着原型链去它的原型上寻找同名方法。</p>
</blockquote>
<p>接下来我们考虑下怎么让这个拦截器和 Dep 扯上关系，也就是怎么收集依赖。前面对 Object 收集依赖的过程是在 getter 中完成的，那数组怎么收集依赖呢？其实也是在 getter 中完成的。而与 Object 不同的是，触发依赖是在拦截器中完成的。</p>
<p>Vue 把 Array 的依赖保存在 Observer 中，因为需要让 getter 和拦截器都能访问到这个实例。在 Observer 中，对每个侦测了变化的数据，都标上了一个印记<code>__ob__</code>，并且把代表 Observer 实例的 this 保存在<code>__ob__</code>上，它的作用之一是用于标记已经侦测过的数据，避免重复侦测，另一方面可以很方便地通过数据取到<code>__ob__</code>，从而拿到 Observer 上保存的依赖。</p>
<p>除了侦测数据自身的变化外，数组元素发生的变化也要侦测。也就是说不仅要侦测数组元素本身，还要侦测一下它里面各种元素的变化。所以 Vue 中有一个 ObserveArray 函数，它可以对数组中的每一项内容都进行侦测（遍历每个元素并执行 observe 函数）。</p>
<p>此后，还要再侦测新增元素的变化，这需要扩展一下拦截器，把新增的元素拿过来，用 Observer 侦测一下。可以新增元素的操作只有 push、unshift、splice。通过获取它们的args就可以拿到新增的元素。接下来需要把新增的元素添加 Observer 侦测，使用的方法是<code>observerArray</code>，这个方法怎么从拦截器里拿到呢？其实，因为 Observer 会把自身的实例附加到 value 的<code>__ob__</code>属性上，这样只需要在拦截器的this里面就可以访问到<code>__ob__</code>了（所以这里不太适合用箭头函数。。）</p>
<p>这种拦截方式只能够拦截到数组操作的 API，对于直接对数组上某个元素使用下标访问修改的操作，它就无法拦截到了。</p>
<p>最后贴一下拦截器的代码演示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrProto = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">const</span> arrMethods = <span class="built_in">Object</span>.create(arrProto);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params">obj, key, val, enumerable</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    value: val,</span><br><span class="line">    enumerable: !!enumerable,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>, <span class="string">&#x27;sort&#x27;</span>, <span class="string">&#x27;reverse&#x27;</span>].forEach(<span class="function">(<span class="params">method</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> original = arrProto[method];</span><br><span class="line">  def(arrMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__;</span><br><span class="line">    <span class="keyword">let</span> insert;</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">        insert = args;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">        insert = args.slice(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (insert) &#123;</span><br><span class="line">      ob.observeArray(insert);</span><br><span class="line">    &#125;</span><br><span class="line">    ob.dep.notify();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Vue-3-的变化侦测"><a href="#Vue-3-的变化侦测" class="headerlink" title="Vue 3 的变化侦测"></a>Vue 3 的变化侦测</h2><p>Vue 3 相对于 Vue 2 来说，在变化侦测上最大的变化是采用了 Proxy 代替了 <code>Object.defineProperty</code>，Proxy 为 JavaScript  提供了元编程的能力，同时也不再需要数组那样需要拦截器的操作，Proxy 统一提供了 get 和 set 方法，它可以直接拦截并改变 JavaScript 底层引擎操作。</p>
<p>在 Vue 2 时代，原有的变化侦测方法无法侦测到属性的删除和新增，对于直接使用下标修改数组元素和修改 length 也无法侦测，这些问题在 Vue 3 时代全部都处理掉了。Vue 2 为了弥补这些缺陷，引入了<code>this.$set</code>，<code>this.$delete</code>等 API。并且由于依赖收集需要递归，其性能也是有限的。</p>
<p>Vue 3使用一个类似 React Hooks 的函数包裹需要侦测的数据，它提供了<code>reactive</code>方法用于将一个复杂的对象转化成响应式的。当你从 data 函数中返回一个对象时， Vue 会把这个对象包裹在一个含有 get 和 set 拦截器的 Proxy 中。</p>
<p>依赖保存、收集与触发其实与 Vue 2 相差不大，也是在 get 中收集依赖，在 set 中触发依赖。用 Vue 官方的解释说，叫做当一个值被读取时进行追踪，当某个值改变时进行检测，重新运行代码来读取原始值。</p>
<p>如果对象是嵌套的，从响应式代理中访问这个嵌套的对象时，对象在被返回之前也会被转换成一个代理。</p>
<p>同时需要注意，Proxy 转换的对象和原始对象并不相等，它们使用<code>===</code>运算符运算是返回 false 的。最佳实践：永远不要持有对原始对象的引用。</p>
<p>Vue 3在响应式原理上还有很多新的特性，这些有机会时再来看一下，官方文档写的很详细。</p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>npm与yarn的区别到底都在哪？</title>
    <url>/2021/09/28/npm-yarn/</url>
    <content><![CDATA[<p>npm是我们的老朋友了，此前朋友推荐了yarn，在使用中发现yarn确实比npm便利了许多，那可是有没有思考过，这两者间到底有什么区别？</p>
<p>这里简单探究一下。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/202109280112403.jpg"></p>
<a id="more"></a>

<p>或许你已经受够了npm糟糕的包管理方式：安装龟速，获取包版本不固定导致不确定项目能不能正常运行，log信息又臭又长…</p>
<p>还记得<code>package.json</code>中那些奇怪的符号吗？<code>1.0.1</code>，<code>~1.0.1</code>，<code>^1.0.1</code>，这都代表些什么？</p>
<p>这是版本号规范，在声明对某个包的依赖时需要指明是否允许 update 到新版本，什么情况下允许更新。</p>
<p>假如某个包只能接受补丁更新，连特性更新都无法接受，此时应该选用~，如果可以接受小范围更新，就使用^，如果没有限制，那也可以直接写个*。</p>
<blockquote>
<p>如果一个项目打算与别人分享，应该从 1.0.0 版本开始。以后要升级版本应该遵循以下标准：</p>
<p>补丁版本：解决了 Bug 或者一些较小的更改，增加最后一位数字，比如 1.0.1</p>
<p>小版本：增加了新特性，同时不会影响之前的版本，增加中间一位数字，比如 1.1.0</p>
<p>大版本：大改版，无法兼容之前的，增加第一位数字，比如 2.0.0</p>
</blockquote>
<p>此外，npm安装包是串行的，如果中间某个包的安装出现了错误，npm不会停止，而是会继续安装，这就会导致如果后面还有错误的话，最头上的错误将难以排查。yarn解决了很多npm的问题。</p>
<p>以下转载了一位博主的博客：<a href="https://www.jianshu.com/p/254794d5e741">https://www.jianshu.com/p/254794d5e741</a></p>
<ul>
<li><strong>速度快</strong> 。速度快主要来自以下两个方面：</li>
</ul>
<ol>
<li>并行安装：无论 npm 还是 Yarn 在执行包的安装时，都会执行一系列任务。npm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。</li>
<li>离线模式：如果之前已经安装过一个软件包，用Yarn再次安装时之间从缓存中获取，就不用像npm那样再从网络下载了。</li>
</ol>
<ul>
<li>安装<strong>版本统一</strong>：为了防止拉取到不同的版本，Yarn 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，Yarn 就会创建（或更新）yarn.lock 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。npm 其实也有办法实现处处使用相同版本的 packages，但需要开发者执行 npm shrinkwrap 命令。这个命令将会生成一个锁定文件，在执行 npm install 的时候，该锁定文件会先被读取，和 Yarn 读取 yarn.lock 文件一个道理。npm 和 Yarn 两者的不同之处在于，Yarn 默认会生成这样的锁定文件，而 npm 要通过 shrinkwrap 命令生成 npm-shrinkwrap.json 文件，只有当这个文件存在的时候，packages 版本信息才会被记录和更新。</li>
<li><strong>更简洁的输出</strong>：npm 的输出信息比较冗长。在执行 npm install <package> 的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，Yarn 简洁太多：默认情况下，结合了 emoji直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。</li>
<li><strong>多注册来源处理：</strong>所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 npm 要么是 bower, 防止出现混乱不一致。</li>
<li><strong>更好的语义化</strong>： yarn改变了一些npm命令的名称，比如 yarn add/remove，感觉上比 npm 原本的 install/uninstall 要更清晰。</li>
</ul>
<p>命令对比：</p>
<table>
<thead>
<tr>
<th><strong>npm</strong></th>
<th><strong>yarn</strong></th>
</tr>
</thead>
<tbody><tr>
<td>npm install</td>
<td>yarn</td>
</tr>
<tr>
<td>npm install react –save</td>
<td>yarn add react</td>
</tr>
<tr>
<td>npm uninstall react –save</td>
<td>yarn remove react</td>
</tr>
<tr>
<td>npm install react –save-dev</td>
<td>yarn add react –dev</td>
</tr>
<tr>
<td>npm update –save</td>
<td>yarn upgrade</td>
</tr>
<tr>
<td>npm run build</td>
<td>yarn run build</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript中的宏任务与微任务</title>
    <url>/2021/09/22/javascript-macrotask-microtask/</url>
    <content><![CDATA[<p>这个概念其实挺抽象的，要理解它，得从JavaScript运行机制开始聊起。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/202109231222803.jpg"></p>
<a id="more"></a>

<p>众所周知，JavaScript是单线程的，也就是说，同一时间只能做一件事，如果有某个耗费时间很长的任务，它就会造成线程卡死，反映到宏观上就可能会造成页面卡顿，无响应，甚至崩溃等。所以JavaScript引入了很多异步编程的概念。</p>
<p>要理清楚宏任务和微任务，必须得先搞明白JavaScript的运行机制才可以。</p>
<p>异步编程是为了解决某些任务需要等待而产生的，比如加载页面时还需要用ajax/axios调用后端接口，有可能接口会因为网络原因返回较慢，但如果要让页面等着接口返回后再加载，那必然是体验很不好的。所以聪明的程序员通常会把页面加载作为同步任务，而调用接口时使用异步任务。</p>
<p>网上有一张很有名的图：</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/202109231234383.webp" alt="img"></p>
<p>用文字表述来讲，同步任务与异步任务，它们的执行方式定义是这样的：</p>
<ul>
<li>同步任务和异步任务分别进入不同的执行环境，同步的进入主线程，异步的进入Event Table并注册回调函数。</li>
<li>当指定的异步任务完成时，Event Table会将这个函数移入Event Queue。</li>
<li>主线程内的任务不断执行，执行完毕为空时，会去Event Queue中读取对应的函数，进入主线程执行。</li>
<li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li>
</ul>
<p>每一次循环操作称之为一个tick。同步任务都在主线程上执行，形成一个执行栈，主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。下图解释了一个事件循环是怎么执行的。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/202109231246175.webp" alt="img"></p>
<p>那么宏任务和微任务和这里有什么联系呢？</p>
<p>宏任务被称作macrotask，在执行栈中每次执行的代码段就是一个宏任务，也包括每次从Event Queue中获取一个事件回调并放在执行栈中执行。</p>
<p>浏览器为了能够使得JS内部宏任务与DOM任务能够有序的执行，会在一个宏任务执行结束后，在下一个宏任务执行开始前，对页面进行重新渲染。</p>
<p>都有哪些宏任务：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">script(整体代码)</span><br><span class="line">setTimeout</span><br><span class="line">setInterval</span><br><span class="line">I/O</span><br><span class="line">UI交互事件</span><br><span class="line">postMessage</span><br><span class="line">MessageChannel</span><br><span class="line">setImmediate(Node.js 环境)</span><br></pre></td></tr></table></figure>

<p>微任务被称作microtask，i和a一字母之差。微任务是在当前宏任务执行结束后立即执行的一系列任务，也就是在当前宏任务之后，渲染之前，下一个宏任务之前。微任务的响应速度比setTimeout更快（这是个宏任务），且无需等待渲染。</p>
<p>在一个宏任务结束后，JS就会将在宏任务执行期间的所有微任务执行完毕。</p>
<p>微任务有：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Promise.then</span><br><span class="line">Object.observe</span><br><span class="line">MutaionObserver</span><br><span class="line">process.nextTick(Node.js 环境)</span><br></pre></td></tr></table></figure>

<p>这里有一张图帮助理解：</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/202109231244632.jpeg" alt="img"></p>
<p>总结（参考<a href="https://www.jianshu.com/p/bfc3e319a96b%EF%BC%89%EF%BC%9A">https://www.jianshu.com/p/bfc3e319a96b）：</a></p>
<table>
<thead>
<tr>
<th></th>
<th>宏任务（macrotask）</th>
<th>微任务（microtask）</th>
</tr>
</thead>
<tbody><tr>
<td>谁发起的</td>
<td>宿主（Node、浏览器）</td>
<td>JS引擎</td>
</tr>
<tr>
<td>具体事件</td>
<td>1. script (可以理解为外层同步代码) 2. setTimeout/setInterval 3. UI rendering/UI事件 4. postMessage，MessageChannel 5. setImmediate，I/O（Node.js）</td>
<td>1. Promise 2. MutaionObserver 3. Object.observe（已废弃；<code>Proxy</code> 对象替代） 4. process.nextTick（Node.js）</td>
</tr>
<tr>
<td>谁先运行</td>
<td>后运行</td>
<td>先运行</td>
</tr>
<tr>
<td>会触发新一轮Tick吗</td>
<td>会</td>
<td>不会</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2与Vue3之间到底有哪些区别？</title>
    <url>/2021/09/22/vue2-vue3-differences/</url>
    <content><![CDATA[<p>Vue2与Vue3之间的区别，这里简单记录一下。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/202109231222852.jpg"></p>
<a id="more"></a>

<h2 id="双向绑定原理"><a href="#双向绑定原理" class="headerlink" title="双向绑定原理"></a>双向绑定原理</h2><p>Vue2的双向绑定利用了Object.defineProperty()进行数据劫持，结合发布订阅模式实现。</p>
<p>Vue3中使用ES6 Proxy，其优势在于可以监听整个对象而不是单单某个属性，直接绑定整个对象可以省去for in，闭包等辅助类的东西从而提升效率。此外，它可以监听数组内部数据的变化。</p>
<h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><p>Vue3提供了一种全新的Composition API以代替Vue2的Option API，并提供了script-setup语法糖简化Composition API的写法，但同时兼容Vue2写法。</p>
<p>（在Vueconf 2021大会上，看到尤大现场展示script-setup的语法，真的当场直呼惊艳）</p>
<p>Composition API使用的地方在setup回调函数中，这个回调函数是创建组件之前执行，由于在执行 setup 时尚未创建组件实例，因此在 setup 选项中没有 this。这意味着，除了 props 之外，将无法访问组件中声明的任何属性，比如本地状态、计算属性或方法。</p>
<h2 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue2--------------vue3</span><br><span class="line">beforeCreate  -&gt; setup()</span><br><span class="line">created       -&gt; setup()</span><br><span class="line">beforeMount   -&gt; onBeforeMount</span><br><span class="line">mounted       -&gt; onMounted</span><br><span class="line">beforeUpdate  -&gt; onBeforeUpdate</span><br><span class="line">updated       -&gt; onUpdated</span><br><span class="line">beforeDestroy -&gt; onBeforeUnmount</span><br><span class="line">destroyed     -&gt; onUnmounted</span><br><span class="line">activated     -&gt; onActivated</span><br><span class="line">deactivated   -&gt; onDeactivated</span><br><span class="line">errorCaptured -&gt; onErrorCaptured</span><br></pre></td></tr></table></figure>

<h2 id="全局绑定"><a href="#全局绑定" class="headerlink" title="全局绑定"></a>全局绑定</h2><p>对于一些第三方插件，vue2中通常使用prototype原型来挂载到vue对象中。</p>
<p>Vue3没有直接在Vue实例中暴露prototype，而是提供了一个名为<code>globalProperties</code>的全局属性配置，可以代替vue2中的prototype</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>vue3中去除了 <code>$on</code>、<code>$off</code>、<code>$once</code>、三种方法，仅保留<code>$emit</code>。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Vue3新增对TS和PWA的支持</p>
<p>未完待续</p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>关于JavaScript函数的一点冷知识</title>
    <url>/2021/09/21/javascript-function/</url>
    <content><![CDATA[<p>红宝书第十章，关于函数，记录一些平时可能注意不到的东西。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/202109231221398.jpg"></p>
<a id="more"></a>

<ul>
<li>函数其实是一个对象。</li>
<li>可以把函数想象为对象，函数名想象为指向函数的指针。</li>
<li>箭头函数不可以使用arguments，super，new.target，没有prototype属性。</li>
<li>因为函数名是指向函数的指针，所以一个函数其实可以有多个名称。</li>
<li>ECMAScript6中所有函数对象都会暴露一个只读的name属性，包含关于函数的信息。</li>
<li>arguments对象类似数组，但不是数组，使用时通常需要转化一下：<code>let args = Array.prototype.slice.call(arguments);</code></li>
<li>函数不能重载，但可以通过判断变量个数来类似地实现重载效果。</li>
<li>函数声明和函数表达式是有区别的，在直接声明之前调用是OK的，这叫做声明提升，但如果改为等价的函数表达式，调用就会出问题。因为此时它的定义包含在一个变量初始化语句中，而不是函数声明中。</li>
<li><code>arguments.callee</code>是指向arguments对象所在函数的指针，可以用来函数内部调用（递归），严格模式下使用这个会报错。</li>
<li><strong>重点！</strong>this在标准函数和箭头函数下的行为不一样。<ul>
<li>在标准函数中，this引用的是把函数当成方法调用的上下文对象，在网页的全局上下文调用函数时，this指向的是window。</li>
<li>this到底引用的是哪个对象，要到函数被调用时才能确定。</li>
<li>执行上下文可以理解为当前代码的运行环境。在 JavaScript 中，运行环境主要包含了全局环境和函数环境。在 JavaScript 代码运行过程中，最先进入的是全局环境，而在函数被调用时则进入相应的函数环境。全局环境和函数环境所对应的执行上下文我们分别称为全局上下文和函数上下文。</li>
<li>箭头函数中，this引用的是定义箭头函数的上下文，也就是箭头函数在哪个上下文定义，this就指向哪个上下文。</li>
<li>所以这就导致箭头函数里需要慎重使用this。</li>
</ul>
</li>
<li>caller引用的是调用当前函数的函数，在全局作用域中caller为null。</li>
<li>new.target用于检测函数是否使用new初始化，是则返回true，否则返回false。</li>
<li>call和apply方法的作用是一样的，都以指定的this值来调用某个函数，会改变调用函数时this对象的值。<ul>
<li>apply方法接收两个参数，this值与参数数组，当然第二个参数传arguments也可以。</li>
<li>call传参形式与apply不同，第一个参数也是this值，但之后可以传不定个参数，将所需要的参数一个个列出来。</li>
<li>到底用的时候选哪个？传参怎么方便怎么来。如果不需要传参呢？随便，用啥都行。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU算法 学习笔记</title>
    <url>/2021/09/21/LRU-algorithm/</url>
    <content><![CDATA[<p>LRU算法是一种常见的页面置换算法，选择内存中最近最久未使用的页面予以淘汰，也就是根据数据的历史访问记录来淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/202109210045581.jpg"></p>
<a id="more"></a>

<p>一般LRU实现使用链表维护，实现LRU算法的步骤有三步：</p>
<ul>
<li>新数据从链表头部插入</li>
<li>当缓存命中时，此数据移动到链表头部</li>
<li>当链表满时，将链表尾部的数据丢弃</li>
</ul>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/202109210102810.webp" alt="img"></p>
<p>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。实现代价是命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部。</p>
<p>如何使用JS实现？</p>
<p>使用数组模拟链表（后面要用Map替换掉降低复杂度），提供两个方法，一个用于加入某个kv值，但需要判断链表是否已满，这里我使用set标识，还有一种方法用于设定某个值被命中，也就是标记它为最新使用，我使用hit标识。hit方法需要根据值来找键，普通的数据结构需要O(n)的时间满足这个操作，但可以使用JavaScript ES6提供的Map，就可以降低为O(1)，它既能保持键值对还能记住插入顺序。</p>
<p>那么提供一个数据结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> LRUCache = <span class="function"><span class="keyword">function</span> (<span class="params">capacity</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    <span class="built_in">this</span>.cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRUCache.prototype.set = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.cache.has(key)) &#123;</span><br><span class="line">        <span class="comment">// 如果cache里已经有这个值了，那就做一次更新，相当于做了一次hit</span></span><br><span class="line">        <span class="built_in">this</span>.cache.delete(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.cache.size &gt;= <span class="built_in">this</span>.capacity) &#123;</span><br><span class="line">        <span class="comment">// 这里要打算往cache里加入新值，但需要提前判断容量，如果容量不够，就需要删除尾部</span></span><br><span class="line">        <span class="built_in">this</span>.cache.delete(<span class="built_in">this</span>.cache.keys().next().value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cache.set(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LRUCache.prototype.hit = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.cache.has(key)) &#123;</span><br><span class="line">        <span class="comment">// hit的原理是先删除再新加入</span></span><br><span class="line">        <span class="built_in">this</span>.cache.delete(key);</span><br><span class="line">        <span class="built_in">this</span>.cache.set(key, <span class="built_in">this</span>.cache.get(key));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 表示命中成功，return啥随便你自己定</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 表示命中了个寂寞，return啥还是随便你自己定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用来解决LRU问题。</p>
<p>扩展LRU算法，详情参考：<a href="https://www.jianshu.com/p/d533d8a66795">https://www.jianshu.com/p/d533d8a66795</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JS函数柯里化 学习笔记</title>
    <url>/2021/09/20/function-currying/</url>
    <content><![CDATA[<p>函数柯里化是一个比较重要的JS特性，在笔试题和面试题中都出现过，现在把它学习一下。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/202109202340400.jpg"></p>
<a id="more"></a>

<p>函数柯里化是函数式编程里面的概念：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
<p>主要是体现在从函数里返回函数，将一个传递多个变量的函数调用改成了传递单个变量的多个函数调用。</p>
<p>举个经典例子，把<code>f(1,2,3)</code>变成<code>f(1)(2)(3)</code></p>
<p>柯里化有 3 个常见应用：</p>
<ul>
<li>参数复用：需要多次调用同一个函数，并且传递的参数绝大多数是相同的，使用柯里化就很合适</li>
<li>提前返回：多次调用多次内部判断，可以直接把第一次判断的结果返回外部接收</li>
<li>延迟计算：避免重复执行程序，等真正需要结果的时候再执行</li>
</ul>
<p>提前返回和延迟计算其实是一回事，因为执行柯里化函数的的过程当中返回的是执行了一部分的函数，没有直接返回结果，所以叫提前返回，同时，直到所有参数传递完成才会执行计算，所以叫延迟计算。</p>
<p>这个方法如果自己硬写的话，其实很直观，return里继续return一个function就可以，无限套娃。</p>
<p>但对于经典的面试题累加函数来说，有没有一个能接收无限个数参数的方法？当然有。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 首先将传入的arguments（参数表）转为数组对象</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用递归完成操作</span></span><br><span class="line">    <span class="comment">// 当 add 函数不断调用时，把第 N+1 个括号的参数加入到第 N 个括号的参数里面</span></span><br><span class="line">    <span class="keyword">let</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        args.push(...arguments);</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inner.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 每次拿到inner时，参数会随着传入的数量不断增加，此时使用reduce依次累加即可</span></span><br><span class="line">        <span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> prev + cur;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意，result是一个函数类型，我们重写了toString用于返回它的值</span></span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result.toString());</span><br></pre></td></tr></table></figure>

<p>arguments不是数组，不能使用数组的操作，需要首先将其拆分成数组。每次执行add函数的时候，返回的函数都是inner函数。</p>
<p>如果直接打印result，不重写<code>toString</code>，会发现result是一个函数类型，原本的函数变成字符串返回了，所以这里还需要重写一下<code>toString</code>，然后在输出时使用它，即可获得结果。</p>
<p>那下面的问题来了，如果面试官出的不是这个累加呢？有没有更通用的办法？</p>
<p>其实直接用上面这个改进也可以，但也有更优雅的写法。要判断当前传入的函数参数个数是否大于等于原函数所需参数个数，使用函数名.length可以访问，如果是，则执行此函数，如果小于，那么返回一个函数，递归继续处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> args.length &gt;= fn.length ? fn(...args) : <span class="function">(<span class="params">..._args</span>) =&gt;</span> curry(fn, ...args, ..._args);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> add = curry(add1);</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>很优雅吗？是的，很优雅，一行搞定。</p>
<p>还搞不了？实在不行……上lodash吧。</p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS实现三栏布局的方法</title>
    <url>/2021/09/19/three-column-layout/</url>
    <content><![CDATA[<p>学习一下三栏布局，同时补充一下BFC和文档流的知识。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/202109202337202.jpg"></p>
<a id="more"></a>

<h2 id="补充知识：BFC、文档流"><a href="#补充知识：BFC、文档流" class="headerlink" title="补充知识：BFC、文档流"></a>补充知识：BFC、文档流</h2><p>BFC叫做块级格式化上下文，是Web页面的可视CSS的一块渲染区域，它决定了块级元素如何对它的子元素内容进行布局，以及决定了与子元素同级别的兄弟元素之间的关系和作用。</p>
<p>根元素<html>，浮动元素，绝对定位元素，行内块元素，flex，grid，overflow不可见的元素等，都会创建格式化上下文，但其实不止这些，还有很多不常见的，比如表格相关，参考mdn。</p>
<p>BFC对浮动的影响很重要，浮动设定和清除只会应用于同一BFC的元素，浮动不会影响其它BFC中元素的布局，清除浮动只能清除同一BFC中在它前面的元素的浮动。BFC可以阻止元素被浮动元素覆盖掉，特就是使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围，此时可以使用<code>overflow: hidden</code>取消这个效果。</p>
<p>还有一种很特殊的性质叫做外边距塌陷（有的地方叫外边距折叠，都是一个意思），在同一个BFC下，外边距会发生重叠。比如有两个div在同一个BFC下，给它们设置margin为10px，但两个盒子之间的距离却是10px而不是20px。</p>
<p>文档流是一种用于输出HTML元素的流，从上到下从左到右依次排布布局。但如果使用浮动或某些定位（absolute，fixed）时，元素会脱离文档流，这同时会影响它之后的HTML元素的排布，这就是为什么需要清除浮动。</p>
<h2 id="浮动型三栏布局"><a href="#浮动型三栏布局" class="headerlink" title="浮动型三栏布局"></a>浮动型三栏布局</h2><p>采用float方式的布局，左右模块各自向左右浮动，并设置中间模块的 margin 值使中间模块宽度自适应。</p>
<p>但这种方式有一种问题，其main元素必须写在left和right之后，否则浮动将跑到main的下一行。这会导致主要内容的加载优先级比侧边低，在内容较多时，这种方式体验不好。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>三栏布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.container</span> <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 整个栏目的高度 */</span></span></span><br><span class="line">        height: 200px;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 左部分侧边定为左浮动 */</span></span></span><br><span class="line">        float: left;</span><br><span class="line">        width: 300px;  </span><br><span class="line">        background-color: red;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 右部分侧边定为右浮动 */</span></span></span><br><span class="line">        float: right;</span><br><span class="line">        width: 300px;</span><br><span class="line">        background-color: red;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 左外距大小与左边长度对应,也可以稍大一些做留白,右边同理 */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* 这里设置两者相等,其实就是一种居中效果,想想margin: 0 auto？ */</span></span></span><br><span class="line">        margin-left: 300px;</span><br><span class="line">        margin-right: 300px;</span><br><span class="line">        background-color: blue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-class">.main</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 使用伪元素在main后面加一个清除浮动,这种写法比较优雅 */</span></span></span><br><span class="line">        content: &#x27;&#x27;;</span><br><span class="line">        display: block;</span><br><span class="line">        clear: both;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/202109191843784.png" alt="image-20210919184253594"></p>
<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p>圣杯布局是一个很经典的布局，它可以做到首先渲染主体div。</p>
<p>做法：</p>
<ul>
<li><p>左中右div设置左浮动，脱离文档流，设定定位方式为相对，设定文字换行</p>
</li>
<li><p>外层容器设置overflow: hidden，触发形成BFC区域条件，撑开整个盒子</p>
</li>
<li><p>左div、右div设置好给定的宽度，这个条件是已知的</p>
</li>
<li><p>main盒子设置宽度为100%</p>
</li>
<li><p>左div设置left为负左宽度，左外距为-100%</p>
</li>
<li><p>右div设置right为负右宽度，左外距为负右宽度</p>
</li>
<li><p>外层容器设置右内距为右宽，左内距为左宽</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>三栏布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="comment">/* 如果你对这些注释里任何一句话有疑问或者看不懂，自己随便删几条CSS跑跑就知道了 */</span></span></span><br><span class="line">    </span><br><span class="line"><span class="css">      <span class="selector-class">.main</span>, <span class="selector-class">.left</span>, <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">        position: relative;</span><br><span class="line">        height: 300px;</span><br><span class="line"><span class="css">        <span class="comment">/* 加入这个是为了让文字固定在中间的显示区域中 */</span></span></span><br><span class="line">        word-break: break-all;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="css">      <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 其实这里经过测试，发现不用overflow生成BFC也可以触发，不知道什么原因 */</span></span></span><br><span class="line">        overflow: hidden;</span><br><span class="line"><span class="css">        <span class="comment">/* 加入padding是为了将main盒子的两边留白，腾出放置左盒子和右盒子的区域 */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* 为什么要这么做？如果不这么做，main盒子的内容就会溢出到左右盒子的区域 */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* 为什么限制main盒子的CSS要放在container里？布局需要 */</span></span></span><br><span class="line">        padding: 0 300px 0 200px;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="css">      <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line"><span class="css">        <span class="comment">/* left和margin-left共同起一个作用，即，把左盒子原本应该存在的位置向上移动一行 */</span></span></span><br><span class="line">        left: -200px;</span><br><span class="line">        margin-left: -100%;</span><br><span class="line">        background: pink;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="css">      <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">        width: 300px;</span><br><span class="line"><span class="css">        <span class="comment">/* 与left类似，把右盒子向上移动一行，并放在最右边 */</span></span></span><br><span class="line">        right: -300px;</span><br><span class="line">        margin-left: -300px;</span><br><span class="line">        background: pink;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="css">      <span class="selector-class">.main</span> &#123;</span></span><br><span class="line">        width: 100%;</span><br><span class="line">        background: forestgreen;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/202109202250685.png" alt="image-20210920224958561"></p>
<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><p>双飞翼布局是圣杯布局的变式，两者很类似，只是圣杯布局是用内边距控制盒子大小，双飞翼布局用两层盒子嵌套后通过外边距控制，两边盒子的浮动处理操作还是差不太多的，只不过双飞翼布局不需要使用相对定位。</p>
<p>当然，这份代码里就没有container这个外部容器了，实际写的时候应该要有，而且加上overflow: hidden来生成一个BFC。</p>
<p>做法：</p>
<ul>
<li>左、中外层、右div设置左浮动，脱离文档流</li>
<li>左盒子和右盒子设定宽度</li>
<li>左盒子设定左外距为负100%，右盒子设定左外距为负宽度</li>
<li>中内层盒子设定左外距为左盒子宽度，右边同理</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>三栏布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="comment">/* 如果你对这些注释里任何一句话有疑问或者看不懂，自己随便删几条CSS跑跑就知道了 */</span></span></span><br><span class="line"><span class="css">      <span class="selector-class">.main</span>, <span class="selector-class">.left</span>, <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">        height: 200px;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="css">      <span class="selector-class">.content</span>, <span class="selector-class">.left</span>, <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="css">      <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">        width: 100%;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 双飞翼布局的关键就在于是使用外边距进行缩小中间盒子的，左外距和右外距与分别与两侧边等宽 */</span></span></span><br><span class="line">        margin-left: 200px;</span><br><span class="line">        margin-right: 300px;</span><br><span class="line">        background-color: indigo;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line"><span class="css">        <span class="comment">/* 在浮动下，让左侧边盒子向上移动一行 */</span></span></span><br><span class="line">        margin-left: -100%;</span><br><span class="line">        background-color: royalblue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">        width: 300px;</span><br><span class="line"><span class="css">        <span class="comment">/* 在浮动下，让右边盒子向上移动一行 */</span></span></span><br><span class="line">        margin-left: -300px;</span><br><span class="line">        background-color: royalblue;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- HTML结构有较大变化 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/202109202309895.png" alt="image-20210920230848633"></p>
<h2 id="绝对定位布局"><a href="#绝对定位布局" class="headerlink" title="绝对定位布局"></a>绝对定位布局</h2><p>一种也算比较实用的布局方式，这种写法比较直观，也就是用子盒子相对父盒子进行绝对定位，并对齐。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>三栏布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 放置一个相对定位对它本身没有什么用，但是可以用来给子元素绝对定位作为父级元素参照 */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* absolute元素相对于最近的非static定位祖先元素的偏移，来确定元素位置 */</span></span></span><br><span class="line"><span class="css">        <span class="comment">/* 不写也行，我试过，但盒子对不齐，定位不好调，不如这样写省事 */</span></span></span><br><span class="line">        position: relative;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="css">      <span class="selector-class">.main</span>, <span class="selector-class">.left</span>, <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">        height: 300px;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-class">.main</span> &#123;</span></span><br><span class="line">        margin: 0 200px;</span><br><span class="line">        background-color: orangered;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">        position: absolute;</span><br><span class="line">        width: 200px;</span><br><span class="line"><span class="css">        <span class="comment">/* 这里的left和top是相对container定位的，用于对齐盒子，下面的同理 */</span></span></span><br><span class="line">        left: 0;</span><br><span class="line">        top: 0;</span><br><span class="line">        background-color: limegreen;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">        position: absolute;</span><br><span class="line">        width: 200px;</span><br><span class="line">        background-color: limegreen;</span><br><span class="line">        right: 0;</span><br><span class="line">        top: 0;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p>flex做三栏布局可能是最简单的，直观，且实用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>三栏布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="comment">/* flex做三栏布局可能是最简单的 */</span></span></span><br><span class="line"><span class="css">      <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">        display: flex;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="css">      <span class="selector-class">.container</span> <span class="selector-tag">div</span> &#123;</span></span><br><span class="line">        height: 200px;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="css">      <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 使用order是为了改变元素摆放顺序，这样不需要将left排在main之前，可以优先渲染main */</span></span></span><br><span class="line">        order: -1;</span><br><span class="line">        width: 200px;</span><br><span class="line">        background: coral;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="css">      <span class="selector-class">.right</span> &#123;</span></span><br><span class="line">        width: 400px;</span><br><span class="line">        background: coral;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="css">      <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 一般情况下可能会直接用flex: 1，但第三个参数代表的flex-basis可以用来设定中间盒子的最小宽度 */</span></span></span><br><span class="line">        flex: 1 1 800px;</span><br><span class="line">        background: seagreen;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/202109202321702.png" alt="image-20210920232110609"></p>
<p>其实能用的布局方案远不止这些，但其他的应该算不常见或者现在已经不常用了吧。</p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3.x中集成axios的方法</title>
    <url>/2021/07/28/vue3-axios/</url>
    <content><![CDATA[<p> 以前使用Vue2+Vue-CLI的axios比较多，用于和后端对接数据接口。现在更换为Vue3+Vite2后，axios的引入有了一些微妙的变化，这里记录一下引入的过程方便以后回顾。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210728084353.jpg"></p>
<a id="more"></a>

<p>整体思路：封装axios模块和API，在需要API时直接在对应组件中<code>import</code>使用，比较像之前我在uni-app那篇中使用云函数的封装方法，不过使用uniCloud不需要手动再写引入了。</p>
<p>首先使用包管理器下载axios并引入。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install axios --save</span><br><span class="line"></span><br><span class="line">yarn install axios</span><br></pre></td></tr></table></figure>

<p>然后并不需要对main.js做任何操作，可以在项目中这样建立文件目录，并在axios文件夹下建立两个js文件：<code>axios.js</code>和<code>api.js</code></p>
<p>这里<code>api.js</code>不一定只有一个，如果你的接口很多，可以将多个api拆分为多个文件，便于管理。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210728084623.png" alt="image-20210728084623169"></p>
<p>然后开始编写<code>axios.js</code>，它是对axios配置的封装。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> service = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&quot;/desktop&quot;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">&quot;Authorization&quot;</span>: <span class="string">&quot;Bearer &quot;</span> + <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;token&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">service.interceptors.request.use(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 发送请求前会做的事情</span></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 请求错误要做的事情</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">service.interceptors.response.use(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 2xx的状态码会激活的函数</span></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 非2xx状态码会激活的函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> service;</span><br></pre></td></tr></table></figure>

<p>使用axios.create创建一个service实例，可以向里面传递各种配置信息，比如baseURL，超时时间（单位毫秒），自定义请求头等。我在这里设定了一个Authorization请求头，因为项目中使用到了KeyCloak的token，具体需要设定什么，需要和后端交流，自己的项目一般没有特殊需要的话可以把header这一块直接去掉。</p>
<p>另外，还需要在vite的配置文件里配置一下跨域，在server下这样配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">      <span class="string">&quot;/desktop&quot;</span>: &#123;</span><br><span class="line">        target: <span class="string">&quot;http://你的ip:你的端口/&quot;</span>,</span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        rewrite: <span class="function">(<span class="params">path</span>) =&gt;</span> path.replace(<span class="regexp">/^\/api/</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>这个rewrite的意思好像确实没找到..不过先这样带着吧</p>
<p>之后就可以将这个实例导出了，然后在api内调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> service <span class="keyword">from</span> <span class="string">&#x27;./axios.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起get请求，后面可以拼接字符串等当查询条件</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserApp</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> service.get(<span class="string">&#x27;/getUserApp/&#x27;</span> + id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起post请求，可以后跟params</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">postSth</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> service.post(<span class="string">&#x27;/test&#x27;</span>, &#123;</span><br><span class="line">      params: &#123;</span><br><span class="line">        obj,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像这样，每需要一个接口，就export一个函数，直接return传回axios的返回值，这是一个Promise，可以直接使用then，catch等进行调用。</p>
<p>使用方法（composition API写法）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getUserApp &#125; <span class="keyword">from</span> <span class="string">&#x27;../../plugins/axios/api.js&#x27;</span>; <span class="comment">// 这里的路径是相对路径，使用时根据实际情况修改</span></span><br><span class="line"><span class="keyword">import</span> &#123; getCurrentInstance &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>: &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; proxy &#125; = getCurrentInstance();</span><br><span class="line">        getUserApp()</span><br><span class="line">          .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          	proxy.data.具体操作(res)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于在setup中不能使用this，所以这里采用了getCurrentInstance的方案，使用内部对data的proxy访问data。</p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript ES6 Proxy学习笔记</title>
    <url>/2021/07/25/javascript-proxy/</url>
    <content><![CDATA[<p> 好久没来更新博客了，之前因为复习周和找实习发生了很多事情，安定下来后需要好好补补了。</p>
<p>最近使用了vue3之后，发现很多地方都用到了Proxy，有必要了解一下。</p>
<p>本笔记摘自《ECMAScript6标准入门》第12章。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210725185210.jpg"></p>
<a id="more"></a>

<p>Proxy，听名字就知道，它是与代理相关的东西。在ES6中，Proxy用于修改某些操作的默认行为，属于元编程的一种，在语言层面上进行修改。</p>
<p>既然说到代理，那Proxy的工作方式就离不了和代理有关系。其实确实是这样，Proxy在访问目标对象前架设了一层拦截或过滤，如果外界需要访问一个对象，必须先走架设在对象之上的Proxy，这个机制可以对外界的访问进行过滤和改写，也就做到了修改默认行为的效果。</p>
<p>Proxy是一个对象，默认写法是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<p>其中，target是一个对象，代表foo这个变量本来就应该包含的内容，handler也是一个对象，其中需要设置对象的get和set方法，也就是针对target中内容的读取和写入时，会触发的事情。其实，Proxy可以拦截的操作不仅只有get和set，这里仅作简单举例。每一个拦截的方法都有其参数的要求，可以查询文档了解其具体使用方法。</p>
<p>如果用一种不太规则的写法解释Proxy的定义，可能像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;...&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;...&#125;;</span><br><span class="line"><span class="keyword">let</span> foo = target;</span><br><span class="line">foo.添加拦截(handler);</span><br></pre></td></tr></table></figure>

<p>Proxy实例可以作为其他对象的原型对象，沿着原型链走。Proxy支持的拦截方法有：</p>
<ul>
<li><code>get</code>：用于拦截某个属性的读取操作</li>
<li><code>set</code>：用于拦截某个属性的赋值操作</li>
<li><code>has</code>：用于拦截<code>HasProperty</code>操作，判断对象是否具有某个属性时会生效的操作，典型的操作比如in运算符</li>
<li><code>defineProperty</code>：拦截同名操作</li>
<li><code>ownKeys</code>：拦截对象自身属性的读取操作</li>
<li><code>getOwnPropertyDescriptor</code>：拦截同名操作，返回一个属性描述对象或者undefined</li>
<li><code>deleteProperty</code>：用于拦截delete操作，如果这个方法返回了false或者抛出错误，则本次delete会失效</li>
<li><code>preventExtensions</code>：拦截同名方法，只能返回bool值</li>
<li><code>getPrototypeOf</code>：拦截获取对象原型的操作</li>
<li><code>isExtensible</code>：拦截同名操作</li>
<li><code>setPrototypeOf</code>：拦截同名操作</li>
<li><code>apply</code>：拦截函数的调用，call和apply的操作</li>
<li>``construct`：拦截new命令</li>
</ul>
<p>使用proxy会带来一个this问题，也就是它并非透明代理，而是在目标对象的外面套了一层壳，使用this访问得到的是Proxy而不是对象本身。</p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>一文搞懂从输入URL到页面展示全过程</title>
    <url>/2021/05/30/the-URL-from-the-input-to-the-page-display-process/</url>
    <content><![CDATA[<p>前段时间因为各种事情一直在忙，最近总算是告一段落了，学点东西记录一下。</p>
<p>URL从输入到解析再到展示的全过程是一个非常经典的面试题，也是非常考验一个程序员基本能力的问题，以此为轴，可以串出很多深层次的知识点。</p>
<p>之前我对这个问题的了解非常浅层次，后来参阅了很多资料之后，感觉是将它整理出来的时候了。它可能不是最细的，但我会尽力完善。</p>
<p>“从一个网址从浏览器中输入并跳转起，到页面展示在你的屏幕上，这中间发生了什么？”接下来我们就开始一探究竟。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210530145341.jpg"></p>
<a id="more"></a>

<h2 id="流程概览"><a href="#流程概览" class="headerlink" title="流程概览"></a>流程概览</h2><p>整个解析到显示的过程可以这样简单描述：</p>
<ul>
<li>浏览器首先使用HTTP协议或HTTPS协议，向服务端请求页面；</li>
<li>服务端响应浏览器请求，返回HTML代码等资源；</li>
<li>浏览器将HTML代码构建为DOM树，计算DOM树上的CSS属性；</li>
<li>根据CSS属性对元素逐个进行渲染，得到存放于内存中的位图，该步骤中的位图可以进行合成以加快绘制速度；</li>
<li>将最终合成的结果绘制在页面上。</li>
</ul>
<p>概览看起来简单，但其中每个环节展开讲解都会牵扯到很多问题。</p>
<p>如果用一个稍微复杂点的流程图来描述，那就是这样的：</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210530150801.png"></p>
<p>这个过程需要牵扯到三个进程，浏览器进程、网络进程和渲染进程，它们分别的职责是：</p>
<ul>
<li>浏览器进程：主要负责用户交互、子进程管理和文件储存等功能。</li>
<li>网络进程：面向渲染进程和浏览器进程等提供网络下载功能。</li>
<li>渲染进程：把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。</li>
</ul>
<p>也可以将这个图稍微简化一下：</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210530151820.png"></p>
<p>接下来我将过程简单分为三个阶段：<strong>网络阶段</strong>、<strong>构建阶段</strong>、<strong>渲染阶段</strong>三个部分进行描述。</p>
<h2 id="网络阶段"><a href="#网络阶段" class="headerlink" title="网络阶段"></a>网络阶段</h2><p>网络阶段是指从用户输入起直到获取到HTTP响应报文后的这个阶段，这是整个流程的起点。</p>
<p>首先用户需要输入URL，当然实际上，用户输入的也不一定是URL，浏览器首先需要判断用户的输入，从而确定用户输入的到底是URL还是一些其他内容。现在很多浏览器的地址栏都会集成一个搜索引擎，用户可以直接在地址栏输入搜索关键词，浏览器则将根据搜索引擎的URL规则生成一个URL并准备发起请求。而当用户输入的是一个准确的URL时，浏览器应当对此URL进行完整性检查，确认格式后再准备发起请求。这一步很容易理解，比如我想访问百度主页，我只需要输入<code>baidu.com</code>，浏览器即可自动帮我将前面的协议名称等内容补全，最终获得一个请求URL为<code>https://www.baidu.com/</code>。而假如浏览器判断用户输入的可能是搜索关键词，则自动根据默认搜索引擎构造URL，比如我在地址栏输入<code>shawnzhou</code>并按回车，我最终请求的URL是<code>https://cn.bing.com/search?q=shawnzhou&amp;PC=U316&amp;FORM=CHROMN</code>。</p>
<p>此时在浏览器进程上，URL已经构造完毕，可以准备发起请求了。但因为发起请求是网络进程要做的事情，所以这一步还需要通过进程间通信（IPC）将URL传入网络进程，由网络进程负责建立TCP连接并发送HTTP或HTTPS请求。</p>
<p>在上面那个比较复杂的图中，我们现在的位置是：</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210530162345.png"></p>
<p>网络进程拿到URL之后并不会直接去向外发送请求，它会首先寻找本地缓存中是否有这个URL对应的资源（具体策略请看文末扩展知识），如果有，而且没有比如过期等异常情况，那就不需要再耗费网络资源进行加载了，直接从本地把资源调出来准备渲染即可。这里我们就假设没有缓存，必须要进行请求。</p>
<p>请求即试图通过网络与互联网上的其他服务器建立通信。每个服务器都有自己的ip地址作为公网上识别自己的名称，但是想要人去记这些毫无规律杂乱无章的ip地址也太费劲了。所以人们通过比如baidu.com这样的域名，使用某个形象的名字去对应某个ip地址（也就是对应某个服务器）。但现在还有一个问题，人能看明白域名的意思，但机器不一定，所以此时需要有个翻译官来帮忙把各种域名翻译成对应的ip地址，这个翻译官就是DNS服务器。</p>
<p>可是，全世界每天的解析量大到几乎无法估算，只用一台DNS服务器怕不是能给他累到冒烟，而且万一哪天这个服务器挂掉了，那全世界的网络岂不就和瘫痪没什么区别了？所以DNS的需求就决定了它必须是个分布式的。总之，DNS会按照一定的解析顺序对URL进行解析，然后给出目标服务器的IP地址，这个具体的解析策略在文末的扩展知识中。</p>
<p>拿到服务器的IP地址之后，现在就可以与服务器进行TCP连接了。TCP是在客户端和服务端之间传输数据的桥梁，通过请求-响应的形式进行可靠的传输连接。HTTP请求即是建立在TCP连接之上的，要想建立TCP连接，需要经过一个三次握手的过程，那为什么必须要三次握手而不是两次或者四次？</p>
<p>实际上，TCP的三次握手是为了做到保证数据的可靠传输和尽可能提高传输效率而规定的。少于三次，则可能会出现信息丢失从而无法保证可靠传输，多于三次，则可以简化为三次。TCP需要seq序列号来做可靠重传或接收，而避免连接复用时无法分辨出 seq 是延迟的或者是旧的 seq，但seq没有绑定到整个网络的全局时钟上，因此无法判断这个包是不是迟到了，所以需要三次握手来约定确定双方的初始 seq 。假如只有两次握手，客户端首先向服务端发起第一次握手，服务端确认后向客户端发起第二次握手，但此时客户端到底是否确认收到是不确定的，这就造成了服务端向客户端发送的数据不一定可靠，同理，一次握手的话更加不可靠了。而如果是四次甚至更多次握手，则会造成确认重复，浪费网络资源。</p>
<p>OK，走到现在这一步，TCP连接是建立起来了，接下来就是HTTP或HTTPS进行请求的阶段了。这里以HTTP为例，HTTPS多出的步骤放在了扩展知识中。首先浏览器需要构造一个请求，这个请求包含了请求头和请求体，请求头携带了一些配置等信息，请求体可能有也可能没有，里面包含的是请求的具体内容。假如是按照现在常用的RESTful风格的API，它具有很多比如GET，PUT之类的方式，获取的内容一般也不相同，比如需要获得一个html文件或者需要下载一个东西，如何去界定返回的内容到底是什么东西呢？通过在请求头设定<code>Content-type</code>，就可以确定到底是什么类型了。比如需要返回html，则需要<code>text/html</code>，需要下载文件，则需要字节流，则需要<code>application/octet-stream</code>，如果是前后端分离开发需要json格式的数据，则需要<code>application/json</code>。请求头可以写的有很多，根据不同的请求可以携带不同的内容，还可以带cookie。</p>
<p>浏览器发出请求，服务器接收到请求后根据服务端的业务逻辑执行对应代码，然后构造一个响应并返回。响应也包括响应头和响应体，有一个核心内容是响应状态码，这个在我以前的文章里有写，我附在了扩展知识中。浏览器接收到来自服务端的响应后则开始解析，首先会从响应头开始解析，判断状态码是多少，如果需要重定向，则会读取重定向地址并重新发出HTTP请求，如果响应200，说明成功，则会继续处理本次请求。解析完请求头，可以继续的话，就解析请求体。用户发出 URL 请求到页面开始解析的过程，叫做导航。</p>
<p>上面这些操作都是在网络进程中完成的，如果要渲染页面，在网络进程读取到这会是一个网页之后，浏览器渲染进程将开始准备，但渲染进程准备好后还不能立即开始解析，因为此时html代码文档还在网络进程，所以网络进程此时需要通过IPC提交文档，由浏览器进程再确定文档确实被提交。具体流程如下：</p>
<ul>
<li><p>首先，浏览器进程接收到网络进程的响应头数据，然后向渲染进程发送提交文档的消息；</p>
</li>
<li><p>渲染进程接收到提交文档的消息后，会和网络进程建立传输数据的管道，即IPC；</p>
</li>
<li><p>管道建立，文档开始传输，传输完成之后，渲染进程会返回确认提交的消息给浏览器进程；</p>
</li>
<li><p>浏览器进程在收到确认提交的消息后，会更新浏览器界面状态，包括安全状态、地址栏的 URL、前进后退的历史状态，并渲染HTML然后更新。</p>
</li>
</ul>
<p>这同时也解释了为什么在浏览器的地址栏里面输入了一个地址后，如果加载速度比较慢，之前的页面不会立马消失，而是需要等待加载一会才能把页面内容更新。</p>
<p>默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。</p>
<p>再来标注一下我们现在的位置：</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210530230041.png"></p>
<p>此时这个流程已经几乎快走完了，最后看起来只剩下了解析DOM树和渲染的过程，但其实，这个过程还是很复杂的。</p>
<h2 id="构建阶段"><a href="#构建阶段" class="headerlink" title="构建阶段"></a>构建阶段</h2><p>在构建阶段，浏览器已经获得了需要的HTML字节流代码文件，但是不能直接把代码打出来，那样不是网页，可是浏览器也没法自己读代码，这可咋整？有办法，渲染进程在这一步将负责解析获得的字节流，并先构建DOM树。</p>
<p>在说DOM树之前，先说说DOM的作用吧。从页面视角来看，DOM是生成页面的基础数据结构；从JavaScript视角来看 ，DOM提供给JavaScript操作的API，从安全视角来看，DOM是一道安全线，会在解析阶段将不安全的内容剔除。DOM树即是由各种DOM结点组成的一棵树。在渲染引擎内部，有一个叫做HTML Parser的模块，它的职责就是负责将HTML字节流转化为DOM结构。</p>
<p>DOM的具体生成流程示意图：</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210530235859.png"></p>
<p>在HTML解析器中，有一个叫做分词器的东西，它将字节流分为很多Token，规定了最小语义单元。分词器对字节流进行处理，将HTML代码拆分为标签和文本，即找出组成HTML页面的单元，然后生成结点，最后将它们组合起来就生成了DOM。上图所示的HTML代码经过分词器区分之后的的结构如下：</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210530235618.png"></p>
<p>好了，现在能够把标签区分开来了，但是要如何区分结点的父子关系呢？毕竟我们要做的是DOM树，既然是树结构那就免不了要讨论结点之间的父子关系，这里采用的是Token栈的方式进行生成，Token栈可以用入栈和退栈操作完成父子关系的计算。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210530235832.png"></p>
<p>简单描述一下Token栈的算法过程：循环遍历每个Token直到所有的Token都解析完，当遇到开始标签时，将起标签压入Token栈，在DOM树中绘制一个同名结点。在栈中上下相邻的两个Token在绘制时表示为父子关系，栈中靠顶为子，靠底为父。如果遇到文本结点，则会直接将它绘制到DOM中，但不会压入Token栈。当遇到结束标签时，栈顶弹出，代表此结点的内容已经放入DOM。</p>
<p>到了现在这个阶段，我们已经拿到DOM树结构了，实际上，DOM树结构此时还是一个对象，它还不能直接展示在页面上，此时还缺少CSS的加持，有了样式之后，就可以进行渲染了。要加入样式，则需要计算一个叫做CSSOM的东西，它判断每个DOM结点都有哪些CSS参与了修饰。对于CSSOM的介绍，我放在了扩展知识里。</p>
<p>拿到的CSS样式表首先需要过一次标准化，即将属性值统一，比如rem转化为px，color写颜色名的转化为RGB值，同时还需要考虑CSS的继承，层叠等概念，比较复杂。但这时候的CSS代码还是不能被浏览器识别的，需要一步转化，将CSS样式转化成<code>document.styleSheets</code>，这里我们可以先暂时把这些算好的属性叫做<code>ComputedStyle</code>，即计算样式。现在有了DOM树，有了CSSOM，接下来就是将它们结合起来，生成布局树的步骤了。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210531003655.png"></p>
<p>创建布局树时，需要将DOM树和计算样式结合起来，流程如下：</p>
<ul>
<li>对DOM树进行剔除操作，也就是剔除掉比如head这种不可见的结点，它们不需要被渲染。</li>
<li>查看<code>ComputedStyle</code>中的结点，判断是否带有如<code>display: none</code>这样的令其不可见属性，这样的不可见结点也不会放在布局树中。</li>
<li>最终将留下来的结点的DOM和CSSOM结合起来，生成布局树。</li>
</ul>
<p>题外话：要是因为JS或者其他原因，导致布局需要随时变动，如何优化性能？这里有重绘和重排两个概念，我在扩展知识中说明了这一部分。</p>
<p>总之现在是有了布局树，下面该准备将它渲染了。</p>
<h2 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h2><p>渲染是什么？将页面布局显示在屏幕上就是渲染。说到屏幕就不得不先提一些它的相关知识。</p>
<p>每个显示器都有其固定的刷新频率，比如60Hz的普通屏幕，144Hz，240Hz的高刷新率屏幕。那这个单位Hz到底代表什么？它是频率的单位，代表每秒钟的周期性变动的重复次数，也就是说，一块60Hz的屏幕每秒钟刷新60次，再通俗点说，刷新频率就是屏幕每秒画面被刷新的次数，表示每秒钟显示屏上的“图片”被重新绘制了多少次。</p>
<p>我们知道，显卡是负责图形计算和图形输出的硬件，显卡中有个部分叫做前缓冲区，它负责将计算好的画面输出到屏幕，如果刷新率为60Hz，则每秒钟内，显示器从前缓冲区读取60张合成的图像，然后输出到屏幕上。显卡合成的图像会临时保存在后缓冲区，当前缓冲区的图像已经被输送走的时候，后缓冲区的图像将被立即送入前缓冲区，等待下一次显示，而后面输出的图像又会放在后缓冲区待命，这样循环往复，便实现了屏幕图像的刷新。</p>
<p>还有一个概念叫做帧和帧率，它一般出现于使用动画时，比如滑动，缩放等，一般的网页刷新帧率是60帧/秒，也就是渲染引擎每秒要输送60张计算好的图片发送到显卡的后缓冲区，有时候会感觉到页面卡到掉帧，也就是说帧率出现了下降，即渲染引擎的计算量增大，每秒钟没办法输送正好60张图片，这就会导致帧率下降。比如60Hz的屏幕，代表1000ms内刷新60次，所以每次计算的时间限制大约只有16.67ms，如果某个组件在16.67ms内无法计算完成，则帧率就会下降，计算时间越长下降越多。当帧率下降严重时，你就会感觉到卡。这启示我们，生成布局树时应当让DOM尽量少，尽量少触发重排和重绘，这样就会提升显示性能。</p>
<p>这样，一次从URL输入到加载的全过程就算说完啦~呼，好久没有写过长文了，偶尔记录记录还是很有成就感的。</p>
<h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><h3 id="网络与通信相关"><a href="#网络与通信相关" class="headerlink" title="网络与通信相关"></a>网络与通信相关</h3><ul>
<li>HTTP标准</li>
</ul>
<p><a href="https://tools.ietf.org/html/rfc2616">https://tools.ietf.org/html/rfc2616</a></p>
<p><a href="https://tools.ietf.org/html/rfc7234">https://tools.ietf.org/html/rfc7234</a></p>
<p><a href="https://tools.ietf.org/html/rfc2818">https://tools.ietf.org/html/rfc2818</a></p>
<p><a href="https://tools.ietf.org/html/rfc7540">https://tools.ietf.org/html/rfc7540</a></p>
<ul>
<li>HTTP请求类型</li>
</ul>
<p><a href="https://www.runoob.com/http/http-methods.html">https://www.runoob.com/http/http-methods.html</a></p>
<ul>
<li>HTTP请求状态码</li>
</ul>
<p><a href="https://shawnzhou.world/2021/04/07/HTTP-status-code/">https://shawnzhou.world/2021/04/07/HTTP-status-code/</a></p>
<ul>
<li>OSI七层模型</li>
</ul>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210531014011.png"></p>
<ul>
<li>IPC示意图：</li>
</ul>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210530162723.png" alt="image-20210530162723558"></p>
<h3 id="浏览器缓存策略"><a href="#浏览器缓存策略" class="headerlink" title="浏览器缓存策略"></a>浏览器缓存策略</h3><p>详情参阅<a href="https://www.jiqizhixin.com/articles/2020-07-24-12">https://www.jiqizhixin.com/articles/2020-07-24-12</a></p>
<p>缓存是一种请求资源的副本，可以存储各种URL请求要用到的东西，比如HTML，CSS，JS代码，以及图片，视频，数据等资源。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的 URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。</p>
<p>本地和Web服务器都可以拥有缓存。使用缓存可以减少网络延迟，加快页面加载速度，减少带宽消耗和服务器压力。缓存的规则有新鲜度（过期机制判断是否陈旧）和校验值（验证机制判断是否修改），缓存分为强缓存（本地缓存）和协商缓存（弱缓存）。</p>
<p>在网络进程根据URL判断缓存是否存在时，会首先查看强缓存，如果命中则直接获取。如果未命中，则进入协商缓存阶段，此时将向浏览器发出请求判断是否命中，如果协商缓存命中，服务器会返回304，不带任何响应实体，此时可以从浏览器（客户端）中使用缓存。假如协商缓存也没有命中，则直接从服务器加载全部资源。</p>
<blockquote>
<p>304 Not Modified 表示资源已找到，但是并不符合条件中的要求，此时服务器端资源并未改变，可以直接使用客户端未过期的缓存。</p>
</blockquote>
<h3 id="DNS解析策略"><a href="#DNS解析策略" class="headerlink" title="DNS解析策略"></a>DNS解析策略</h3><p>感谢工作室一位对计算机网络了如指掌的学长给我的耐心讲解Orz</p>
<p>就目前来说，一次DNS解析的顺序是如下面这样：</p>
<ul>
<li>首先寻找本地DNS缓存（包括浏览器缓存，系统缓存，路由器缓存），假如缓存不过期，合法，且命中，则直接从缓存拿出解析结果，这是最快的。</li>
<li>如果缓存里没有，则会去寻找操作系统设定的hosts文件，如果在hosts文件里面有解析结果，则直接拿走结果，这个速度也很快。</li>
<li>如果hosts里面也没有，那就去看看本地DNS服务器里有没有记录。本地DNS服务器一般都是由DHCP自动分配，当然也有特殊情况下需要手动分配的，比如需要在某个内网环境中过滤掉一些域名，那就需要搭建本地DNS服务器并自定义解析策略。</li>
<li>如果上面这些都没有，那只能说明本地就彻底没有这个解析了。此时解析会向ISP-DNS缓存（互联网运营商提供）中查看有没有这个记录，有则返回这个记录，到这一步的解析其实可能会有点需要时间了，但这里能解析的域名也就是国内的绝大多数域名了，国内网站几乎没有到这一步还找不到记录的。</li>
<li>假如你要访问的确实就是国内找不到的，那就还会继续向外延伸。解析会根据根域名服务器→顶级域名服务器→主域名服务器的顺序依次进行，直到找到记录后返回。</li>
<li>到上一步还是找不到？你是不是域名写错了…</li>
</ul>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210530213359.png"></p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210530213649.png"></p>
<h3 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h3><p>详情参阅<a href="https://www.cnblogs.com/davina123/p/12978114.html">https://www.cnblogs.com/davina123/p/12978114.html</a></p>
<p>TCP的三次握手如下：</p>
<ul>
<li>第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT（Synchronize Sequence Numbers）状态，等待服务器确认；</li>
<li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>
<li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li>
</ul>
<p>借用一张网上的图解释一下三次握手，上面的漫画形象来自《图解HTTP》，这本书很不错，推荐买来一读。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210530221625.png"></p>
<p>完成三次握手之后，TCP连接成功建立。</p>
<p>TCP的四次挥手如下：</p>
<ul>
<li><p>第一次挥手： 首先从客户端开始发出连接释放报文，并且停止发送数据，这客户端进入到终止等待1状态。</p>
</li>
<li><p>第二次挥手：从服务器到客户端 。服务器收到连接释放报文，发出确认报文且带上自己的序列号，这时服务器端进入了关闭等待状态。这时TCP服务器要通知高层的应用进程，客户端向服务器释放，这时服务器处于半关闭状态。如果服务器还有数据要发送，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据</p>
</li>
<li><p>第三次挥手：服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，由于在半关闭状态，服务器很可能又发送了一些数据，服务器就进入了最后确认状态，等待客户端的确认。</p>
</li>
<li><p>第四次挥手：客户端收到服务器释放报文后，发出确认此时，客户端就进入了时间等待状态。因为此时TCP连接还没有释放，必须经过一段时间2∗MSL（最长报文段寿命），因为网络是不可靠的，有可以最后一个ACK丢失。所以时间状态就是用来重发可能丢失的ACK报文的。当客户端撤销相应的TCB后，才进入CLOSED状态。</p>
</li>
</ul>
<p>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。服务器结束TCP连接的时间要比客户端早一些。所以我们可以看到当服务器端收到客户端的SYN连接请求报文后，可以直接的发送请求连接和确认连接，但在关闭的时候，服务器收么到关闭信息后，很可能不会立即关闭，它需要时间来反应，只能先回复一个确认，只有当服务器端所有的报文都发送完后，服务器端才能发送希望断开连接。所以需要挥手需要四步来完成。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210530222248.png" alt="img"></p>
<h3 id="浏览器如何处理HTTPS协议"><a href="#浏览器如何处理HTTPS协议" class="headerlink" title="浏览器如何处理HTTPS协议"></a>浏览器如何处理HTTPS协议</h3><p>详情参阅<a href="https://segmentfault.com/a/1190000012196642">https://segmentfault.com/a/1190000012196642</a>与<a href="https://www.jianshu.com/p/ecbae815baf2">https://www.jianshu.com/p/ecbae815baf2</a></p>
<p>HTTPS是一种安全的，加密的协议，由于HTTP协议使用明文，有被窃听，伪装，篡改的可能性，它并不适合安全传输，使用HTTPS则可以解决这个问题。</p>
<p>HTTP加上加密处理、认证机制、以及完整性保护后的就是HTTPS。</p>
<p>需要知道的是，HTTPS并非是应用层的一种新的协议。只是HTTP通信接口部分用SSL或TLS协议代替而已。也就是说，所谓的HTTPS，其实就是身披SSL协议外壳的HTTP。HTTPS中使用了SSL和TLS这两个协议，TLS是以SSL为原型开发的协议，有时候会统称该协议为SSL。HTTPS在加密过程中使用了非对称加密技术和对称加密技术，公钥加密后的密文只能通过对应的私钥来解密，而私钥加密的密文却可以通过对应的公钥来解密，使用证书保证公钥的正确性，非对称加密算法加密的是证书的数字签名。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210530231645.webp" alt="img"></p>
<h3 id="CSSOM"><a href="#CSSOM" class="headerlink" title="CSSOM"></a>CSSOM</h3><p>详情参阅<a href="https://zhuanlan.zhihu.com/p/23569241">https://zhuanlan.zhihu.com/p/23569241</a>和<a href="https://www.cnblogs.com/mcad/p/10753212.html">https://www.cnblogs.com/mcad/p/10753212.html</a></p>
<p>CSSOM 是 CSS 的对象模型，在 W3C 标准中，它包含两个部分：</p>
<ul>
<li>描述样式表和规则等 CSS 的模型部分（CSSOM）</li>
<li>跟元素视图相关的 View 部分（CSSOM View）</li>
</ul>
<p>最后渲染出CSSOM树大概是这个样子：</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210531002914.png" alt="img"></p>
<h3 id="重绘和重排"><a href="#重绘和重排" class="headerlink" title="重绘和重排"></a>重绘和重排</h3><p>详情参阅<a href="https://www.cnblogs.com/cencenyue/p/7646718.html">https://www.cnblogs.com/cencenyue/p/7646718.html</a>和<a href="cnblogs.com/yadongliang/p/10677589.html">cnblogs.com/yadongliang/p/10677589.html</a></p>
<p>重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。触发重绘的条件是改变元素的外观属性，比如字体颜色和背景颜色。重排又称回流，当渲染树中的一部分或全部，因为元素的规模尺寸，布局，隐藏等改变而需要重新构建时，就称为回流。每个页面至少需要一次回流，就是在页面第一次加载的时候。</p>
<p>重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。所以，重排必定会引发重绘，但重绘不一定会引发重排。</p>
<p>重绘和重排会导致性能下降，浏览器本身带有一个优化策略：浏览器会维护一个队列，把所有会引起重排，重绘的操作放入这个队列，等队列中的操作到一定数量或者到了一定时间间隔，浏览器就会flush队列，进行一批处理，这样多次重排，重绘变成一次重排重绘。</p>
<p>减少重绘和重排的操作有以下方法：</p>
<ul>
<li>不要一条一条地修改 DOM 的样式。可以先定义好 css 的 class，然后修改 DOM 的 className。</li>
<li>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。</li>
<li>为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。</li>
<li>不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。（table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么要避免使用table做布局的一个原因)</li>
<li>不要在布局信息改变的时候做查询（会导致渲染队列强制刷新）</li>
<li>不要经常访问浏览器的flush队列属性；如果一定要访问，可以利用缓存。将访问的值存储起来，接下来使用就不会再引发回流</li>
<li>先设置元素为display：none然后进行页面布局等操作；设置完成后将元素设置为display：block这样的话就只引发两次重绘和重排</li>
<li>将需要多次重排的元素，position属性设为absolute或fixed，元素脱离了文档流，它的变化不会影响到其他元素</li>
</ul>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS flex布局学习笔记</title>
    <url>/2021/05/06/css-flex-layout/</url>
    <content><![CDATA[<p>flex布局方式是CSS3中的一个新特性。它的全称为flexible box，意为弹性盒。这是一种非常特殊的盒模型，它能扩展或收缩内部元素的大小，以达到最大限度的利用空间，提供了一种能更加简洁，直观，有效的排列元素的方法，可以非常灵活地决定元素的排列方法。目前flex布局已经被所有主流浏览器支持，可以安全地使用这个特性。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210506185541.jpg"></p>
<a id="more"></a>

<h2 id="flex的基本概念"><a href="#flex的基本概念" class="headerlink" title="flex的基本概念"></a>flex的基本概念</h2><p>借用一张网络上的flex布局示意图：</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210506190024.png"></p>
<p>flex布局的核心在于它有两个方向的“轴线”，正如上图所示，<code>main axis</code>代表主轴线，对应的方向是“行”；<code>cross axis</code>代表交叉轴线，对应的方向是“列”。借用一下盒模型的概念，盒模型是大盒套小盒，大盒是大容器，在这里也就是<code>flex container</code>，代表flex容器，内部的每个小盒是<code>flex item</code>，代表flex元素。</p>
<p>实际上，水平方向不一定是主轴，可以通过设置将主轴设定为列方向，这样水平方向的轴就变成了交叉轴。每个flex元素占据的主轴空间是<code>main size</code>，占据的交叉轴空间是<code>cross size</code>，但这并不代表<code>main size</code>就对应<code>width</code>，<code>cross size</code>就对应<code>height</code>，这要看主轴的方向，如果主轴是列方向，那<code>main size</code>就对应<code>height</code>了。</p>
<h2 id="flex的常用CSS"><a href="#flex的常用CSS" class="headerlink" title="flex的常用CSS"></a>flex的常用CSS</h2><p>实现一个flex布局只需要将它的<code>display</code>指定为<code>flex</code>即可。（也可以指定为<code>inline-flex</code>，这样元素将变为行内元素，但内部依然是flex布局）</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>flex container</code>，它有以下几种属性需要设置：</p>
<ul>
<li>主轴线方向是水平还是垂直</li>
<li>是否允许容器内的<code>flex item</code>换行（换行后将存在多条主轴线）</li>
<li><code>flex item</code>在主轴线上的对齐方式</li>
<li><code>flex item</code>在交叉轴线上的对齐方式</li>
<li>当存在多条主轴线时，多条轴线之间的对齐方式</li>
</ul>
<p>对于<code>flex item</code>，它有以下几种属性需要设置：</p>
<ul>
<li>排列的先后顺序</li>
<li>原本应当占据的主轴空间大小</li>
<li>元素在有多余空间时的放大比例</li>
<li>元素在空间不够用时的缩小比例</li>
<li>搞特殊，设定特立独行的布局方式</li>
</ul>
<p>下面逐个记录这些CSS的写法和用法。</p>
<h3 id="flex-container"><a href="#flex-container" class="headerlink" title="flex container"></a>flex container</h3><ul>
<li>主轴线方向是水平还是垂直</li>
</ul>
<p>设定<code>flex-direction</code>即可，它的取值不仅仅有<code>row</code>和<code>column</code>，还可以取<code>row-reverse</code>和<code>column-reverse</code>，不带reverse的从左往右排，带reverse的从右往左排。</p>
<ul>
<li>是否允许容器内的<code>flex item</code>换行（换行后将存在多条主轴线）</li>
</ul>
<p>设定<code>flex-wrap</code>，取值为<code>wrap</code>，<code>no-wrap</code>，<code>wrap-reverse</code>，分别代表不换行（空间不足时尺寸尽可能收缩），换行（第一行在上方），换行（第一行在下方）。</p>
<ul>
<li><code>flex item</code>在主轴线上的对齐方式</li>
</ul>
<p>设定<code>justify-content</code>，对齐方式有五种。<code>flex-start</code>左对齐，<code>flex-end</code>右对齐，<code>center</code>居中对齐，<code>space-between</code>两端对齐间距相等，<code>space-around</code>每个元素两侧间距相等。这五种方式的示意图如下（手画的，可能有点对不准）</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210506225937.png"></p>
<ul>
<li><code>flex item</code>在交叉轴线上的对齐方式，使用<code>align-items</code>，取值为：<code>stretch</code>默认对齐，占满容器高度；<code>flex-start</code>交叉轴起点对齐；<code>flex-end</code>交叉轴终点对齐；<code>center</code>交叉轴的中点对齐，<code>baseline</code>第一行文字的基线对齐。</li>
</ul>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210506232625.png"></p>
<ul>
<li>当存在多条主轴线时，多条轴线之间的对齐方式，使用<code>flex-wrap</code>，它的取值有<code>stretch</code>默认值，代表轴线平分垂直轴线方向的空间；<code>flex-start</code>在交叉轴起点对齐；<code>flex-end</code>在交叉轴终点对齐；<code>center</code>在交叉轴中间对齐；<code>space-between</code>在轴线两端对齐，间隔相等；<code>space-around</code>轴线间隔相等；</li>
</ul>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210506233605.png"></p>
<h3 id="flex-item"><a href="#flex-item" class="headerlink" title="flex item"></a>flex item</h3><ul>
<li>排列的先后顺序</li>
</ul>
<p>数值越小越靠前，一开始默认都是0。使用<code>order</code>设置先后顺序值，提供一个整数。</p>
<ul>
<li>原本应当占据的主轴空间大小（基准大小）</li>
</ul>
<p>这个概念比较难理解，但也是flex布局的关键点，因为浏览器要通过这个属性与其他属性配合实现弹性宽度。但是应当注意，这代表盒子的宽度将变为弹性，所以无法对其设置width（主轴水平时）。</p>
<p>使用<code>flex-basis</code>设定一个长度值如<code>10px</code>或<code>auto</code>即可。如果设置为0，则相当于视为元素的基准大小都是0（其实这时实际显示的时候都会配合放大，所以一般不会看到宽度为0的盒子），如果设置为auto，则交由浏览器自行判断每个元素有多宽。这个值很重要，因为它是盒子实现弹性的数值基础。</p>
<ul>
<li>元素在有多余空间时的放大比例</li>
</ul>
<p>假设在一个flex布局中所有的元素都被定义了<code>flex-basis</code>，此时系统按照设置进行布局，假如发现排列完成后仍然有剩余空间，则可以按照<code>flex-grow</code>设定的值进行放大。它默认值为0，即就算存在剩余空间也不使用。如果元素的<code>flex-grow</code>都设置成1，那就代表大家都等分剩余空间均匀放大，如果有个元素的值是2，其他都是1，那么2的放大程度就是其他元素的一倍，以此类推。</p>
<ul>
<li>元素在空间不够用时的缩小比例</li>
</ul>
<p>基本和<code>flex-grow</code>一样，使用<code>flex-shrink</code>进行空间不够时的缩小操作，但它的默认值是1，也就是空间不够时默认缩小。可以对某个元素单独设置为0，代表它不会被缩小。</p>
<p>有一个语法糖叫做<code>flex</code>，它是<code>flex-basis</code>，<code>flex-grow</code>，<code>flex-shrink</code>的结合。它的默认值是这三个默认值的结合，也就是<code>flex: 0 1 auto</code>。它的取值可以只有一个数字，也可以有两个数字，情况比较复杂，可以查阅其他资料。</p>
<ul>
<li>搞特殊，设定特立独行的布局方式</li>
</ul>
<p>使用<code>align-self</code>进行特殊的元素布局，对单个元素生效，它的值默认继承自父级flex container的<code>align-items</code>属性，取值也和它相同。</p>
<h2 id="flex的简单应用"><a href="#flex的简单应用" class="headerlink" title="flex的简单应用"></a>flex的简单应用</h2><h3 id="水平垂直居中（uni-app）"><a href="#水平垂直居中（uni-app）" class="headerlink" title="水平垂直居中（uni-app）"></a>水平垂直居中（uni-app）</h3><p><img src="C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20210507000400918.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;view class&#x3D;&quot;content-jz&quot;&gt;</span><br><span class="line">    &lt;view class&#x3D;&quot;content-jz-box&quot;&gt;&lt;&#x2F;view&gt;</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">		data() &#123;</span><br><span class="line">			return &#123;&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		onLoad() &#123;</span><br><span class="line">      </span><br><span class="line">		&#125;,</span><br><span class="line">		methods: &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot;&gt;</span><br><span class="line">  $default: #ff0093;</span><br><span class="line">  $smallBox: #039fff;</span><br><span class="line">  $text: #fff;</span><br><span class="line">  .content-jz &#123;</span><br><span class="line">    background-color: $default;</span><br><span class="line">    flex: 1;</span><br><span class="line">    height: 30vh;</span><br><span class="line">    display: flex;</span><br><span class="line">    align-items: center;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    .content-jz-box &#123;</span><br><span class="line">      width: 100rpx;</span><br><span class="line">      height: 100rpx;</span><br><span class="line">      background-color: $smallBox;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSS3</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title>uniCloud中云函数的使用与工具类封装</title>
    <url>/2021/05/05/cloud-function-in-uni-app/</url>
    <content><![CDATA[<p>uni-app是一个方便小程序开发的基于Vue的框架，它为开发者提供了一个非常方便的平台叫做uniCloud，使用它可以代替部分传统的服务端功能，使用云数据库和云函数（可以理解为数据接口）进行方便的CRUD操作。</p>
<p>但是uniCloud中原生的<code>uniCloud.callFunction</code>方法比较底层，在接口数量较多时会造成维护不便，所以需要一个结构对它进行解耦。这里对云函数的基本使用和一种简易的封装方式做个笔记。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210505143022.jpg"></p>
<a id="more"></a>

<h2 id="uniCloud开发环境搭建"><a href="#uniCloud开发环境搭建" class="headerlink" title="uniCloud开发环境搭建"></a>uniCloud开发环境搭建</h2><p>首先需要在hbuilderX中新建一个uni-app项目，可以先创建一下，选择默认模板，然后勾选使用uniCloud，完成创建。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210505143752.png"></p>
<p>然后在uniCloud文件夹中选择关联云服务空间或项目。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210505143528.png"></p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210505143823.png"></p>
<p>云服务空间需要在uniCloud网站上实名认证申请才可以得到。我这里已经申请完了，可以看到管理界面如下：</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210505144026.png"></p>
<h2 id="云函数的基本使用"><a href="#云函数的基本使用" class="headerlink" title="云函数的基本使用"></a>云函数的基本使用</h2><p>在管理界面→云数据库中，创建一个用于测试的数据库表，写入一些测试数据，然后创建一个云函数用于获取这个列表。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210505150157.png"></p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210505150256.png"></p>
<p>在云函数的<code>index.js</code>里面这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="comment">// 获取数据库连接</span></span><br><span class="line"><span class="keyword">const</span> db = uniCloud.database();</span><br><span class="line"><span class="built_in">exports</span>.main = <span class="keyword">async</span> (event, context) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 异步操作，需要使用await等待</span></span><br><span class="line">  <span class="comment">// 使用collection方法获取对应的数据库集合的引用</span></span><br><span class="line">  <span class="comment">// 使用get获取全部内容</span></span><br><span class="line">	<span class="keyword">let</span> AccountsList = <span class="keyword">await</span> db.collection(<span class="string">&quot;accounts&quot;</span>).get();</span><br><span class="line">	<span class="keyword">return</span> AccountsList;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用上传并运行云函数将这个云函数上传到云端，并测试运行结果：</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210505150900.png"></p>
<p>看到能正常返回数据，说明运行成功了。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210505151004.png"></p>
<p>对于返回的数据格式，最好做一个简单的封装，即带有HTTP状态码，请求信息等数据的对象。所以将云函数改写一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="comment">// 获取数据库连接</span></span><br><span class="line"><span class="keyword">const</span> db = uniCloud.database();</span><br><span class="line"><span class="built_in">exports</span>.main = <span class="keyword">async</span> (event, context) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 异步操作，需要使用await等待</span></span><br><span class="line">  <span class="comment">// 使用collection方法获取对应的数据库集合的引用</span></span><br><span class="line">  <span class="comment">// 使用get获取全部内容</span></span><br><span class="line">	<span class="keyword">let</span> AccountsList = <span class="keyword">await</span> db.collection(<span class="string">&quot;accounts&quot;</span>).get();</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">    code: <span class="number">200</span>,</span><br><span class="line">    msg: <span class="string">&quot;已成功返回accounts表的数据&quot;</span>,</span><br><span class="line">    data: AccountsList.data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再次上传运行一下（需要注意，每次修改完云函数之后都要将它上传到云端才可以正常使用），查看输出结果：</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210505152420.png"></p>
<p>云函数调试完成，接下来返回前端，尝试在<code>index.vue</code>里面调用它并显示信息在页面上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">		data() &#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;</span><br><span class="line">				data: [],</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		onLoad() &#123;</span><br><span class="line">      <span class="built_in">this</span>.getList();</span><br><span class="line">		&#125;,</span><br><span class="line">		methods: &#123;</span><br><span class="line">      getList() &#123;</span><br><span class="line">        uniCloud.callFunction(&#123;</span><br><span class="line">          name: <span class="string">&#x27;getAccountsList&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.data = res.result.data;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="built_in">this</span>.data);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用<code>callFunction</code>对云函数调用，它返回一个Promise，可以用<code>.then</code>获取调用成功的信息。控制台显示：</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210505155238.png"></p>
<p>这样就表示一个云函数调用完成了。</p>
<h2 id="云函数API的工具类封装"><a href="#云函数API的工具类封装" class="headerlink" title="云函数API的工具类封装"></a>云函数API的工具类封装</h2><p>云函数虽然好用，但每个需要用云函数的地方如果都需要这样写，不太利于维护项目，所以需要通过一些方式对它进行封装，以到达解耦的效果。</p>
<p>封装之后，在调用时就不再需要写一大堆的<code>callFunction</code>了，可以让代码更加直观而且可维护。首先新建目录：</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210505163937.png"></p>
<p>这里面api文件夹代表跟api相关的操作封装，http.js封装一个<code>uniCloud.callFunction</code>请求的Promise，用于各云函数请求调用时使用；index.js用于批量导出模块；list.js用于声明云函数模块（随着项目规模的增加，可以不用只有一个list.js，可以将不同的云函数分散开来，方便维护，只需要再加一些js文件就可以）。</p>
<p>先在app的入口程序main.js里面注册一下自定义的工具类，将它挂载到Vue的原型对象就可以。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> API <span class="keyword">from</span> <span class="string">&#x27;./common/api&#x27;</span></span><br><span class="line">Vue.prototype.$api = API</span><br></pre></td></tr></table></figure>

<p>在http.js中这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">$http</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> &#123; url, data &#125; = options;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">reslove, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		uniCloud.callFunction(&#123;</span><br><span class="line">			name: url,</span><br><span class="line">			data</span><br><span class="line">		&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (res.result.code === <span class="number">200</span>) &#123;</span><br><span class="line">				reslove(res.result)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				reject(res.result)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">			reject(err)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个<code>uniCloud.callFunction</code>，需要给它提供一个云函数名称和参数列表，分别对应name和data，在传入时name通过url传入，data作为同名变量可以简写。让它返回一个Promise，内部执行这个<code>callFunction</code>，并判断返回的状态码是不是200，如果是，则转resolve，如果不是，则转reject，如果出错也转reject，对于其他需求，也可以在内部继续扩展。</p>
<p>在index.js中这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> requireAPI = <span class="built_in">require</span>.context(</span><br><span class="line">	<span class="comment">// ./api 目录的相对路径</span></span><br><span class="line">	<span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">	<span class="comment">// 判断是否查询子目录</span></span><br><span class="line">	<span class="literal">false</span>,</span><br><span class="line">	<span class="comment">// 使用正则判断.js文件后缀</span></span><br><span class="line">	/.js$/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = &#123;&#125;; <span class="comment">// 导出模块对象</span></span><br><span class="line">requireAPI.keys().forEach(<span class="function">(<span class="params">key,index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 使用forEach对所有的文件进行检索，但不需要检索index.js</span></span><br><span class="line">	<span class="keyword">if</span>(key === <span class="string">&#x27;./index.js&#x27;</span>) </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 将对应的key绑定到moudule里导出</span></span><br><span class="line">	<span class="built_in">Object</span>.assign(<span class="built_in">module</span>,requireAPI(key))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="built_in">module</span></span><br></pre></td></tr></table></figure>

<p><code>require.context</code>是webpack里面的一个工具，通过给定的条件获取指定的上下文，主要用于实现自动化导入模块。使用这个API可以遍历某个文件夹下面的所有文件并自动导入，不用再手动import了。</p>
<p><code>require.context</code>函数接受下面三个参数：</p>
<ol>
<li><code>directory</code>，字符串，读取文件的路径</li>
<li><code>useSubdirectories</code> bool值，是否遍历文件的子目录</li>
<li><code>regExp</code>，正则表达式，用于匹配对应文件名的文件</li>
</ol>
<p>在list.js中这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $http <span class="keyword">from</span> <span class="string">&#x27;./http.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getList = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> $http(&#123;</span><br><span class="line">		url: <span class="string">&#x27;getAccountsList&#x27;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此后，如果想要添加新的云函数，只需要新建云函数后，在list.js里按照这个<code>getList</code>的写法再写一个就可以了，这种方式是无参的，如果需要有参的传递，则函数里写入一个data，<code>$http</code>中也传入一个data即可。</p>
<p>经过一系列封装后，前端代码就可以改写成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">		data() &#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;</span><br><span class="line">				data: [],</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		onLoad() &#123;</span><br><span class="line">      <span class="built_in">this</span>.getList();</span><br><span class="line">		&#125;,</span><br><span class="line">		methods: &#123;</span><br><span class="line">      getList() &#123;</span><br><span class="line">        <span class="built_in">this</span>.$api.getList()</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(res);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>最终运行结果：</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210505173156.png"></p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>uni-app</tag>
        <tag>uniCloud</tag>
        <tag>小程序开发</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么我们不应再继续使用Windows7了？</title>
    <url>/2021/04/28/good-bye-windows7/</url>
    <content><![CDATA[<p>5月份工作室要开展电脑服务日活动，其中有一项活动内容是win7系统免费升级win10（基于学校提供的正版化服务）。自从Windows 7停止维护之后，学校的电脑也陆续要求全部更换为国产操作系统或者正版Windows 10。知道这件事的我突然在脑内来了一波回忆杀，我仍然记得小学时初次见到win7 aero的惊艳感，直到后来有自己的电脑之前，我一直在使用的操作系统就是Windows 7。时间到了2021年，现在的Windows 7到底怎么样了？</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/20210428134045.jpg"></p>
<a id="more"></a>

<p>Windows 7是由微软开发的操作系统，内核版本号为Windows NT 6.1。win7可以算是vista的一个升级版，在各方面都有了显著的进步，尤其是我最中意的界面效果，比如Aero，切换动画等。自2009年系统发布，微软最初承诺要提供十年的支持，但Windows 7 活跃的时间比这个时间要更久一些。</p>
<p>2015年，微软终止了对Windows 7的主流支持，那时Windows 10也开始崭露头角。不过这时候的微软并没有完全放弃win7，仍然在对win7进行安全补丁更新支持。直到2020年1月14日，微软宣告正式停止对Windows 7停止官方技术支持、软件更新和安全问题修复，win7的生命也就到此画上了句号。</p>
<p>那现在是不是就彻底不可以使用了？也不完全是，但需要付费购买后续的安全补丁，且补丁价格会逐年递增。微软当然不建议我们选择这样的方案，仍然建议我们升级到最新的Windows 10。毕竟如果没有了安全更新的保护，电脑遭受通过网络、移动设备等传播的病毒，攻击的风险会加大，为了数据的安全性，还是选择使用Windows 10。</p>
<p>其实早在2015年，微软就开展过win7免费升级win10的活动，那一次的微软很宽容，为了推广win10的使用，甚至允许了盗版win7也可以免费升级到正版win10。然而那时也没有很多人愿意升级到win10，包括那时的我本人在内，理由无非是兼容性，配置和学习成本。现在想要升级win10，可没有这样的活动了，正版的操作系统除了在新购笔记本电脑时会预装，或使用机构提供的批量授权激活（如我校微软正版化服务），只能自己掏钱购买。对于原本就预装Windows 7的老笔记本电脑，在不升级硬件的前提下升级到Windows 10，可能使用体验也不会提升太多（说白了就是会比较卡），这种情况还是建议换设备吧，毕竟电子产品更新换代还是很快的，新的软件需要新的平台，新的平台需要新的服务，新的服务可能需要更好的硬件支持，对于拿电脑作为“吃饭工具”的程序员等行业人员来说，真的没有必要死抱着Windows 7不放。</p>
<blockquote>
<p>我记得2014年Windows XP停止更新时，也有很多人以同样的理由拒绝升级Windows 7，我只能说历史总是惊人的相似…</p>
</blockquote>
<p>系统漏洞的风险往往是致命的。对于危险的系统漏洞，微软官方的维护能够让它抢先在被黑客利用之前进行修复，尽管在微软停止更新后，第三方的杀毒软件纷纷表示能够为win7的安全继续保驾护航，但这很难保证将漏洞扼杀在摇篮之中，安全厂商或许可以在发现攻击事例后做出应对措施为用户做好安全防护，但你有没有想过，假如第一个中招的是你，你要怎么办呢？</p>
<p>其实现在想想，将Windows 7升级为Windows 10之后，所需的学习成本真的很高吗？其实我觉得未必。我高二时有了第一台自己的电脑，那时的win10才正式投入使用了两三年，对于基本操作而言相比于Windows 7并没有很大的变化，稳定性上自然不会有现在好，但就当时而言，我敲个代码，看个视频，打打炉石也就足够了。也许是微软故意要设计成新旧面板并存的样子，让用户能够平稳的从win7过渡到win10。除了令大家都很头疼的不打招呼就自动更新，其他方面还暂时没发现没什么巨大的硬伤。</p>
<p>如果你要问我哪个版本的Windows 10最好用，那我会毫不犹豫的告诉你是1909。1909是我从大二升级系统之后一直用到今年3月的版本，它的易用性、舒适性和稳定性上达到了一个平衡点，但1909也会在今年5月11日停止技术支持，所以我现在换用了变化相对“有点大”的20H2。（其实正确来讲变化较大的应该是20H1，但在我使用20H1时出现了各种悲剧事件，导致体验略差…）20H2一个比较明显的改动在于右击此电脑→属性的界面发生了很大的变化，配环境变量的同学可能拿着以前的教程找不到对应的地方了，但其实新版本的页面中也有对应的入口，所以不必担心。</p>
<p>操作系统也是软件，软件都有自己的生命周期，它总有走到终点的时候，它的退场是一种正常的迭代，也预示着时代的变迁。尽管对于国内市场份额，Windows7已经不如Windows 10，但它的存有量和使用量可能仍然在Windows 10之上。Windows 10目前还年轻气盛，但也是微软经过了多年打磨之后相对而言比较成熟的系统，尽管它还是会存在一些蓝屏或兼容性问题，但整体而言，它是一个更加优于Windows 7的选择。Windows 10现在的功能性更新，安全更新也在持续进行中，将Windows 7升级为Windows 10，是为了更好的保护你的个人信息安全，避免被各种勒索病毒和恶意程序攻击。</p>
]]></content>
      <categories>
        <category>杂谈与随想</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>windows7</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的Set和Map数据结构</title>
    <url>/2021/04/27/javascript-set-map/</url>
    <content><![CDATA[<p>在ES6中，JavaScript提供了两个新的数据结构Set和Map，使用它们可以在一些场景下方便很多。</p>
<p>本笔记摘自《ECMAScript6标准入门》第11章。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/07426ed0bd44c46c39659b6f561f0414.jpg"></p>
<a id="more"></a>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set代表集合，类似于数组，但数组中元素的值都是唯一的。Set本身是一个构造函数，用于生成一个Set数据结构，可以传入一个数组或者其他具有iterable接口的其他变量作为参数用于初始化，当然，仍然会保证Set不重复。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="comment">// Set(4) &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure>

<p>一行快速去重：<code>[...new Set(arr)]</code></p>
<p>另一种写法：<code>Array.from(new Set(arr))</code></p>
<p>可以使用<code>.add</code>方法向其中添加一个元素。使用<code>.size</code>方法返回元素个数。向Set中加入值时不会发生类型转换，所以不用担心数字变成字符串。在Set内部判断两个值相同的方式叫做<code>Same-value equality</code>，类似于精确相等运算符<code>===</code>，但和它也有一些区别，主要的区别在于在<code>Same-value equality</code>会认为NaN等于它本身，而<code>===</code>不会认为<code>NaN === NaN</code>。此外，在Set中，两个对象总是认为不相等的。</p>
<p>目前还暂时不能在遍历操作中直接改变Set的值，但可以使用一些变通的方式，比如在遍历时使用原Set造出一个新Set并迭代赋值。</p>
<h3 id="Set的常用属性和方法"><a href="#Set的常用属性和方法" class="headerlink" title="Set的常用属性和方法"></a>Set的常用属性和方法</h3><ul>
<li><code>Set.prototype.constructor</code>，就是Set本身（构造函数）。</li>
<li><code>Set.prototype.size</code>，返回元素个数。</li>
<li><code>add(val)</code>加入某个值，返回Set结构本身。</li>
<li><code>delete(val)</code>，删除某个值，返回bool表示删除是否成功。</li>
<li><code>has(val)</code>判断某个值是否存在。</li>
<li><code>clear()</code>，清空Set。</li>
<li><code>keys()</code>返回键名的iterator，<code>values()</code>方法和它几乎完全一致，它返回键值的iterator。</li>
<li><code>entries（）</code>返回键值对的iterator。</li>
<li><code>forEach()</code>使用回调函数对每个kv值进行操作，回调函数里需要两个参数分别代表k和v。</li>
<li><code>.map()</code>，<code>.filter()</code>这两种数组的操作对set也适用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="string">&#x27;mon&#x27;</span>, <span class="string">&#x27;tue&#x27;</span>, <span class="string">&#x27;wed&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> s.entries()) &#123;&#125;</span><br><span class="line">s.forEach(<span class="function">(<span class="params">k, v</span>) =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>Set本身就是集合，使用Set可以实现并集，交集，差集。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)));</span><br></pre></td></tr></table></figure>

<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>与Set类似，也是值不重复的集合，和Set的区别是：</p>
<ul>
<li>WeakSet的成员只能是对象，不能是其它类型的值。</li>
<li>WeakSet中的对象都是弱引用，也就是垃圾回收机制不考虑WeakSet对此对象的引用。换种方法解释就是，如果WeakSet引用的对象已经不被其他任何对象引用了，它就会被回收，WeakSet也访问不到了。</li>
</ul>
<p>它的第二个区别很重要，这直接导致了它是不可遍历的。因为在它里面存放的对象有可能随时消失，所以在里面的元素可能遍历前一半时还在，后一遍就没了。所以它只适合临时存放一些对象，或者存放DOM结点。</p>
<p>它的构造函数和Set类似，可以传入一个数组，但这个数组里面的成员必须全都是对象。</p>
<p>常用方法：add，delete，has，和Set基本相同，WeakSet没有size属性。</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>众所周知，JavaScript中的对象是一种键值对的集合，类似于Hash的结构，但是它的键只能是字符串，这有时候会带来一些限制。</p>
<p>Map对象类似于对象，但键的范围被扩大到多种类型，也就是将”串-值“结构升级成了”值-值“结构。</p>
<p>它的构造函数接受一个数组作为参，任何具有iterator接口并且每个成员都是一个双元素数组的数据结构都可以作为它的参。也就是说，Set和Map都可以用来生成新的Map。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>(&#123;</span><br><span class="line">	[<span class="string">&#x27;foo&#x27;</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">&#x27;bar&#x27;</span>, <span class="number">2</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;baz&#x27;</span>, <span class="number">3</span>]]); <span class="comment">// 是的，得套两层，里面那层才是内容</span></span><br></pre></td></tr></table></figure>

<p>对同一个键多次赋值，后面的将覆盖前面的。什么是同一个键？对同一个对象的引用才是同一个键，必须内存地址一样才可以，内存地址不一样的，就算值一样也不认为是同一个键。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set([<span class="string">&#x27;a&#x27;</span>], <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">map.get([<span class="string">&#x27;a&#x27;</span>]); <span class="comment">// 输出undefined，因为&#x27;a&#x27;和&#x27;a&#x27;不是同一个&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<p>Map的键和内存地址绑定，只要内存地址不一样，就是两个键。这个特性彻底解决了同名属性碰撞的问题。</p>
<p>那如果Map的键是简单类型呢？只要严格相等就行，<code>0</code>和<code>-0</code>也视为同样的。特殊的，Map也将多个<code>NaN</code>视为同一个键。</p>
<blockquote>
<p>吐槽：所以NaN为什么不等于NaN？鬼知道当时他们怎么想的..</p>
</blockquote>
<h3 id="Map的常用属性和方法"><a href="#Map的常用属性和方法" class="headerlink" title="Map的常用属性和方法"></a>Map的常用属性和方法</h3><ul>
<li><code>Map.prototype.size</code>属性返回成员数量。</li>
<li><code>Map.set(k,v)</code>，插入一个键值对，然后返回整个Map，如果已经有这个k值，则更新v。</li>
<li><code>Map.get(k)</code>获得k对应的v，如果找不到k，返回undefined。</li>
<li><code>Map.has(k)</code>判断这个k是否在这个Map里，返回bool。</li>
<li><code>Map.delete(k)</code>删除k对应的kv对，删除成功返回true，否则返回false。</li>
<li><code>Map.clear()</code>清除所有成员。</li>
<li><code>keys()</code>返回键名的iterator，<code>values()</code>方法和它几乎完全一致，它返回键值的iterator。</li>
<li><code>entries（）</code>返回键值对的iterator。</li>
<li><code>forEach()</code>使用回调函数对每个kv值进行操作，回调函数里需要两个参数分别代表k和v。</li>
</ul>
<p>Map可以使用展开运算符快速转为数组，和Set差不多。将数组传入Map构造函数也可以构造Map，二者可以互相转化。</p>
<p>如果Map所有的键都是字符串，就可以转化成对象，但是这个得手写。</p>
<p>将对象转化为Map就是逆操作，但也得手写。</p>
<p>Map转JSON可以直接使用JSON.stringify，这种情况适用于k都是字符串。如果k里面有非字符串，需要转化为数组JSON，like this：<code>JSON.stringify([...m]);</code>。</p>
<p>JSON转Map比较好办，毕竟正常情况下所有键名都是字符串。在特殊情况下，JSON满足数组Map结构时，可以一个一个转化为Map。</p>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>和Map类似，生成键值对集合。</p>
<p>使用set方法添加成员，接受一个数组作为构造函数的参数。但WeakMap只接受对象和null作为键名，这和Map不同。</p>
<p>重点来了，WeakMap的键名指向的对象不计入垃圾回收机制。它的键名引用的对象都是弱引用，也就是垃圾回收机制不考虑这个引用。这句话怎么解释呢？</p>
<p>比如有一个需求是，我想对两个对象通过某个结构添加一些其他信息，然后这个结构就必然会对这两个对象形成一个引用，在使用结束之后，垃圾回收机制不会自动回收这两个对象，因为它们现在还有一个引用在联系，所以此时需要先手动删除这个引用的结构才可以。但如果使用WeakMap进行弱引用，垃圾回收机制就不会考虑这个引用占用的联系，一旦我不需要这两个对象了，垃圾回收会自动把这俩对象收回，即便WeakMap还留着对它的引用。</p>
<p>使用场景：在网页DOM元素上添加数据时使用WeakMap，当该DOM被清除，对应的WeakMap记录就会被自动清除。注册监听事件的listener对象可以用WeakMap实现，它和绑定的DOM建立联系，一旦DOM消失了，事件也就跟着没了。</p>
<p>WeakMap依旧不支持遍历和获得大小。只能使用get，set，has，delete。</p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>基于阿里云OSS+PicGo+Typora的自动博客图床</title>
    <url>/2021/04/25/aliyun-oss/</url>
    <content><![CDATA[<p> 事情是这样的，本来前几天还好好的图床，昨天突然把我博客一堆封面图全删了，我感到非常裂开。。</p>
<p>然后看到同学有自己的OSS存储，我在想我是不是也可以整一个，然后就整了一个，这里记录了一下整个过程以及相关的注意事项，方便后续查阅。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/d478daf074013cd6833aa45f8b6d6cb6.jpg"></p>
<a id="more"></a>

<h2 id="OSS的简介与套餐选择"><a href="#OSS的简介与套餐选择" class="headerlink" title="OSS的简介与套餐选择"></a>OSS的简介与套餐选择</h2><blockquote>
<p>阿里云对象存储OSS（Object Storage Service）是阿里云提供的海量、安全、低成本、高持久的云存储服务。其数据设计持久性不低于99.9999999999%（12个9），服务可用性（或业务连续性）不低于99.995%。</p>
<p>OSS具有与平台无关的RESTful API接口，您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</p>
<p>摘自阿里云官方产品简介“什么是对象存储OSS”</p>
</blockquote>
<p>简单来讲，OSS就是一种云存储服务，提供了一种高稳定性的存储服务和与之相关的操作接口，能够通过GUI，命令行，API等工具方便的管理存储。</p>
<p>在使用OSS之前，需要先购买OSS服务，这里使用标准的存储包即可，它能够满足日常图床使用的需求，如果仅仅用来放图，那40G的流量完全够用，如果你感觉不够可以再加。其他的套餐略贵而且可能不符合图床制作的需求，这里就暂不考虑了。</p>
<p>半年的OSS只需要不到五块钱，非常便宜，即便是买五年的也只需要不到50块钱，是一个性价比很高的选择。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/image-20210425224003176.png"></p>
<p>（写博客时我已经购买了，所以这里显示我已经购买，一开始买了半年的试试水，然后发现OK，那我先冲他五年的）</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/QQ%E5%9B%BE%E7%89%8720210425225759.png"></p>
<p>购买之后，你就可以在控制台里看到OSS管理界面了。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/image-20210425225952117.png"></p>
<h2 id="OSS存储配置与密钥获取"><a href="#OSS存储配置与密钥获取" class="headerlink" title="OSS存储配置与密钥获取"></a>OSS存储配置与密钥获取</h2><p>购买了OSS服务后，需要首先在Bucket列表里新建一个Bucket（可以理解为存放数据的容器），用于存储内容，配置在下图中说明：</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/image-20210425230712015.png"></p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/image-20210425230851190.png"></p>
<p>这样操作之后你就可以获得一个新的Bucket，然后在点进这个Bucket，选择文件管理，并新建一个用于存放图片的目录。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/image-20210425231028555.png"></p>
<p>可以在这里测试一下上传一张图片，然后点击图片文件名可以看到URL链接，就说明成功了。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/image-20210425231417524.png"></p>
<p>接下来为了能够以API或第三方软件的形式操控你的OSS，需要为那些程序提供你账号的授权。阿里云官方的最佳实践是不建议使用全局的AccessKey，因为一旦泄露将导致整个账号被别人完全控制，这将出现不可预料的安全后果，可以遵循最小授权原则，使用RAM访问控制建立子账号，为子账号添加仅OSS的用户权限，并在为第三方提供时使用子账号，这样可以保证权限的安全性。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/image-20210425231909318.png"></p>
<p>一般在你创建AccessKey之后，它会为你提供一对ID和密码，将这个ID和密码保存下来，放到安全的地方存储即可。</p>
<h2 id="PicGo下载与配置"><a href="#PicGo下载与配置" class="headerlink" title="PicGo下载与配置"></a>PicGo下载与配置</h2><p>PicGo是一个用于快速上传图片并获取图片 URL 链接的工具，Typora官方推荐。</p>
<p>GitHub项目地址：<a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p>
<p>在Releases下面找到发布版本，尽管他现在说2.3是beta版本不稳定，但2.2版本貌似有一些奇怪的bug，所以这里推荐直接下载最新版本。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/image-20210425232401585.png"></p>
<p>下载安装之后打开，进入配置界面。在图床设置→阿里云OSS中修改下面设置。</p>
<p>哦对了，最后不要忘了点一下设置为默认图床然后再确定。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/image-20210425232755490.png"></p>
<p>关于上图中的存储区域，可以在OSS管理控制台的概览→访问域名中看到。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/image-20210425232937971.png"></p>
<p>设置完毕之后，在上传区测试一张图片，如果提示上传成功，相册里也有这张图，那就OK了。</p>
<h2 id="Typora配置"><a href="#Typora配置" class="headerlink" title="Typora配置"></a>Typora配置</h2><p>最后一步，打开Typora，配置绑定PicGo</p>
<p>在设置→偏好设置→图像中，选择插入图片时的操作为上传图片，并把对本地和网络图片的规则应用打勾，然后上传服务那里选择PicGo（app），并选择exe的路径，它在上传时会自动打开这个软件，平常的时候PicGo默认就在后台挂着，需要传图，粘贴一下就秒传了，很方便。写完博客了也可以把PicGo关掉节省内存。</p>
<p>这样一个基本自动的图片上传就做好啦~</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/image-20210425233321043.png"></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>自动上传的路径不能有中文，否则会上传失败..</p>
<h2 id="挖坑"><a href="#挖坑" class="headerlink" title="挖坑"></a>挖坑</h2><p>目前这套解决方案已经解决了图片上传的问题，但在实际使用时，对于原图片经常需要进行一些尺寸压缩和画质压缩，以便于降低大小从而能达到快速加载，目前的图片优化仍然是通过我人工完成，我打算后面写一个更好用的方法解决这个问题。</p>
<p>这套方案还暂时没有和阿里云的全站CDN加速结合起来，因为我的网站没有备案。目前正在跑备案流程，如果通过了的话，再加上CDN加速，那博客加载速度可能就要起飞了，大概就要告别cloud flare和GitHub pages啦（手动滑稽</p>
]]></content>
      <categories>
        <category>教程相关</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>阿里云OSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的原型、原型链</title>
    <url>/2021/04/22/javascript-prototype/</url>
    <content><![CDATA[<p>原型和原型链一直是我以前学习JS的时候的老大难，因为它有点难啃，不是很好理解。</p>
<p>今天上午为了准备京东二面，硬是对着资料把它学了下来，趁热打铁，记录一下笔记。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/700fb8492e2b72988c12a43ba74931b5.jpg"></p>
<a id="more"></a>

<p>众所周知，面向对象程序设计里面，继承是一个很重要的概念，它是对象之间一种很重要的关系，使用继承可以很方便的派生出一些更复杂的类，而不需要将基类再次重写。在JavaScript中，ES6之前是没有严格的面向对象理念的，JS的对象也只是一种很简单的键值对，但JS也需要继承来制作出很多复杂的类，其实JS就是使用原型链的方式进行继承。</p>
<p>可以说，JavaScript是基于原型的，创建的每一个函数（或者叫构造函数）都有一个特殊的属性叫做<code>prototype</code>，这个属性可以理解为一个指向它“原型”的指针，那这个原型就是这个函数的原型对象，类似于“我的本源”，或者不严格的用OOP思想理解的话，函数是一个“class”，函数的实例是一个“instance”，这个函数继承自一个叫做prototype的“class”，这个prototype是函数的“基类”，在这里就叫做“原型”。</p>
<p>如果给原型定义一个概念的话，那就是：除null外的每一个JavaScript对象创建的时候，它就会自动与另一个对象关联，关联的对象就是它的原型，对象可以从它的原型中继承属性。</p>
<p>那prototype里有什么？其实里面有一个constructor，指向关联的构造函数。对于除了null外的每个对象而言，它都有个属性<code>__proto__</code>，它指向对象的原型。</p>
<p>比如我有一个构造函数foo，那么图示是这样的：</p>
<p><img src="https://z3.ax1x.com/2021/04/22/cOVnRs.png"></p>
<p>就继承而言，原型满足了这个要求，原型相当于继承的基类，基类的非私有的属性和方法会被传给子类，所以子类可以使用基类的非私有的属性和方法，在JavaScript里，对于一个对象而言，如果它要使用某个属性，JavaScript会首先查看它本身有没有这个属性，如果没有，则通过对象的原型查看它的“基类”有没有这个属性，如果还没有就一直往上查。</p>
<p>那查到最根本的根本，到头到了哪？到了Object。原型也是一个对象，所以原型也会有它的原型，所有对象最终的原型是Object，或者说，大家都是从Object继承过来的。那么问题来了，Object的原型是什么？JavaScript规定，是<code>null</code>。</p>
<p>好一个道生一，一生二，二生三，三生万物！原型的奥妙也就在这里，那现在可以给出一个相对完整的图示了：</p>
<p><img src="https://z3.ax1x.com/2021/04/22/cOZukD.png"></p>
<p>看图上这条<code>__proto__</code>的链条，从null到Object，然后到foo，那foo之外也完全可以有bar或者baz，因为我们有Object了，所以基于原型链，就可以实现JavaScript中的继承。应当注意，只有函数才有<code>prototype</code>，对象没有，对象只有<code>__proto__</code>，但其实函数也有自己的<code>__proto__</code>，它指向<code>Function.prototype</code>，也就是说，所有函数都是Function的实例。</p>
<p>基于原型链，我们可以使用<code>instanceof</code>运算符判断某个自定义对象是不是某个类型的对象，因为只要实例对象的<code>__proto__</code>和某类型对象的<code>prototype</code>是同一个，那就说明它们是出自同一条原型链，那自然就是一样的了，这样说可能抽象，举个例子，比如在深拷贝中，我需要建立初始对象，如果这个初始对象是Object，我就初始化为<code>&#123;&#125;</code>，如果这个初始对象为Array，我就初始化为<code>[]</code>，这样使用<code>instanceof</code>运算符就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>使用原型链的方法，可以说明new这个关键字的执行过程了：</p>
<ol>
<li>创建一个新的对象</li>
<li>添加原型链，将这个对象的<code>__proto__</code>指向函数的原型<code>xxx.prototype</code></li>
<li>执行构造函数中的代码</li>
<li>如果构造函数有返回值，则new返回这个值，如果构造函数没有返回值，则new返回这个对象本身</li>
</ol>
<p>new不仅仅是实例化一个对象，它存在的意义其实在于实现了JavaScript当中的继承。</p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面试题</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>探究JavaScript中数组扁平化的方式</title>
    <url>/2021/04/13/Flatten-the-array/</url>
    <content><![CDATA[<p>数组扁平化，又称数组拍平，是一种将多维数组降维打击之后变成一维数组的办法。</p>
<p>与深浅拷贝一样也是在面试里出现过，而实际开发中见得较少。这里记录一下，学习学习。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/0f07a86830ad6e0172750c8930f2e041.jpg"></p>
<a id="more"></a>

<p>数组扁平化的目标举例：现在有一个数组是<code>[1,[2,[3,4]]]</code>，要把它高维的部分拍扁，变成<code>[1,2,3,4]</code>。</p>
<p>一个直观的做法就是递归，遍历元素，当目前元素是数值，那就加入到新数组，如果是引用类型（数组），那就递归遍历这个数组。</p>
<p>这样的做法大概做法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> el <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> el === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            flatten(el);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            target.push(el);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法看起来没啥问题，但实际运行起来漏洞百出。对于数组里面元素只有数字的还好，但如果啥都有的话，就会报错。</p>
<p>那咱转化成另一种遍历方式？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; arr.length; index++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> arr[index] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            flatten(arr[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            target.push(arr[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嗯，这样是可以跑了，但是，对于下面这个巨奇怪的数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">    <span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">    &#123;<span class="attr">aaa</span>: <span class="string">&#x27;bbb&#x27;</span>&#125;,</span><br><span class="line">    [<span class="number">2</span>,<span class="number">3</span>,&#123;<span class="attr">a</span>:<span class="number">4</span>&#125;,[<span class="number">5</span>,[[[[<span class="number">1</span>],<span class="number">2</span>],<span class="number">3</span>]]]],</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>它的结果是：<code>[ 1, 2, 2, 3, 5, 1, 2, 3, [Function] ]</code>。看起来少了点东西？没错，里面的对象没了。这说明我们的判断方法有问题。</p>
<p>再换一种方式，这次使用<code>Array.isArray</code>方法进行判定，然后把这个有点视觉观感不太好的if换成三目，就是下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; arr.length; index++) &#123;</span><br><span class="line">        <span class="built_in">Array</span>.isArray(arr[index]) ? flatten(arr[index]) : target.push(arr[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试输出<code>[ 1, 2, &#123; aaa: &#39;bbb&#39; &#125;, 2, 3, &#123; a: 4 &#125;, 5, 1, 2, 3, [Function] ]</code>，这是我们想要的结果。</p>
<p>其实也可以使用ES6中的新方法<code>reduce</code>处理这个事情。先摘一下我之前记录JavaScript数组操作时的笔记：</p>
<blockquote>
<p><code>reduce</code>方法接收一个有以下四个参数的函数：<code>previousValue</code>，<code>currentValue</code>，<code>index</code>，<code>array</code>，后两个参数是可选的。这个函数会返回一个将被叠加到累加器的值，方法停止执行后会返回这个累加器。如果要对一个数组中所有元素求和，这个就比较有用。</p>
</blockquote>
<p>使用<code>reduce</code>处理拍平的操作思路也是递归。这里还使用到了展开运算符，两者一结合，写出来的代码就比较优美了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre,cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(cur) ? [...pre, ...flatten(cur)] : [...pre, cur];</span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那既然都考虑到ES6了，ES6里面就没有可以直接完成这个操作的函数吗？其实是有的。一行解决。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.flat(<span class="literal">Infinity</span>)</span><br></pre></td></tr></table></figure>

<p>参数里传入的是扁平化的深度，那要彻底扁平的话就传入一个<code>Infinity</code>就可以了。</p>
<p>还有没有其他方法呢？有一种使用<code>toString</code>的方法，但是效果并不好，对于复杂的结构不能处理，这里给出查找到的一种做法参考。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.toString().split(<span class="string">&#x27;,&#x27;</span>).map(<span class="function">(<span class="params">val</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parseInt</span>(val)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是一种比较神的做法，它使用的是apply和some，有点高级。这个留个坑，以后再慢慢研究。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat.apply([],arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的Promise对象</title>
    <url>/2021/04/12/javascript-promise/</url>
    <content><![CDATA[<p>Promise是ES6中新增的一种特性，是异步编程的一种解决方案，相比于回调函数与事件更合理而且更加强大，可以用来解决“回调地狱”问题。</p>
<p>最早由社区提出并实现，ES6将它写入了语言标准，统一了用法，并原生提供了Promise对象。</p>
<p>尽管用过基于Promise的Axios，但是对于Promise本身我却知之甚少。所以这里把它学一学。这篇学习笔记摘自《ECMAScript标准入门》第十四章。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/2ce7cfae7bd62d6ba0b64ee875e8cf52.jpg"></p>
<a id="more"></a> 

<p>Promise是啥？可以把它理解为用于处理异步事件的一种容器，保存着某个未来才会结束的事件的结果。它本质上是一个对象，从它可以获取异步操作的消息。它提供了统一的API，可以适用于各种情况下的异步操作。</p>
<p>对于一个Promise对象，它有两个特点：</p>
<ul>
<li>对象状态不受外界影响。它有三种状态：<code>pending</code>，<code>fulfilled</code>，<code>rejected</code>，分别代表进行中，已成功，已失败，这三种状态只有异步操作的结果才可以改变，其他任何操作都对它不会造成影响，这也是英文名Promise的由来，代表“承诺”或者“期约”（红宝书译者李松峰先生翻译为期约）。</li>
<li>一旦状态改变了，那就不会再改变，任何时候都可以获得这个结果。Promise的状态改变只有两种可能，即从pending变成fulfilled或从pending变成rejected，一旦改变，此时结果将定型，这时将状态称之为<code>resolved</code>。与事件不同，事件在错过之后，监听将无法得到结果，但Promise可以随时通过回调函数获取到已经resolved的结果。</li>
</ul>
<p>Promise可以将嵌套调用的异步回调函数变成同步操作的流程，这并不是说把异步改成了同步，而是使用同步的形式，内部其实仍然是异步的。这个特性可以处理掉回调地狱这个问题。</p>
<p>Promise的缺点是：</p>
<ul>
<li>无法取消，一旦新建将被立即执行</li>
<li>如果不设置回调函数，内部的错误不会抛到外部</li>
<li>pending阶段时无法得知具体pending到哪个程度</li>
</ul>
<p>一个简单的Promise实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">	<span class="keyword">if</span> (success)</span><br><span class="line">        resolve(val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        reject(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>它接受一个函数作为参数，这个函数的两个参数一个是resolve一个是reject，这两个函数JavaScript引擎会提供。</p>
<p>走resolve就变成功，走reject就变失败。可以使用<code>.then</code>方法指定两个回调函数，这两个回调函数前者代表成功时执行，后者代表失败时执行，第二个回调函数可以不写。then方法指定的回调函数将在当前脚本所有同步任务执行完之后才会执行，所以假如有三个log，一个在promise定义，一个在then，一个在外部，则输出顺序是promise 外部 then。在调用resolve或reject的时候如果带了参，这些参会被原封不动的传到回调函数里。reject函数的参数通常是Error对象的实例，表示抛了错误。</p>
<p>使用promise封装ajax操作，可以避免多次网络请求的回调地狱，但其实我们做项目用的时候直接上Axios多一点，有的地方用fetch API，也不错。</p>
<p><code>.catch</code>方法是.then的别名，一般用于处理错误。如果异步操作走到了reject，那就会用catch方法指定的回调函数处理这个错误，如果在then里面运行时报错了，也会走catch。但当这个promise已经resolved之后，再抛出错误，也不会被捕获了。它的错误有冒泡性质，会一直向下传递，直到被下一个catch抓到。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;err!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>一般而言，不使用then中的第二个参数，而是使用catch方法。</p>
<p><code>Promise.all()</code>方法用于将多个Promise实例封装成一个新的Promise实例，接受一个数组作为参数，数组里的元素都是Promise的实例，如果不是，就会先调用<code>Promise.resolve()</code>方法转化为Promise。</p>
<p>比如使用all方法生成了一个p，p里面有p1,p2,p3三个Promise实例，p是一个Promise，所以p的状态只跟p1p2p3有关。判定规则如下：当三者全都fulfilled，则p也会fulfilled；如果有其中一个reject，那p就reject，第一个被reject的实例会返回值给p的回调。</p>
<p>还有一个类似的方法叫做<code>Promise.race()</code>，传参和all相同，但里面的实例有一个改变状态，封装好的Promise实例就改变状态，改变相同。</p>
<p>还有两个有用的附加方法，第一个是<code>done()</code>，用于解决最后一个方法抛出的错误无法捕捉，done方法永远处于回调链的尾端，保证抛出任何可能出现的错误。done方法也可以像then那样提供传参，也可以不传任何东西。第二个是<code>finally</code>，指定无论Promise对象最后状态如何都会执行的操作，它接受一个回调函数作为必要参数，无论怎样都要执行。</p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>0.1+0.2等于几？</title>
    <url>/2021/04/11/JavaScript-floating-point-calculation-problems/</url>
    <content><![CDATA[<p>0.1+0.2等于0.3吗？这好像是一个小学生就能解答的问题。</p>
<p>但是在JavaScript中，这个问题的答案可就不一定了。为什么呢？学习一下，写个笔记。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/29f7bcd1c340d73922142ab15e31e6fe.jpg"></p>
<a id="more"></a>

<p>在JavaScript中，数字是<code>Number</code>类型，此类型使用IEEE 754格式表示整数和浮点数。储存整数比较好理解，但储存浮点数值的内存会消耗更多一些，是整数值的两倍内存，所以ECMAScript总是想方设法把用不着小数的浮点数转化成整数。这个特性会让一些小数点后全为0的小数显示为整数，可是这只是一个显示格式的问题，但对于值而言不会出错，但对于有些计算而言，就会出一些要命的错误。</p>
<p><img src="https://z3.ax1x.com/2021/04/11/c0KlA1.png"></p>
<p>很明显，这不是我们想要的结果。</p>
<p>其实这要从IEEE 754这个标准的浮点数开始说起。 它规定双精度浮点数的长度为64个二进制位，最高1位是符号位，后11位是指数部分，剩下的52位是小数部分。符号位决定了数字的正负，指数部分决定数的大小，小数部分决定了数字的精度。众所周知，在计算机中的存储是二进制的，数值相加到计算机内计算时都是体现成二进制的（这里暂时没补码什么事），那么，先尝试把0.1和0.2转化成二进制小数吧。</p>
<p>然后开始了无尽的计算…</p>
<blockquote>
<p>(0.1)<sub>2</sub>=0.0001100110011001…</p>
<p>(0.2)<sub>2</sub>=0.0011001100110011…</p>
</blockquote>
<p>可以发现，这两个数字的二进制是无限的。由于小数部分最多支持52位，所以在IEEE 754标准下，到了52位之后数字就会被截断，只能拿在它之前的数值进行计算，这样的计算是存在误差的，然后就得到了这个出现错误的结果。</p>
<p>如何解决？方法有很多。</p>
<ul>
<li><p>使用<code>toFixed()</code>方法进行保留x位小数，适合于计算有精度要求的情况，但是这种情况并不能满足全部可能。</p>
</li>
<li><p>把需要计算的数字同时倍增放大一个给定的倍数，放大到都是整数，然后在整数下进行计算，计算完毕后再缩回来。</p>
</li>
<li><p>把精确数值计算的任务丢给后端。</p>
</li>
<li><p>采用第三方库<code>Math.js</code>，<code>decimal.js</code>，<code>big.js</code>等，完成计算操作。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>网络请求中的跨域资源共享</title>
    <url>/2021/04/11/cross-origin/</url>
    <content><![CDATA[<p> 跨域是实际前后端分离开发当中不可避免的会出现的问题，在面试当中也经常问到相关内容，这部分知识还是挺重要的。</p>
<p>这里把跨域相关的知识点学习一下，记录一下。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/9e09d93fc4971bf62c4affad87f36bd1.jpg"></p>
<a id="more"></a>

<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>在研究跨域之前，首先得明白啥是“域”，以及我们为什么要把它跨过去。</p>
<p>先引入一下同源策略的定义吧。</p>
<p>MDN定义：</p>
<blockquote>
<p>同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p>
</blockquote>
<p>简单来说，这是浏览器的一种安全策略，对于非同源之间的信息交互，浏览器会拒绝，这样能够有效阻隔来自非安全的源的恶意攻击。同源策略是一种Web的规范，而浏览器是这些规范的实现者。假如Web当中没有同源策略，那我们在网络上最后一点点的隐私也就彻底没有了。</p>
<p>那么什么才能叫同源，什么叫不同源呢？同源是指同时满足三个相同的URL，三个相同指的是<strong>域名相同，端口相同，协议相同</strong>。只有当三者完全相同时才可以认为是同源，有任一条件不相同则判定为不同源。在同源下进行URL请求是一切正常的，但若是未经特殊处理的不同源请求，将会被阻止并抛出安全错误，这是浏览器对信息安全的一种自我保护机制。</p>
<p>个人认为，同源也可以理解为同域，即处于同一资源点或同一网络区域，对不同源之间进行的访问一般称之为跨域访问。</p>
<p>在前后端分离的开发当中，前端和后端部署的端口号不相同，甚至有时域名都不会相同，这很明显在请求时就会触发保护机制，导致前端无法发送HTTP请求。但可以通过一些设置来越过这个保护机制。</p>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS的中文名字叫跨域资源共享，英文全称为<code>Cross-Origin Resource Sharing</code>，它定义了浏览器与服务器之间如何实现跨域通信。CORS背后的基本思路就是使用自定义的HTTP头部允许浏览器和服务器之间互相了解，以确实请求或相应应该成功还是失败。</p>
<p>CORS通信过程由浏览器自主完成，使用CORS进行的跨域通信与不使用CORS的同域通信代码是一样的，但浏览器会自动识别是否跨域，如果跨域，就会自动附加一些头信息，有时候还会多发一次请求。</p>
<p>浏览器将CORS请求分成两类：简单请求和非简单请求。满足简单请求有两个条件。</p>
<ol>
<li>请求方法是下面三个之一：<code>HEAD</code>，<code>GET</code>，<code>POST    </code></li>
<li>HTTP的头信息不超出以下字段：<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
</li>
</ol>
<p>这两个条件有任一不满足，就属于非简单请求。</p>
<p>对于简单请求，会在头信息中额外添加一个<code>Origin</code>字段，它包含发送请求页面的域（协议，域名和端口），服务器接收到这个值后，根据这个值决定是否同意这个请求。如果服务器可以同意这个请求，则会在响应头部加入<code>Access-Control-Allow-Origin</code>头部，包含相同的源，或者<code>*</code>（表示此资源公开），如果服务器不同意这个请求，则返回的头部中没有这个东西，浏览器如果在响应中没有找到此头部，则认为跨域请求被拦截，会抛出一个错误，但这个错误不能通过HTTP状态码识别，因为正常返回的响应可能是200，但只是被拦截。</p>
<p>其实除了<code>Access-Control-Allow-Origin</code>，还有两个可选字段<code>Access-Control-Allow-Credentials</code>，<code>Access-Control-Expose-Headers</code>，前者表示是否允许发送cookie，它的值只能设置为true，表示允许请求中携带cookie，默认CORS请求是不带cookie的，如果不想带cookie，这段删除即可。后者表示<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法还能否拿到其他字段，</p>
<p>非简单请求是指对服务器有特殊要求的请求，比如请求方法为<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段类型为<code>application/json</code>。</p>
<p>非简单CORS请求会在正式通信之前先增加一次预检请求，意思是首先请求服务器确认这样的请求是否可以被满足。这种预检请求机制允许使用自定义头部，允许使用除了<code>GET</code>和<code>POST</code>之外的方法，以及不同请求体内容类型。预检请求使用<code>OPTIONS</code>方法发送，其头部包含<code>Origin</code>，<code>Access-Control-Request-Method</code>，<code>Access-Control-Request-Headers</code>，前两个必选，第三个可选。第一个头部与简单请求中的origin相同，第二个头部表示请求希望使用的方法，第三个头部是可选的，表示自定义头部列表，使用逗号分隔。</p>
<p>服务器在接收<code>OPTIONS</code>请求后，会在响应中发送这些头部信息与浏览器沟通：</p>
<ul>
<li><code>Access-Control-Allow-Origin</code>：与简单请求含义相同</li>
<li><code>Accecss-Control-Allow-Methods</code>：本服务器允许的方法（一个用逗号分隔的列表）</li>
<li><code>Access-Control-Allow-Headers</code>：本服务器允许的头部（一个用逗号分隔的列表）</li>
<li><code>Access-Control-Max-Age</code>：缓存预检请求时间（单位为秒）</li>
</ul>
<p>预检请求返回后，结果会按响应指定的时间缓存一定时间，在这段时间内，不会再重新发送预检请求。</p>
<p>也就是说，第一次发送非简单请求时会发送两个请求，第二次发送时，如果第一次的预检请求缓存没有过期，则不会再重新发送一次预检请求，但如果过期了，就会再发送一次预检请求。预检请求中也可以携带凭据请求设置。</p>
<h2 id="实际解决跨域拦截的办法"><a href="#实际解决跨域拦截的办法" class="headerlink" title="实际解决跨域拦截的办法"></a>实际解决跨域拦截的办法</h2><p>我们在实际处理跨域问题当中是后端解决的，使用SpringBoot提供的<code>@Configuration</code>注解即可将其自动配置。</p>
<p>查阅资料可以知道axios也可以设定跨域，但我们在开发过程中尝试过一些方法均不成功，原因未知，最终是由后端添加配置解决了问题。</p>
<p>以下代码摘自我的Java Web课程设计，由驼君贡献的后端代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaee.keshe.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：TuoJun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>：2021/01/04 17:33</span></span><br><span class="line"><span class="comment"> * Description：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrosConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;HEAD&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此外还有一个abo的版本，是我们之前项目里使用过的，也可以处理跨域问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gk.gkserver.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.CorsFilter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> abo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/9/8 20:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@remarks</span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> CorsConfiguration <span class="title">corsConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        corsConfiguration.setMaxAge(<span class="number">3600L</span>);</span><br><span class="line">        <span class="keyword">return</span> corsConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, corsConfig());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="其他跨域解决方案"><a href="#其他跨域解决方案" class="headerlink" title="其他跨域解决方案"></a>其他跨域解决方案</h2><p>除了CORS之外，还有几种跨域解决方案，它们都有一定的局限性，但仍然有一些可圈可点之处。</p>
<ul>
<li>图片探测（image ping）</li>
</ul>
<p>利用<code>&lt;img&gt;</code>标签实现跨域通信的技术，因为任何页面都可以跨域加载图片。可以动态创建一个图片，然后通过它们的<code>onload</code>和<code>onerror</code>事件处理程序得知何时收到响应。这种技术常用于图片探测，数据通过查询字符串发送，响应随意，不过一般是位图图片或者204状态码。</p>
<blockquote>
<p>204 No Content 表示请求在服务端已经正常处理，但没有资源可以返回。一般来说不需要返回信息的请求可以返回204。</p>
</blockquote>
<p>浏览器通过图片探测拿不到任何数据，但监听的<code>onload</code>和<code>onerror</code>事件可以让开发者知道什么时候可以收到响应（测试服务器连通性）</p>
<p>《JavaScript高级程序设计》中说，图片探测可以被用于跟踪用户在页面上的点击或动态显示广告，但我实在不理解这俩操作到底有什么用以及怎么实现。。并且在搜索引擎中也找不到相关结果，大概是一个被遗弃的办法吧。</p>
<ul>
<li>JSONP</li>
</ul>
<p>JSONP是“JSON with padding”的简写，是JSON的一种变形体，看起来和JSON一样，但会包含在一个函数调用里。</p>
<p>JSONP格式包含两个部分：回调和数据，回调是在页面接收到响应之后执行的函数，通常回调函数的名称是通过请求来动态指定的，而数据就是作为参数传回给回调函数后的JSON数据，</p>
<p>一个典型的JSONP请求例子：<code>http://url.com/jsonp/?callback=handleResponse</code></p>
<p>这个例子里把回调函数的名字定为<code>handleResopnse()</code>。</p>
<p>JSONP调用的原理和图片探测类似，是动态创建<code>&lt;script&gt;</code>元素实现的，因为<code>&lt;script&gt;</code>的src属性也不受到跨域的限制，因为JSONP是有效的JavaScript，所以JSONP响应在被加载完成后会立即执行。</p>
<p>JSONP的优点是简单直观好用，可以直接访问响应体，但他的缺点非常致命：不安全。因为JSONP是从任意不同的域拉取可执行代码，如果这个域返回了恶意内容，只能删除JSONP，没有其他解决办法，所以在使用JSONP时一定要确保目标域可信任。此外，JSONP无法很好的确定请求是否失败，尽管HTML5中<code>&lt;script&gt;</code>元素有<code>onerror</code>事件，但目前还没有被任何浏览器实现。所以使用当中有一种使用计时器的替代方法，这种方法并不准确，但至少管点用。</p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>跨域</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>数据存储之Web Storage</title>
    <url>/2021/04/10/web-storage/</url>
    <content><![CDATA[<p>Web Storage是HTML5中提供的一套关于数据存储的解决方案。最早是网页超文本应用技术工作组在Web Applications 1.0规范中提出的。这个规范中的草案最终成为了HTML5中的一部分，后来又独立成为了自己的规范。它用来解决一些Cookie难以处理的存储问题。</p>
<p>Web Storage最新的规范版本是第2版，定义了<code>localStorage</code>和<code>sessionStorage</code>，前者为永久存储，后者为跨会话机制。这两种浏览器存储API提供了在浏览器中不受页面刷新影响而存储数据的两种方式。2009年之后所有主要供应商发布的浏览器版本在window对象上支持<code>localStorage</code>和<code>sessionStorage</code>。</p>
<p>本部分学习笔记摘抄自《JavaScript高级程序设计》第四版，第25章，客户端存储。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/fbe4bc917a6bf551562ce341ea66e5c7.jpg"></p>
<a id="more"></a>

<h2 id="Session-Storage对象"><a href="#Session-Storage对象" class="headerlink" title="Session Storage对象"></a>Session Storage对象</h2><p><code>sessionStorage</code>对象只存储会话数据，即其生命周期仅存在于会话存在期间，会话结束时则自动清除，也就是当页面关闭时就没有了。但是在里面存储的数据并不受页面刷新影响。存储在<code>sessionStorage</code>对象中的数据只能由最初存储数据的页面使用，对于多页应用程序的支持不是很好。</p>
<p>使用<code>sessionStorage</code>对象的方法很简单，可以使用<code>setItem()</code>方法向里面添加一个键值对数据，也可以使用属性直接存储数据。</p>
<p>存储过程因为需要写入磁盘，所以牵扯到读写方式问题。现代浏览器在实现存储写入时使用的是同步阻塞方式，所以数据会被立即提交到存储，在落实到API的具体实现上可能不会立即把数据存入磁盘，但在JavaScript中这种变化是不可见的，也就是表现为写入的任何数据都可以立即读取。但旧版IE（比如IE8）采用的事异步方式的数据写入，因此给数据赋值的时间和数据写入磁盘的时间略微会存在一些延迟，这种延迟在少量的数据上是完全看不出来的，但如果大量数据读入，可能会出现一些问题。在旧版IE中，可以考虑使用事务模式调用<code>sessionStorage</code>，比如在赋值之前使用<code>sessionStorage.begin()</code>，在赋值完成之后使用<code>sesstionStorage.commit()</code>提交事务，将数据强行写入磁盘。调用<code>begin()</code>是为了保证事务在代码执行期间没有磁盘写入的操作。</p>
<p>可以使用for循环遍历<code>sessionStorage</code>的值，使用<code>length</code>属性获得长度，使用<code>key()</code>方法传递下标获得键名，也可以使用for-in循环迭代key，然后使用<code>getItem()</code>方法获取值。</p>
<p>对于值的删除，可以使用<code>delete sessionStorage.属性</code>或者<code>sessionStorage.removeItem(&#39;key&#39;)</code>删除一个键值对。</p>
<p><code>sessionStorage</code>应该用于存储会话期间有效的小块数据，如果需要跨会话持久存储，需要使用<code>localStorage</code>。</p>
<h2 id="Local-Storage对象"><a href="#Local-Storage对象" class="headerlink" title="Local Storage对象"></a>Local Storage对象</h2><p>新修订的HTML5规范中，<code>localStorage</code>对象取代了<code>globalStorage</code>，这是一种在客户端进行持久化存储的机制，要访问同一个<code>localStorage</code>对象，页面必须来自同一个域，使用同样的端口和同样的协议，同一个域的子域也不可以。</p>
<p><code>localStorage</code>也可以像<code>sessionStorage</code>那样使用键值对操作和属性直接访问存取数据，也就是<code>setItem</code>，<code>getItem</code>等方法。</p>
<p>存储在<code>localStorage</code>中的数据会一直保留，直到有JavaScript代码删除了它或者用户清除了浏览器缓存。<code>localStorage</code>数据不受页面刷新影响，也不会因窗口关闭、标签页或重新启动浏览器而丢失。</p>
<h2 id="实际操作细节注意"><a href="#实际操作细节注意" class="headerlink" title="实际操作细节注意"></a>实际操作细节注意</h2><p>这里要特别感谢之前合作过的一位全栈同学给我的启发</p>
<p>我在实际开发中用到过一次<code>localStorage</code>，模拟一个按顺序上菜的过程，做了一个厨师与服务员之间的生产者-消费者模式，其中模式里面的仓库就要借助<code>localStorage</code>完成，这是一个等待上菜的缓冲队列，本质上是一个数组，复合类型的数据。在我存到<code>localStorage</code>里面时，居然发现它变成了<code>[Object object]</code>，这是为什么呢？</p>
<p>因为，实际上这两者在存储时，存储的是字符串，引用类型并不能直接存储进<code>localStorage</code>，所以需要使用<code>JSON.stringify</code>将它转化成JSON，然后在获得的时候再使用<code>JSON.parse</code>转化成引用对象，就可以了。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Web Storage</tag>
      </tags>
  </entry>
  <entry>
    <title>盒模型详解—你真的了解盒模型吗？</title>
    <url>/2021/04/08/box-model/</url>
    <content><![CDATA[<p> 突然想到前几天面试的一个尴尬场景。关于盒模型理论，我以前确实有拿来认真了解，我以为我还是知道的，结果面试官一个问题把我问蒙了：</p>
<p>“请你说一下W3C盒模型和IE盒模型的区别。”</p>
<p>我…..这是啥？</p>
<p>为了避免这样的丢人事件再次发生，我打算重新认真学习一下。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/098a3a9cacf4a7ee778583aaf147d701.jpg"></p>
<a id="more"></a>

<h2 id="W3C盒模型理论基础"><a href="#W3C盒模型理论基础" class="headerlink" title="W3C盒模型理论基础"></a>W3C盒模型理论基础</h2><p>盒模型指的是HTML元素在浏览器引擎当中的一种构建模式，它把网页当中的所有元素都看成一个个大小不一的盒子互相嵌套。盒模型理论出现的比较早，在199年就有W3C提出了这个理论。尽管CSS标准中为其服务的<code>margin</code>，<code>padding</code>，<code>width</code>，<code>height</code>等并没有用盒模型这个术语进行描述，但那时候的开发者以及浏览器厂商已经在使用这个术语了。</p>
<p>这里讨论的是W3C盒模型。</p>
<p>盒模型理论将所有HTML元素视为盒子，如<code>div</code>，<code>p</code>等元素均视为盒子。对于每个盒子来说，它有五个参数用于支撑模型布局：</p>
<ol>
<li>高度，<code>height</code>。用于描述实际内容的高度，简称为高。</li>
<li>宽度，<code>width</code>。与高度类似，用于描述实际内容的宽度，简称为宽。</li>
<li>内边距，<code>padding</code>。内边距描述了内容与边框之间的距离，有上下左右四个方向，简称方向+内距，如左内距，右内距。</li>
<li>外边距，<code>margin</code>。外边距描述了盒子与盒子之间的间隔距离，有上下左右四个方向，简称方向+外距。</li>
<li>边框，<code>border</code>。边框是内外边距之间的分界层，可以是任意类型和宽度的线，表示盒子内部和盒子外部的分隔，也有上下左右四个方向。尽管实际开发当中盒子的边框一般都很窄或者没有。（尽管可以没有边框，但在理论模型上边框存在，可以理解成实际使用时加入了一个宽度为0的边框），简称方向+边。</li>
</ol>
<p>下图描述了W3C盒模型的图形表示（图片摘自Wikipedia-CSS box model）</p>
<p><img src="https://z3.ax1x.com/2021/04/10/caQJjH.png"></p>
<p>使用盒模型可以描述绝大多数页面的结构。在CSS3中，盒模型被并入标准，被称为<code>border-box</code>。</p>
<p>对于一个盒子的总宽度和总高度而言，其计算方法是显然的：</p>
<blockquote>
<p>总宽度=宽+左右内距+左右外距+左右边</p>
<p>总高度=高+上下内距+上下外距+上下边</p>
</blockquote>
<h2 id="W3C盒模型与IE盒模型的区别"><a href="#W3C盒模型与IE盒模型的区别" class="headerlink" title="W3C盒模型与IE盒模型的区别"></a>W3C盒模型与IE盒模型的区别</h2><p>这里面牵扯到一个历史问题。在HTML4版本之前和CSS出现之前，只有很少的元素支持<code>padding</code>，不同元素的宽高计算方法不尽相同。在盒模型理论提出之前，HTML元素的显示还没有一个很统一的标准。当时，浏览器对于盒模型的适应性还不很好，比如当时的IE4和Netscape 4.0都把宽高定义为边框到边框的距离，这种定义方式的盒模型就被称为IE盒模型，计算距离不适用刚才写的计算公式。可以通过下面的一张图看出区别来。</p>
<p><img src="https://z3.ax1x.com/2021/04/10/caQtud.png"></p>
<p>Wikipedia指出，通常认为IE盒模型是一个错误的盒模型，因为它处理元素的方式并不遵循W3C的标准，这将导致各种各样的显示错误。直到IE6之后，IE才支持了W3C标准的盒模型。但是由于当时需要考虑到向下兼容，默认情况下，IE仍然以它自己的盒模型方式运行。这种行为非常怪异，所以一般将其称之为“怪异盒模型”，将W3C盒模型称为“标准盒模型”。不过Mac上的IE浏览器貌似就没有这样奇怪的设定，遵循了W3C标准。</p>
<p>在标准模式下，使用W3C标准渲染，但对特别远古的浏览器不支持。在怪异模式下，采用向后兼容模式，可能会出现怪异盒模型这样的渲染。</p>
<p>尽管曾经有人想过利用CSS的各种bug让低版本浏览器强行支持W3C标准的盒子，但实践证明那样用bug修bug的操作是不可靠的，那如何让浏览器完全区分标准模式和怪异模式呢？</p>
<h2 id="扩充：标准模式与怪异模式-quirks-mode"><a href="#扩充：标准模式与怪异模式-quirks-mode" class="headerlink" title="扩充：标准模式与怪异模式(quirks mode)"></a>扩充：标准模式与怪异模式(quirks mode)</h2><p>标准模式与怪异模式下的渲染模式有很大不同，尽管现在都是标准模式渲染了，但也可以了解一下两者之间的区别。</p>
<p>怪异模式是浏览器为了兼容很早以前的旧版本浏览器设计的，并不遵循W3C标准。换句话说，是故意模拟出来一些旧浏览器的bug来让旧标准的网页能够正常显示。（好家伙，负负得正是吧）</p>
<p>标准模式是微软在2000年IE5发布时提出的一个标准，因为IE5在当时已经实现了当时比较先进的HTML4标准，但同时IE5也要兼容以前浏览器下的内容，所以微软想到了一个文档类型声明的方式，就是HTML代码最前面的<code>DOCTYPE</code>。让浏览器在解析HTML文档之前首先判断一下遵循了什么标准。</p>
<p><code>DOCTYPE</code>的全称叫做Document Type Declaration，或者叫做DTD。之前还一直好奇DTD到底是什么，现在算是明白了。</p>
<p>现代浏览器如何区分标准模式与怪异模式？一般来说，当出现以下情况之一时，浏览器将触发怪异模式。</p>
<ol>
<li><code>doctype</code>声明缺失或不完整；</li>
<li>遇到HTML 3或更早的文档时；</li>
<li>使用HTML 4文档但系统标识符不存在时；</li>
<li>SGML注释或其他无法识别的内容出现在文档类型声明之前时；</li>
<li>在IE6下，文档类型声明之前出现了一个XML声明时；</li>
</ol>
<p>当DTD遇到这些声明时，将判断为不同的标准：</p>
<p><code>&lt;!DOCTYPE html&gt;</code>：这代表此页面遵循HTML5规范，浏览器选择标准模式，这是目前最合适的一种模式，写页面无脑加就ok，除非极其特殊的情况。</p>
<p><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&gt;</code>：这代表HTML4的一种规范，浏览器仍然会选择标准模式，但和HTML5有一些区别。</p>
<p><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</code>：这时候选择的不是完全的标准模式，而是“Almost Standards Mode”（几乎标准的模式），里面也和标准模式差不多，但有些地方在转化为HTML5标准时可能会出现混乱。</p>
<p>其他情况可以参考怪异模式的触发条件。</p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>盒模型</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用校园邮箱申请正版JetBrains全家桶</title>
    <url>/2021/04/08/How-to-apply-for-JetBrains-IDE-using-your-campus-email/</url>
    <content><![CDATA[<p> 众所周知，JetBrains家的IDE功能非常强大，真可谓开发利器，高级生产力工具。但是很多IDE的收费是很贵的，个人使用承担不起这样昂贵的价格，使用校园邮箱提供的学生优惠就可以免费申请到一年的JetBrains IDE全家桶，这样我们就能开心的使用这些功能强大的IDE啦。</p>
<p>虽然一次申请只有一年，但在到期之前可以再申请续一下，这样就可以用很长时间了。</p>
<p>校园邮箱从哪获得呢？这篇教程我以我本学校的邮箱举例，不同学校的校园邮箱使用平台不尽相同，但基本操作都大同小异，按照学校给的教程开通一下账号就可以使用了。</p>
<p>啥，你说你们学校没说过校园邮箱的事情？说不定是学校有但是低调了一些，多打听打听，会找到答案的。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/bfed5b93381b2701fe229b269df387e1.jpg"></p>
<a id="more"></a>

<h2 id="1-开通校园邮箱账号"><a href="#1-开通校园邮箱账号" class="headerlink" title="1. 开通校园邮箱账号"></a>1. 开通校园邮箱账号</h2><p>这里以我学校为例，如果你是其他学校的同学，应当参照你们学校发布的校园邮箱使用说明。</p>
<p>一般来说，校园邮箱的邮箱地址都是带<code>stu</code>的，比如我校的是<code>@stu.qlu.edu.cn</code>。</p>
<p>首先打开<a href="http://mail.stu.qlu.edu.cn/">http://mail.stu.qlu.edu.cn/</a>，首次登录需要使用学号为账号，系统会提供一个默认密码，第一次登录成功后需要及时修改。</p>
<p>进入邮箱界面后，可以检查一下是否有安全策略等可能阻挡邮件接收的地方，或者自己发个邮件测试一下，没问题的话就进行下一步了。</p>
<p><img src="https://z3.ax1x.com/2021/04/08/cJ58JK.png"></p>
<p><img src="https://z3.ax1x.com/2021/04/08/cJOtQx.png"></p>
<h2 id="2-开通JetBrains账号"><a href="#2-开通JetBrains账号" class="headerlink" title="2. 开通JetBrains账号"></a>2. 开通JetBrains账号</h2><p>打开JetBrains官网<a href="https://www.jetbrains.com/">https://www.jetbrains.com/</a>，在主页上方导航栏内点击小人图标，进入登录注册页面。</p>
<p><img src="https://z3.ax1x.com/2021/04/08/cJIYt0.png"></p>
<p>在下方对话框里输入你的注册邮箱（注意，这个可以不是你的校园邮箱，二者可以不相同），然后点击Sign Up</p>
<p><img src="https://z3.ax1x.com/2021/04/08/cJIdcF.png"></p>
<p>然后你就可以收到一封确认信息的注册邮件了。</p>
<p><img src="https://z3.ax1x.com/2021/04/08/cJoC40.png"></p>
<p><img src="https://z3.ax1x.com/2021/04/08/cJoiCV.png"></p>
<p>按照提示完成后续注册。</p>
<p><img src="https://z3.ax1x.com/2021/04/08/cJoDxS.png"></p>
<p>记得把<code>I have read and I accept the JetBrains Account Agreement</code>打上勾，然后点击submit就可以完成注册了。</p>
<h2 id="3-申请学生优惠"><a href="#3-申请学生优惠" class="headerlink" title="3. 申请学生优惠"></a>3. 申请学生优惠</h2><p>下面就到最关键的一步了，开始准备申请学生优惠。</p>
<p><img src="https://z3.ax1x.com/2021/04/08/cJTHl8.png"></p>
<p>点击这个<code>Apply for a free student or teacher license for educational purposes</code>，就可以进入到学生优惠申请界面。</p>
<p>然后点击下面的<code>Apply now</code>。</p>
<p><img src="https://z3.ax1x.com/2021/04/08/cJ7290.png"></p>
<p>之后会弹出一个让你填写信息的页面，按照下图的说明填写即可。</p>
<p><img src="https://z3.ax1x.com/2021/04/08/cJHXin.png"></p>
<p>点击申请后，你的校园邮箱（不一定是你的账号邮箱）里面会收到一封确认邮件，按照提示点击确认。</p>
<p>（我的账号已经申请过了，且确认邮件是在学校换邮件系统之前发的，所以现在的邮箱里没有这封邮件了，我从朋友的教程那里引了张参考图）</p>
<p><img src="https://s1.ax1x.com/2020/04/04/Gw79Kg.png"></p>
<p>如果上面的步骤都没有问题的话，申请通过后，你的主页上应该会这样显示：</p>
<p><img src="https://z3.ax1x.com/2021/04/08/cJbhTJ.png"></p>
<p>这里我用了我之前的账号，上面显示到今年6月底就会到期，不过还可以继续申请使用。</p>
<p>到此为止，所有的申请工作就已经结束啦，可以去下载你喜欢的IDE使用了。</p>
<h2 id="4-下载你喜欢的IDE"><a href="#4-下载你喜欢的IDE" class="headerlink" title="4. 下载你喜欢的IDE"></a>4. 下载你喜欢的IDE</h2><p>可以直接从官网导航找到你喜欢的IDE，比如WebStorm或IDEA Ultimate。</p>
<p><img src="https://z3.ax1x.com/2021/04/08/cJLUaQ.png"></p>
<p><img src="https://z3.ax1x.com/2021/04/08/cJLNVg.png"></p>
<p>当然，你也可以选择使用官方的工具箱进行IDE的管理，下载Toolbox即可。链接：<a href="https://www.jetbrains.com/toolbox-app/">https://www.jetbrains.com/toolbox-app/</a></p>
<p><img src="https://z3.ax1x.com/2021/04/08/cJLjJA.png"></p>
<p>下载安装过程这里不再赘述。</p>
<p>第一次启动时，会要你登录JetBrains账号，它会自动检测你的学生优惠许可，然后就自动激活啦。</p>
<p>接下来就是快乐的搬砖时间~</p>
<p><img src="https://z3.ax1x.com/2021/04/08/cJOrYd.png"></p>
]]></content>
      <categories>
        <category>教程相关</category>
      </categories>
      <tags>
        <tag>校园邮箱</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>图解HTTP学习笔记—HTTP状态码</title>
    <url>/2021/04/07/HTTP-status-code/</url>
    <content><![CDATA[<p>《图解HTTP》是一本特别浅显易懂的书，形象地解释了HTTP协议中的各种内容。这篇学习笔记摘自原书第四章，返回结果的HTTP状态码。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/1617767935116.jpg"></p>
<a id="more"></a>

<p>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求的结果。借助状态码，用户可以直观的知道服务器是否正常处理了请求。</p>
<p>状态码的类别大概可以分为五种，1xx的信息性状态码，表示请求正在处理；2xx的成功状态码，表示请求成功处理；3xx的重定向状态码，表示需要附加操作；4xx的客户端错误状态码，表示服务器无法处理这个请求；5xx的服务器错误状态码，表示服务器程序在处理请求时报错了。</p>
<p>标准化制定的状态码有总60余种，但其实如果能保证遵循类别定义的话，状态码是可以自行设定的。</p>
<p>这里介绍一部分常见的状态码。</p>
<h2 id="1XX状态码：正在处理"><a href="#1XX状态码：正在处理" class="headerlink" title="1XX状态码：正在处理"></a>1XX状态码：正在处理</h2><p>1xx状态码是 HTTP/1.1协议新增的状态码, HTTP/1.0中不存在。</p>
<p>100 Continue 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</p>
<p>101 Switching Protocols 请求者已要求服务器切换协议，服务器已确认并准备切换。</p>
<p>102 Processing 代表处理将被继续执行。</p>
<h2 id="2XX状态码：成功处理"><a href="#2XX状态码：成功处理" class="headerlink" title="2XX状态码：成功处理"></a>2XX状态码：成功处理</h2><p>200 OK 表示请求在服务端被正常处理，一切正常。</p>
<blockquote>
<p>其实之前开发的时候貌似无论请求对错，只要正常回来就都返回200了，这种响应按标准来说是错误的。比如某个请求应当出错但返回了200，响应体里面包含了报错信息…我们成天这么干（</p>
</blockquote>
<p>204 No Content 表示请求在服务端已经正常处理，但没有资源可以返回。一般来说不需要返回信息的请求可以返回204。</p>
<p>206 Partial Content 表示这个请求只需要资源的一部分，服务器只返回需要范围内的资源。响应报文中包含由Content-Range指定范围的资源。</p>
<h2 id="3XX状态码：重定向"><a href="#3XX状态码：重定向" class="headerlink" title="3XX状态码：重定向"></a>3XX状态码：重定向</h2><p>301 Moved Permanently 永久性重定向，表示请求的资源已经被分配给了新的URI，以后应该用新URI请求。</p>
<p>302 Found 临时性重定向，表示请求的资源已经被分配给了新的URI，希望用户在本次能使用新的URI访问。（这个和301很像但不同，301表示永久移动，302表示临时移动，也就是说如果返回302，则表示这个URI在短期的未来内还有可能发生多次改变，而301的变动一般是长期的）</p>
<p>303 See Other 表示由于请求对应的资源存在着另一个URI，应该使用GET方法定向获取请求的资源。（303和302又很像，但303规定了服务端希望客户端使用GET）</p>
<blockquote>
<p>当301,302,303状态码被返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。301,302标准是禁止将POST改为GET的，但是实际用的时候大家都无视了这个规则。</p>
</blockquote>
<p>304 Not Modified 表示资源已找到，但是并不符合条件中的要求，此时服务器端资源并未改变，可以直接使用客户端未过期的缓存。附带条件的请求是指GET方法中的请求报文内包含了<code>If-Match</code>等各种条件限制的首部。（304虽然被划分在重定向类别里，但其实和重定向没什么关系）</p>
<p>307 Temporary Redirect 临时重定向。此状态码和302含义相同，但它不会把POST变成GET，不过不同浏览器也会有不同情况。</p>
<h2 id="4XX状态码：客户端错"><a href="#4XX状态码：客户端错" class="headerlink" title="4XX状态码：客户端错"></a>4XX状态码：客户端错</h2><p>400 Bad Request 请求出错。表示请求报文存在语法错误，需要客户端修改请求后再次发送。</p>
<p>401 Unauthorized 需要认证。表示发送的请求需要通过一层HTTP认证的认证信息。另外如果之前已经进行过一次请求，则表示用户认证失败。返回含有401的响应必须包含一个适用于被请求资源的<code>WWW-Authenticate</code>首部用以质询用户信息。浏览器初次接收到401时，会弹出认证用的会话窗口。</p>
<p>403 Forbidden 请求访问被拒绝。服务端没必要给出详细的拒绝理由，但如果服务端想的话也不是不行，在响应报文主体部分进行一些描述就可以了。</p>
<p>404 Not Found 【找不着了】</p>
<blockquote>
<p>如果你想的话，也可以拿404当403用，拒绝这个请求并表示不想说明理由。</p>
</blockquote>
<h2 id="5XX状态码：服务端错"><a href="#5XX状态码：服务端错" class="headerlink" title="5XX状态码：服务端错"></a>5XX状态码：服务端错</h2><p>500 Internal Server Error 表示<del>后端又炸了</del>服务器在执行请求时出错了，一般是服务器端的处理程序出现了bug。</p>
<p>502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</p>
<p>503 Service Unavailable 表示现在服务器太忙了，正在超负载或者停机维护，目前无法处理请求<del>（想到了某教务系统）</del>，</p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>使用CSS对盒子水平垂直居中的几种方法</title>
    <url>/2021/04/07/horizontal-and-vertical-center-of-CSS/</url>
    <content><![CDATA[<p> 将盒子水平居中是一件不难办的事情，那么如何做到水平垂直同时居中呢？这时候就需要思考一下了。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/6aaabe6d72ba01b944259bcdbaee6acd.jpg"></p>
<a id="more"></a>

<p>就不贴效果图了，效果图都是水平垂直居中的。</p>
<h2 id="方法一-flex布局"><a href="#方法一-flex布局" class="headerlink" title="方法一 flex布局"></a>方法一 flex布局</h2><p>核心点在于，给父元素使用flex布局，并设置<code>align-items</code>和<code>justify-content</code>为<code>center</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>水平垂直居中<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line">        width: 500px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background-color: skyblue;</span><br><span class="line">        display: flex;</span><br><span class="line">        align-items: center;</span><br><span class="line">        justify-content: center;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: green;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方法二-CSS3-transform"><a href="#方法二-CSS3-transform" class="headerlink" title="方法二 CSS3 transform"></a>方法二 CSS3 transform</h2><p>这个方法的核心是采用<code>transform: translate</code>进行盒子的偏移，需要对子元素设置百分比的高度。</p>
<p>以X轴举例，假如子元素的<code>width</code>是x%，那么如果要让x%居中，它两边的距离（需要偏移的量）应当是<code>(100%-x%)/2</code>，那么<code>translate</code>里面需要填入的值为偏移量与原宽之比，也就是<code>(100%-x%)/(2*x%)</code>。如果是Y周，则变化的x%为<code>height</code>。</p>
<p>这里我为了好算全都定成了50%，实际使用可能有除不开的，建议换成sass这样的高级装备。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>水平垂直居中<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line">        width: 500px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background-color: skyblue;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line">        width: 50%;</span><br><span class="line">        height: 50%;</span><br><span class="line">        background-color: green;</span><br><span class="line">        transform: translate(50%, 50%);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方法三-绝对定位-负margin偏移"><a href="#方法三-绝对定位-负margin偏移" class="headerlink" title="方法三 绝对定位+负margin偏移"></a>方法三 绝对定位+负margin偏移</h2><p>需要将父元素的<code>position</code>设置为<code>relative</code>等能够脱离正常文档流显示的方式以便于子元素的盒子能套在里面，子元素的<code>position</code>设置为<code>absolute</code>做一个绝对定位，并将<code>left</code>和<code>top</code>都设置为50%，此时盒子是不完全居中的，因为有他自己的大小，会导致偏右下一些，所以此时需要使用负margin做个补偿，偏移它长宽的大小。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>水平垂直居中<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line">        width: 500px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background-color: skyblue;</span><br><span class="line">        position: relative;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: green;</span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 50%;</span><br><span class="line">        top: 50%;</span><br><span class="line">        margin: -50px 0 0 -100px;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方法四-完全绝对定位-自动margin"><a href="#方法四-完全绝对定位-自动margin" class="headerlink" title="方法四 完全绝对定位+自动margin"></a>方法四 完全绝对定位+自动margin</h2><p>与方法三差不太多，将四个位置的距离都置为0，并添加一行<code>margin: auto</code>，也可以实现水平垂直居中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>水平垂直居中<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line">        width: 500px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background-color: skyblue;</span><br><span class="line">        position: relative;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: green;</span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 0;</span><br><span class="line">        right: 0;</span><br><span class="line">        top: 0;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        margin: auto;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="方法五-after伪元素"><a href="#方法五-after伪元素" class="headerlink" title="方法五 ::after伪元素"></a>方法五 ::after伪元素</h2><p>改变子元素显示为行内元素，然后使用<code>vertical-align:middle</code>对齐after伪元素。</p>
<p>知识点补充：<code>::after</code>伪元素中特有的content，用于在CSS渲染中向此元素逻辑上的头部和尾部添加内容，这些改动不会在DOM里出现，也不会改变文档内容，不可复制，仅渲染。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>水平垂直居中<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line">        width: 500px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background-color: skyblue;</span><br><span class="line">        text-align: center;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: green;</span><br><span class="line">        display: inline-block;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.box1</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">        content: &#x27;&#x27;;</span><br><span class="line">        display: inline-block;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">        height: 100%;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中的深拷贝与浅拷贝</title>
    <url>/2021/04/06/deep-copy-and-shallow-copy/</url>
    <content><![CDATA[<p> 最近在面试和学习当中都遇到了关于深拷贝和浅拷贝的问题，由于之前做项目没有遇到过此类问题，这里做一个简单的记录，学习一下。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/1617734300860.jpg"></p>
<a id="more"></a>

<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>前置知识：js的数据类型。</p>
<p>在JavaScript里面，数据类型可以分为两大类，基本类型和引用类型。</p>
<p>基本类型也就是简单的数据类型，比如Number, null, Boolean, String, undefined, Symbol，而引用类型通常是复合类型，比如Object, Array, Function, Date, RegExp等。</p>
<p>基本类型存储在栈中，以键值对的形式，引用类型的值保存在堆中，对象的引用保存在栈中，啥叫对象的引用呢，可以简单理解为这是个指针。访问的时候，我们不能访问堆，需要通过栈间接访问堆。</p>
<p>那么深拷贝和浅拷贝到底是什么东西呢？首先明确拷贝是什么。拷贝就是复制，创建一个新变量时使用原有变量的“内容”创建，复制一份新的。</p>
<p>在复制的过程中，问题就出现在引用类型里，我要复制的是对象的引用，还是对象的本身？这听起来似乎有点绕，可以换个方式理解：假如我要复制一个对象，我是要让复制后的对象也指向原来的内容，还是重新创建一份完全一样的新对象？</p>
<blockquote>
<p>“当我的全身都被更换，就连我的大脑一起都被换掉时，那时候的我，还会是‘我’吗？”</p>
</blockquote>
<p>这里面就牵扯到深拷贝和浅拷贝的概念了。所谓浅拷贝，就是在复制的时候只复制所有的引用，复制之后的新对象里，只是创建了一个新的访问原来位置的引用，而原来这个位置本身的内容，没有被重新创建。那么深拷贝就是与其相对应的，不仅引用被复制了，连引用指向的原位置的内容也被重新复制了一份，创建了一个新的。</p>
<p>那么既然这样，深拷贝就一定比浅拷贝好吗？在实际应用中是否应当全都使用深拷贝？其实不一定。深拷贝可能需要经过多层递归调用，效率通常会低一些，而有时候浅拷贝就能满足很多实际场景的要求。</p>
<h2 id="浅拷贝实际应用"><a href="#浅拷贝实际应用" class="headerlink" title="浅拷贝实际应用"></a>浅拷贝实际应用</h2><p>以下是几个例子。</p>
<p><code>Object.assign()</code>，把任意多个源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。</p>
<p><code>展开运算符...</code>，与<code>Object.assign()</code>功能相同。</p>
<p><code>赋值运算符=</code>，赋值只会赋给引用，算浅拷贝。</p>
<p><code>Array.prototype.concat()</code>，返回一个新数组，但如果数组中有嵌套对象则为浅拷贝</p>
<p><code>Array.prototype.slice()</code>，返回一个新数组，但如果数组中有嵌套对象则为浅拷贝</p>
<p>上面这些操作只能算是在一维或者在一层上进行了深拷贝，如果有二层以上则无法完全拷贝，所以算是浅拷贝了。</p>
<h2 id="浅拷贝手动实现"><a href="#浅拷贝手动实现" class="headerlink" title="浅拷贝手动实现"></a>浅拷贝手动实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">    		newObj[key] = obj[key];</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="深拷贝实际应用"><a href="#深拷贝实际应用" class="headerlink" title="深拷贝实际应用"></a>深拷贝实际应用</h2><p><code>JSON.parse(JSON.stringify(obj))</code>，这种JSON化的方式可以实现多维或多层对象的深拷贝，但会忽略undefined、任意的函数、symbol，所以这种方式不能完全解决深拷贝问题。</p>
<p><code>Object.create(obj)</code>可以做到深拷贝。</p>
<h2 id="深拷贝手动实现"><a href="#深拷贝手动实现" class="headerlink" title="深拷贝手动实现"></a>深拷贝手动实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">    		newObj[key] = <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ? deepCopy(obj[key]) : obj[key];</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>由一条SQL语句引发的思考</title>
    <url>/2021/03/05/A-thinking-in-one-SQL-statement/</url>
    <content><![CDATA[<p>帮老师干活，做2020年山东高考录取情况的汇总表，纯靠Excel总归有些操作不是很好处理，所以我借助了MySQL数据库完成一些比如复杂条件合并的操作。</p>
<p>昨天晚上老师要我把两个Excel表里面的一些数据合并一下，但在执行修改操作时发现这条语句跑了两分钟还要多，感觉这不合理，于是来思考一下，到底是为什么会造成这样的？</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/1619365291923.jpg"></p>
<a id="more"></a>

<h2 id="确认需求"><a href="#确认需求" class="headerlink" title="确认需求"></a>确认需求</h2><p><img src="https://s3.ax1x.com/2021/03/05/6eXGH1.png"></p>
<p><img src="https://s3.ax1x.com/2021/03/05/6eX8BR.png"></p>
<p>上面是两个表的数据，其中<code>bkzy2020</code>表代表2020年本科专业的数据，我已经将专业代号和学校代号使用子串操作取了出来。<code>detail2020</code>是2020年本科专业招生的细节数据，其中我需要合并的是<code>detail2020</code>中的<code>major_name</code>（专业全称）和<code>subject_select</code>（选科要求），要把这两条数据按照专业代号和学校代号双对应的条件合并到<code>bkzy2020</code>中。</p>
<h2 id="初期尝试与发现的问题"><a href="#初期尝试与发现的问题" class="headerlink" title="初期尝试与发现的问题"></a>初期尝试与发现的问题</h2><p>这好像挺简单的，思路是使用<code>UPDATE</code>语句修改<code>bkzy2020</code>中的<code>major_name_full</code>和<code>subject_select</code>，条件是两个表的专业代号和学校代号能对应起来。然后有了下面的SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> bkzy2020, detail2020</span><br><span class="line"><span class="keyword">SET</span> bkzy2020.major_name_full = detail2020.major_name , bkzy2020.subject_select = detail2020.subject_select</span><br><span class="line"><span class="keyword">WHERE</span> bkzy2020.major_id = detail2020.major_id <span class="keyword">and</span> bkzy2020.school_id = detail2020.school_id</span><br></pre></td></tr></table></figure>

<p>但这个SQL存在的问题是，他太慢了。跑了几十秒都没有出结果，感觉有点像是写错了，可就我这花瓶功夫的SQL技术也不知道该从哪下手，于是我去找了驼君同学。</p>
<h2 id="与驼君同学的讨论"><a href="#与驼君同学的讨论" class="headerlink" title="与驼君同学的讨论"></a>与驼君同学的讨论</h2><p>果然是基础不牢地动山摇，其实这个更新是可以在形式上简化一下的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> bkzy2020 a , detail2020 b</span><br><span class="line"><span class="keyword">SET</span> a.major_name_full = b.major_name , a.subject_select = b.subject_select</span><br><span class="line"><span class="keyword">WHERE</span> a.major_id = b.major_id <span class="keyword">and</span> a.school_id = b.school_id</span><br></pre></td></tr></table></figure>

<p>这样写就舒服多了，其中a和b是代表<code>bkzy2020</code>和<code>detail2020</code>的别名。</p>
<p>实际上在第一次跑SQL的时候，我漏加了一个条件，当时没注意，后来我在后台挂着这条语句的执行去和驼君讨论，没想到过了一会后，它提示跑出来了…</p>
<p><img src="https://s3.ax1x.com/2021/03/05/6mCIAJ.png"></p>
<p>135秒，两分钟多了。然而由于这里只对了专业id没有加学校id，导致到后面对应出来的成了这样子：</p>
<p><img src="https://s3.ax1x.com/2021/03/05/6mPp4A.png"></p>
<p>其实这里如果是所有学校专业代号互不重复的话，不判断学校也是没问题的，但实际上专业代号在学校之间会重复，只能保证在某个学校内的专业代号互不重复。</p>
<p>后来我加上学校的判断条件后（也就是执行了上面贴出来那段SQL），又跑了140多秒，这次执行应该没啥问题了…奇怪，为啥仍然有对不上的？</p>
<p><img src="https://s3.ax1x.com/2021/03/05/6mPM3q.png"></p>
<p><img src="https://s3.ax1x.com/2021/03/05/6mPQg0.png"></p>
<p>后来发现这其实是个低级错误…这是第一次修改遗留下来的问题！在执行第二次修改时没有对数据进行清空，所以导致出现了这样的问题。</p>
<p>清空一下，重新开始再跑两分钟..</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> bkzy2020 <span class="keyword">set</span> major_name_full = <span class="literal">null</span>, subject_select = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>这样总算是能做到结果没问题了，我将数据表导出为Excel文件，接下来就轮到复盘瞎搞的时间了。</p>
<h2 id="最终解决方案与思考"><a href="#最终解决方案与思考" class="headerlink" title="最终解决方案与思考"></a>最终解决方案与思考</h2><p>为什么这条SQL会这么慢？</p>
<p>就数据量而言，说大不大，说小不小。两个表的规模大概都在16000条左右，但不相同。驼君同学说，因为我没加索引，这条修改走的是全表扫描，也就是规模大概有个一万六乘一万六的笛卡尔积。想想貌似挺恐怖的…</p>
<p><img src="https://s3.ax1x.com/2021/03/05/6mVXRJ.png"></p>
<p>那加上索引试试吧：</p>
<p><img src="https://s3.ax1x.com/2021/03/05/6mZsSJ.png"></p>
<p>索引类型选NORMAL，索引方法选BTREE，此时再分析一下刚才那条查询，对比一下添加前后的执行情况，如图所示：</p>
<p><img src="https://s3.ax1x.com/2021/03/05/6mZoSH.png"><br><img src="https://s3.ax1x.com/2021/03/05/6mZTld.png"></p>
<p>能够看到，扫描的行数直接减少了一万六，所以理论上性能会得到一个很大的提升。</p>
<p>此时再清空数据尝试一下：</p>
<p><img src="https://s3.ax1x.com/2021/03/05/6meEkT.png"></p>
<p>时间降低到了0.29秒，这才对味。</p>
<p>感觉以我的能力而言，这样的优化已经算是做到极限了。那么，为什么增加索引能够有效提升性能呢？</p>
<p>索引是一种特殊的数据库结构，由数据表中的一列或多列组合而成，可以用来快速查询数据表中有某一特定值的记录。通过索引，查询数据时不用读完记录的所有信息，而只是查询索引列。否则，数据库系统将读取每条记录的所有信息进行匹配。</p>
<p>在MySQL中，通常是使用顺序访问和索引访问两种方式访问数据库表的数据。其中顺序访问即为全表扫描，在数据量大时速度会很低。索引访问相当于建立了一个快速查找的表，通过关键字直接定位到数据所在行，当然这里的关键字不应当重复。返回到我的问题中，我的情况还不太一样，我有两个id，必须得保证两两对应才行，可是如果要这样想，索引有两个，要怎么办呢？其实可以把思维换个方向，把学校代号-专业代号这一对看成一个整体的id，这样就可以保证完全不重复了！所以在索引字段中，就把<code>major_id</code>和<code>school_id</code>加上。</p>
<p>索引类型有FULLTEXT、NORMAL、SPATIAL、UNIQUE，分别是全文索引，普通索引，空间索引，唯一索引。</p>
<p>这里使用的是NORMAL索引，大部分情况下的默认选择。</p>
<p>UNIQUE代表不重复索引，适用于字段信息保证不会重复的情况。</p>
<p>FULLTEXT代表全文索引，适用于检索长文本，搜索长文章的时候效果最好，这里的ID都很短，所以就不首选使用这个了。</p>
<p>SPATIAL是空间索引，对空间数据类型建立的索引。这个一般用于多维度的数据，比如空间几何上或者GPS上的信息，这里也不使用。</p>
<p>索引方法一般有BTREE，Hash，RTREE。</p>
<p>BTREE索引是最常见的索引类型，我曾经也做过一个用B-TREE模拟数据库索引进行快速查询的课程设计。</p>
<p>Hash索引的检索效率比BTREE高，但是对查询有所限制。</p>
<p>RTREE索引很少使用，一般是用在SPATIAL索引里面。</p>
<p>这个整理数据的工作我也是做了一段时间了，做之前感觉无非就是增删改查，我写写SQL语句然后拿Excel处理处理还不就行了，有什么难的，但实际接手之后才发现其实有各种各样的问题。因为全国各种学校的数据真的是太复杂了，还赶上了新高考改革，不仅专业有改变，名称也不完全一样，这在我匹配数据时出现了相当多的麻烦。最初做成绩数据合并的时候因为很难直接用SQL语句做修改，所以我加急学了Node.js做了个小后端，挂上MySQL数据库驱动硬写了个半自动的程序，就算这样也跑了好长时间，性能优化之类的事情完全不懂。这次这个小需求又遇到了性能问题，越来越能感觉到自己其实很多东西学的仍然不是很牢固，大二下学期学的数据库全还给老师了。。即便是方向上选择了前端开发，但也不代表说其他计算机的基础知识就能一点不懂，如果真的变成了那样，那我这科班读出来的学生和花几万块钱在外面辅导班培训出来的又有什么区别呢？</p>
<p>不仅专业知识要过硬，基础知识也要过硬，业务能力要有，科学素养也有，这样才是一个合格的计算机行业工作者，现在的我仍然还是欠缺一些啊。。</p>
]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js复习巩固笔记</title>
    <url>/2021/03/03/vue-review-note/</url>
    <content><![CDATA[<p>最近学习其实遇到了一些瓶颈，虽然有写好的学习路线和执行计划，但总感觉仍然无从下手。而且现在开学了，还要上课和写作业，时间其实并不如寒假时充裕。</p>
<p>前几天做了一些算法题，但有一些写不顺手的感觉，去做大厂的笔试题发现其实自己仍然啥也不会，去看别人模拟面试发现他们聊的我大多都只接触的很浅，整理文件看到自己年前写的求职简历，越看越感觉这是一份拼凑出来的垃圾，一想到今年的实习就感到无比头大。</p>
<p>那就重新补补Vue吧，正好Vue也出了3.x的版本，也想正好学学一些版本新特性，慢慢来。</p>
<p>这篇笔记除了生命周期是2的版本，其他的笔记都是基于3的版本。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog-image/1619365291932.jpg"></p>
<a id="more"></a>

<h2 id="Vue-2-x的生命周期钩子函数"><a href="#Vue-2-x的生命周期钩子函数" class="headerlink" title="Vue 2.x的生命周期钩子函数"></a>Vue 2.x的生命周期钩子函数</h2><p>没啥可讲的，得把这图理解着背下来。</p>
<p><img src="https://cn.vuejs.org/images/lifecycle.png"></p>
<p>Vue实例的生命周期可以分为四个阶段：初始化阶段、模板编译阶段、挂载阶段、卸载阶段。</p>
<p>从<code>new Vue()</code>到<code>created</code>之间的阶段叫初始化阶段。从<code>created</code>到<code>beforeMount</code>之间的阶段叫模板编译阶段。从<code>beforeMount</code>到<code>mounted</code>之间是挂载阶段。应用调用<code>vm.$destroy</code>方法后，进入卸载阶段。</p>
<p><code>beforeCreate</code>：在实例生成之前自动执行，此时仅初始化了Events和Lifecycle，el和data还没有初始化，所以此时还不能访问methods，data，computed等里面的方法和数据。</p>
<p><code>created</code>：在实例生成之后自动执行。此时injection和reactivity已经初始化完成，此时data数据已经初始化，methods，computed，watch均开始运作，可以在这个钩子函数里对实例进行预处理，或者在这里发ajax请求。但这里不能对实例化过程进行拦截。</p>
<p><code>beforeMount</code>：在组件内容被渲染到页面之前自动执行。挂载开始之前此函数被调用，完成编译模板，生成html，完成el的初始化，但此时还没有把html渲染到页面里。</p>
<p><code>mounted</code>：在组件内容被渲染到页面之后自动执行。将上一步编译好的html渲染到页面里，此生命周期函数只执行一次，可以在这里执行一些ajax操作。</p>
<p><code>beforeUpdate</code>：当data中的数据发生变化时（ 即将变化之前）会自动执行的函数。此时虚拟DOM还没有更改，可以在这里进一步更改状态。</p>
<p><code>updated</code>：当data中的数据发生变化，同时页面完成更新后，会自动执行的函数。调用此方法时组件DOM已经更新，可以执行依赖于DOM的操作，但应该及你两少使用此函数，它可能会导致更新无限循环。</p>
<p><code>beforeDestroy</code>：Vue应用失效之前自动执行，此时还可以使用this获取实例，这里一般做一些重置的操作，比如清除定时器。</p>
<p><code>destroyed</code>：Vue应用失效时，且DOM完全销毁后自动执行。此时什么都没有了。</p>
<h2 id="一些细节笔记"><a href="#一些细节笔记" class="headerlink" title="一些细节笔记"></a>一些细节笔记</h2><ul>
<li>动态属性：</li>
</ul>
<p>属性名可以使用变量表示，加一个中括号。比如下面这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:name</span>=<span class="string">&quot;nameData&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的name我不确定用什么名字，或者以后要修改，那么就可以在data里面写一个数据字段用于方便修改，这里就加一个中括号括起来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">template: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div :[name]=&quot;nameData&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>其实事件也可以使用动态属性，比如<code>@[event]</code>。</p>
<ul>
<li>区别使用<code>v-show</code>与<code>v-if</code>：</li>
</ul>
<p><code>v-if</code>控制节点的展示与否是直接修改DOM，判断为<code>true</code>时会显示，但<code>false</code>时会直接移除此节点。如果使用<code>v-show</code>，则在<code>true</code>时会显示，<code>false</code>时会使用CSS中的<code>display: none</code>进行隐藏，但DOM结构还在。</p>
<p>在一些需要频繁修改显示情况的位置使用v-show，因为它不会频繁修改DOM，性能会好一些，但如果不涉及频繁的修改显示情况时，两者性能差不多。</p>
<ul>
<li>为什么要在<code>v-for</code>时加<code>:key</code>：</li>
</ul>
<p>当尝试在<code>v-for</code>展示的列表里面修改一些数据时，会重新对页面做渲染，但其实很多时候用不到大批量修改时，对整个列表的DOM进行重新渲染有些浪费性能。因为有大量的数据在这次操作中没有做出变化，但是DOM却被翻新了一次，这样是浪费性能的。所以在循环时一般会使用一个不重复的数据元素作为key值，写在<code>:key</code>里，在数据更新时，如果Vue发现key值没怎么发生变化，则不会重新渲染这个DOM以提升性能。所以合理的加<code>:key</code>能有效地提升性能。</p>
<ul>
<li>为什么<code>v-for</code>和<code>v-if</code>不能写在同一个标签里：</li>
</ul>
<p>因为<code>v-for</code>的优先级比<code>v-if</code>的优先级高，所以将两者写在一起时<code>v-if</code>不会生效，需要将<code>v-if</code>放在<code>v-for</code>的DOM子节点中。</p>
<ul>
<li><code>&lt;template&gt;</code>标签：</li>
</ul>
<p><code>&lt;template&gt;</code>在Vue中不可见，并且只能有一个根节点。</p>
<ul>
<li><code>event</code>与<code>$event</code></li>
</ul>
<p>在绑定事件中，如果调用的方法无参，那么在实现方法时可以额外添加一个<code>event</code>参数，就可以接收到事件，但如果方法带参，<code>event</code>就失效了。如果想要传参的同时再传一个<code>event</code>，需要在绑定事件中传一个<code>$event</code>，然后接收时仍然写<code>event</code>就可以接收到。</p>
<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>IE事件流被称为事件冒泡，这是因为事件被定义为从最具体的元素（DOM树中最深的节点）开始触发，然后向上传播至它的各种上级元素。</p>
<p>还有一种捕获流，是从最外面的祖先一直传到最具体的元素的，和IE事件流正好反过来。</p>
<p>其实可以使用事件修饰符阻止事件冒泡。</p>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>事件修饰符：stop prevent capture self once passive</p>
<p>按键修饰符：enter tab delete backspace up down left right </p>
<p>鼠标修饰符：left right middle</p>
<p>精确修饰符：exact 比如需要只按某按键触发事件的，按组合键也可触发，使用exact限定只按此键可触发。</p>
<h2 id="父子组件传值相关"><a href="#父子组件传值相关" class="headerlink" title="父子组件传值相关"></a>父子组件传值相关</h2><p>单向数据流：子组件可以使用父组件传递来的数据，但是不能修改父组件传递来的数据。设计单向数据流的原因是非单向数据流会造成数据的强耦合不便于维护，使用单向数据流可以对父子组件之间的数据解耦，防止出现难以维护的bug。</p>
<p><code>Non-props</code>：父组件向子组件传递值，但子组件并不通过<code>props</code>接收此值。如果子组件是单个根节点，传递的值会变成显式的属性放在子组件的DOM里。如果子组件是多个根节点，希望non-props生效，可以使用<code>v-bind</code>绑定一个<code>$attrs</code>，就可以将传来的值放在某个节点里，如果传值有多个，<code>$attrs</code>也可以使用<code>.</code>限定接收哪些值。</p>
<p><code>update:modelValue</code>，使用双向绑定简化子传父：这块其实还是有点不理解的地方，把文档链接放这里吧：</p>
<p><a href="https://www.vue3js.cn/docs/zh/guide/migration/v-model.html#v-model-%E4%BF%AE%E9%A5%B0%E7%AC%A6">https://www.vue3js.cn/docs/zh/guide/migration/v-model.html#v-model-%E4%BF%AE%E9%A5%B0%E7%AC%A6</a></p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>《规律与逻辑·用户体验设计法则》 学习笔记7</title>
    <url>/2021/02/26/ui-note7/</url>
    <content><![CDATA[<p>书接上回，这次记录一下在界面设计中对于细节的把控应当怎么做。</p>
<p>该部分为书中第四章内容，视觉体验进阶后半部分。笔记摘自《规律与逻辑》。</p>
<p>该系列将暂时停更一段时间，接下来更新的内容将会与Vue，JavaScript等相关。</p>
<p><img src="https://i.loli.net/2021/03/04/a8QRNpFsv6lkmjK.jpg"></p>
<a id="more"></a>

<h2 id="界面设计中的层次感表现"><a href="#界面设计中的层次感表现" class="headerlink" title="界面设计中的层次感表现"></a>界面设计中的层次感表现</h2><p>层次感是在满足视觉合理性的基础上，把要强调或者突出的主体与画面中的其他元素进行区分。通过对比版面中的元素大小、远近和前后等多重关系进行梳理，并运用色彩加以区分，可以使元素和主体在画面中具有一定的主次关系，让人在观看时产生一定的视觉层次和心理变化。对设计师而言，可以通过技术手段对主体自身的层次感进行调整，使画面在传递的过程中具有更好的视觉效果和层次变化。</p>
<ul>
<li>文字的层级区分</li>
</ul>
<p>拉开文字层级的首选备选方法：</p>
<p>字号&gt;粗细&gt;色彩明度&gt;字体特效，越高优先级的越应优先使用，但越低优先级的效果越明显（并不一定是效果越好，好不好要看实际情况）<br>首级文字最好拉开对比，做一个字号粗细和间距的区分。排版要做到上重下轻，左重右轻。文字层次要做到大方向上统一，局部对比调和。</p>
<ul>
<li>元素的复杂程度</li>
</ul>
<p>一般界面的复杂度是和元素的重要程度挂钩的，比如主页可以做的尽量花里胡哨，但是二级页面基本都很简洁，不然还像主页那么丰富多彩就会显得很混乱。使用元素复杂程度体现层次感有两个要点，一个是图标的效果控制，另一个是插图的合理利用。</p>
<p>在同系列学习笔记5中我记录了关于图标的知识，图标在界面设计中把控层次感是很重要的，入口层级较高的图标建议带彩，使用面性图标或者线条比较粗的线性图标，工具类或列表等层级较低的就可以使用线条比较细的线性图标了。</p>
<p>插图是一种能提升产品情感与品质感的设计方式，但是插图并不适合在任何场景。层级较高的界面可以使用，层级较低的使用反而会显得多余。</p>
<ul>
<li>间距的合理性</li>
</ul>
<p>这里是亲密性原则的一种体现，也就是用户会认为相邻的元素是相关的，所以确实相关的元素是应当挨着近一些，确实不相关的元素应当挨着远一些。</p>
<p>分界线和留白的取舍应当看信息的重要性，重要度最弱的用留白，其次再用分界线。如果一个界面版块过多，可以用粗分界线处理。</p>
<p>如今的设计趋势更倾向于利用较多留白让界面版块更清晰透气，但这并不代表一个产品内所有的几面都需要这种大面积留白。一般来说一级界面可以使用较大的留白，清晰的布局让界面看起来轻松具有呼吸感，但二级三级页面再这样设计就有些过分追求形式了。用户点到二级三级页面大概率的目的是为了获取信息，所以在设计二级三级页面时的核心点在于同屏的信息承载力，但这也不代表二级三级页面得很拥挤，设计时也需要遵循基本规律。</p>
<ul>
<li>学会信息归类</li>
</ul>
<p>要把相同表意的信息归到一起，在视觉上把相关的东西集中在一个版块内，而不相关的东西要有明确的提示，否则会没有层次感。</p>
<p>“查看更多”按钮经常存在于各大网站中，这个按钮的奥妙相当多。这个按钮代表的含义大多是跳入二级页，一般这个按钮会跟随在当前板块的标题后面。这样做的原因是避免歧义，如果按照常规思路，把查看更多按钮放在这个版块的底部，会让用户感到迷惑，迷惑的点是这个查看更多到底是查看这个板块内的更多信息，还是查看更多其他版块？而把查看更多按钮放在标题后面，用户就能很清楚的意识到这是查看更多其他版块。造成这种现象的原因就是查看更多按钮放在底部失去了层次感，原本是标题等级的组件放在了内容等级，层次感就这样缺失了。</p>
<ul>
<li>色彩的合理把控</li>
</ul>
<p>在界面设计中，色彩的运用需要克制。每一种色彩的使用都得有其缘由和目的。对于色彩的把控，有三个问题需要注意。</p>
<p>第一个是相比于黑白灰，有彩色层级更高。很多设计师喜欢把导航条做的花里胡哨的，从视觉层级上压住整个界面，避免界面缺少重量感。因为有彩色层级更高，所以不重要的元素一定不能给它赋予有彩色。比如头像的边框，完全可以使用浅灰色阴影解决的问题，如果加入彩色边框，可能会造成视觉干扰。</p>
<p>第二个是有彩色元素一般意味着可以点击。彩色的文字在用户的心理预期中一般是认为可点击的，在一些多文字场合（比如微信公众号推文页）使用按钮时，可以使用有彩色文字链接作为按钮，这样避免了有色按钮带来的视觉重心倾斜，也能很好的提示用户这个按钮可以点击。但并不是说所有可点击元素都得弄成彩色，那样就会让界面看着很碎，比如信息列表，文字都是黑色的，但这样的组件用户一般都会认为标题可点击，所以不需要再为标题修改颜色了。</p>
<p>第三个是黑色不适用于长文本。过深的黑色对于大量文字来说阅读负担比较重，可以让文字更灰一些，阅读起来压力会小很多，只需要让用户能容易识别出文字来就可以了，但是标题，加粗等地方还是需要用深黑色表示，这样也可以营造一个视觉的层级差。</p>
<h2 id="界面设计中的选图规律"><a href="#界面设计中的选图规律" class="headerlink" title="界面设计中的选图规律"></a>界面设计中的选图规律</h2><p>设计用户界面时基本都避免不了使用图片，但选图是需要谨慎的。这里有以下要点需要记住。</p>
<ul>
<li>图片的比例选择</li>
</ul>
<p>图片比例有以下四种类型：</p>
<p>1:1长宽等比型。这种类型比较常见，可以让界面看起来更简洁，比如头像，方形logo，但如果界面中的图片需要通屏时，这样的图片就不适用了，因为手机屏幕的尺寸是高而窄的。</p>
<p>4:3小众型。这种比例接近长宽等比，在实际使用中用的很少，适用于一些图片为主的产品或用户群体比较年轻的产品。</p>
<p>16:9人体工程学型。人体工程学的研究表明，人的视野范围是一个长宽比例为16:9的长方形，因此显示器等产品的尺寸一般都是以此比例进行设计的。在实际应用中，Banner，视频播放窗口等位置可以使用这样的尺寸，这是迎合人体工程学的。</p>
<p>X:≤Y瀑布流型。这个公式的意思是在界面设计中宽度固定，高度根据图片内容自适应。这样的模式在以图片为主且内容比较复杂的产品中使用较多，一般这样的页面都会使用瀑布流布局，所以名字就是这么来的。</p>
<ul>
<li>选图的统一性。</li>
</ul>
<p>选图的统一性从三个方面入手：</p>
<p>比例统一。当确定一款产品的图片比例后，就要尽量将图片比例都规范化，也就是相同属性的版块图片比例都要保持统一。</p>
<p>视平线统一。如果相同图片的视平线不同，会使用户在浏览时视觉变得不流畅。这个需求在大部分产品中都是很难实现的，但是作为设计稿而言，应该把产品最好的一面展现出来。即使这个需求很难实现，设计师也要把最终视觉稿做到完美。（前端震怒）</p>
<p>格调统一。配图的格调能反应出产品的格调，尽量选取与产品相关的图片。</p>
<ul>
<li>选图的清晰度</li>
</ul>
<p>选图的清晰度注重两个问题：</p>
<p>注重图片质量。选图清晰、高质量是提升界面效果最简单的方式。（当然，实际当中也要注意图片大小，太大了也不合适，得压缩一下）</p>
<p>将图片转换为智能对象。使用PS处理图片时尽量将图片转换为智能对象，这样可以减少像素丢失。</p>
<ul>
<li>图片和主题的贴合性</li>
</ul>
<p>贴合性注重两个方面：</p>
<p>图片要与产品相关联。要格调内容均统一。</p>
<p>避免图片重复。图片重复会很大程度影响预览视觉效果。</p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>UI设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《规律与逻辑·用户体验设计法则》 学习笔记6</title>
    <url>/2021/02/25/ui-note6/</url>
    <content><![CDATA[<p>用户体验设计师的主要产出物是什么？从打开产品的引导页到数据为空状态的设计技巧，逐渐扩展到运营Banner设计，最后深入到界面层次感的打造以及不同风格产品的设计路线，全面解决用户体验设计实际工作中的各种难题。</p>
<p>我打算用两次笔记学完这里。该部分为书中第四章内容，视觉体验进阶前半部分。笔记摘自《规律与逻辑》。</p>
<p><img src="https://i.loli.net/2021/03/04/xbm9IsnTqGHe5J7.jpg"></p>
<a id="more"></a>

<h2 id="设计中的感性与理性"><a href="#设计中的感性与理性" class="headerlink" title="设计中的感性与理性"></a>设计中的感性与理性</h2><p>设计是感性与理性的结合体，只有两者完美融合，才能呈现出独特的美感。感性听从内心，理性服从大脑，理性让人逻辑，感性让人自然。</p>
<p>如果理性束缚意识自由，感性就要消除压力。对于设计而言，应当做到感性和理性的结合，既要懂得设计规律逻辑思维，也不能让思维受到局限，勇于大胆尝试。</p>
<h2 id="引导页设计"><a href="#引导页设计" class="headerlink" title="引导页设计"></a>引导页设计</h2><p>引导页是指导用户如何使用产品的页面，之所以会大量出现在移动端产品中，是因为受到传统PC软件时代的影响。PC时代的软件，用户往往不知道如何操作，所以对于软件而言必须配备一个完备的说明书，甚至需要进入专门的培训班进修才能掌握某种软件的使用。</p>
<p>不过移动互联网时代，这样的说明书似乎显得有些笨重了。软件的轻量也使得用户学习成本大大降低，并不需要以前那样再配备一个说明书了。于是人们使用引导页代替说明书，对用户进行软件使用介绍。</p>
<p>引导页分为产品介绍型、操作指引型和讲故事型。</p>
<ul>
<li>产品介绍型</li>
</ul>
<p>简单介绍产品，让用户有个大致的了解，体现产品的格调，多为图文共同展示形式。文字作为简要介绍，图片烘托氛围，下方最好提供一个阅读进度条，让用户了解当前介绍所处的位置。</p>
<ul>
<li>操作指引型</li>
</ul>
<p>这样的引导页除了会在首次打开产品时出现，还会在产品内首次打开某个界面时出现。这种引导方式会加深用户的印象，但在用户使用过程中，不经意间弹出的引导会打断用户操作，会引起用户反感。所以这样的引导页尽量不要出现在简单易理解的操作步骤中。</p>
<ul>
<li>讲故事型</li>
</ul>
<p>讲故事型引导页的主要目的是营造具有浓烈感情色彩的场景，增加用户对产品的关注，提升在用户心理认知中的情感。一般是设定一个与产品相关的场景进行介绍，使用形式也是图文共同展示较多。</p>
<p>引导页设计规律：</p>
<ul>
<li>控制文字量并有效传达信息：人类对于文案在短时间内能记忆住的字符不超过9个。</li>
<li>改变常规的交互方式：可以使用更创新的形式吸引用户关注，比如使用弹窗。</li>
<li>信息聚焦：引导页中不应该出现过多的视觉焦点，容易分散用户注意力。</li>
</ul>
<h2 id="空状态设计"><a href="#空状态设计" class="headerlink" title="空状态设计"></a>空状态设计</h2><p>（老师！这个问题我会！让我来！）</p>
<p>某列表或某区域的信息为空，没有任何可以展示的东西，或者说获取数据出错，断网，程序异常等情况，都可以认为是空状态适用的场合。</p>
<p>空状态对于提升用户体验的重要性是极其高的。我在《前端工程简史》那篇笔记中写到AJAX技术改变了前端， AJAX技术进行的异步加载表现到页面上就是信息的更新，那如果更新出来是空或者调用接口时爆500了呢？（error 500代表服务器内部错误，一般是后台程序bug了）。此时如果是一个全白的区域，给人的感觉就类似于“是不是正在加载？卡了？”，那自然用户就会感到迷惑，但此时不一定是卡了，而是确实没有什么可以展示的。使用空状态便可解决这样的问题。</p>
<p>空状态分为以下三类型：</p>
<ul>
<li>系统推荐型空状态</li>
</ul>
<p>适合在应用初次启动时使用，此时用户没有或很少在应用内执行任何操作，对于一些信息推荐相关的内容自然是“无米可炊”，那么可以设定一个推荐页面，让用户根据喜好选择一些内容，就解决了内容空的问题。</p>
<ul>
<li>操作指引型空状态</li>
</ul>
<p>这样的空状态适合以下逻辑：界面应该展示产生的内容→界面并没有展示产生的内容→空状态指引用户前往产生内容的页面。</p>
<p>举个例子，某书籍阅读类应用，用户刚注册账号时书单内没有任何书，此时访问书单页面时，空状态提示用户书单为空，可以前往找书页面发现自己喜欢的书籍，给出一个明显的按钮便于用户跳转。</p>
<p>刚才的例子，使用推荐型空状态一样适合，但同样需要给出跳转找书页面的链接，否则用户体验会不太好。</p>
<ul>
<li>情感表达型空状态</li>
</ul>
<p>这是一种“实话实说”型空状态，适用于用户操作的结果页面。比如用户搜索某关键词却什么都没搜到，此时并不怎么需要多余的跳转（毕竟当用户没搜到东西时，常见的操作要么是返回上一页，要么是换个关键词继续搜），此时只需要放一张有趣的图片，可以配上一些幽默的文案，提示用户没有结果，就足够了。</p>
<p>设计空状态应该避免死角，每个有可能为空的状态都应当考虑一下（是考虑一下，不是都需要，下面会说），在用户使用一个产品并完成他之前从未完成过的功能时，不能让用户“走进死胡同”。</p>
<p>但并不是每个空状态都需要设计，也不是每个空状态都需要来个配图进行精心设计。当同屏只有一个版块时，使用带图空状态是合适的，但如果同屏有多个版块，每个版块的空状态都带个图就显得有点占地方了，这时候空状态只给一句话就可以。如果是多版块页面，某版块信息为空时也可以直接设定其折叠显示或者不显示，这样其实也是空状态的一种体现。</p>
<h2 id="Banner设计"><a href="#Banner设计" class="headerlink" title="Banner设计"></a>Banner设计</h2><p>Banner可以作为网站界面的横幅广告，也可以作为活动用的旗帜，还可以作为报纸、杂志上的大标题。对于移动端设计，Banner可以理解为最高视觉层级的功能或活动入口，因为Banner在设计时通常都会花里胡哨的，视觉层级相当高。</p>
<p>Banner的尺寸并没有固定的规范，形状也没有规范，圆角矩形，弧形都是可以的。我在工程实践中常用到的PC端Banner尺寸有<code>1920*700px</code>和<code>1200*400px</code>，手机端可以等比缩放一下或者根据实际情况调整。</p>
<p>Banner的组成五要素：文案、素材商品或模特、背景渐变、纹理叠加、点缀图形。</p>
<p>Banner的设计要点：</p>
<ul>
<li>文案注意排列规则，一行文字不能超过9个字。</li>
<li>设计背景渐变让视觉添加纵深感，用色应当符合产品特性。（色彩选取参考请参照我的同系列学习笔记3）</li>
<li>合理使用纹理叠加衬托主体，但避免过度使用喧宾夺主。</li>
<li>实物点缀，人物点缀，图形点缀对设计Banner尤为必要，这三者至少应当出现一个。</li>
<li>注意控制版面色彩与版式平衡。</li>
</ul>
<p>据书上说，带着这几个要点去网上找找比较成熟的banner图，会发现万变不离其宗。</p>
<p>Banner的组成形式分为纯文案型和文案素材结合型。</p>
<p>纯文案的Banner一般出现在电商以外的产品中，这种Banner不需要图的原因或者结果就是重点突出文案，所以设计这样的Banner必须在字体上下功夫（字体规律请参考我的同系列学习笔记5）。这样的Banner需要元素和图形来烘托气氛，绘制或选取素材时应当尽量贴合Banner的主题。</p>
<p>文案与素材结合型的Banner在电商类或音乐类产品中应用较多，电商类Banner推广销售产品，音乐类Banner推广音乐专辑。设计这样的Banner需要注意权衡文案和素材的视觉层级关系，同时两者尽可能统一风格，营造产品应当表达的氛围。</p>
<p>Banner的设计风格有以下六种：</p>
<ul>
<li>素雅文艺型：大面积留白，字体多宋体，字号差距大，饱和度较低，明度拉高点，常见灰白色。</li>
<li>高冷时尚型：文案很简洁，黑体无衬线，色调就两种，素材大比例，摄影很细腻，点缀得小心。</li>
<li>传统中国风型：灰调用的多，书法中国色，文案多竖排，排版右到左，不要渐变感，传统元素加：印章、山水画、墨迹、扇面、剪纸、园林窗格、祥云、京剧元素、卷轴、锦鲤等。</li>
<li>青春活力型：排版随你意，饱和度拉高，互补加对比，标题别太细，背景多点缀，字体也随意。</li>
<li>节日促销型：就图一热闹，多用红黄紫，画面少留白，标题得夸张，字号放大些，视觉冲击强。</li>
<li>科技概念型：底色用暗色，光效配科技，不要大圆角，配色蓝紫黑，画面要硬朗，科技元素加：光线，金属，线条，光点，宇宙，地球，人脑等。</li>
</ul>
<p>Banner在设计中需要注意的问题：</p>
<ul>
<li>主题要明确，构图要紧凑，整体性要强</li>
<li>左边的视觉重量更高，想突出什么元素就尽量把它放左边</li>
<li>巧用装饰元素，避免画面单调</li>
<li>纹理应当体现一定的质感</li>
<li>装饰性图案元素一般不让用户明显感知到，视觉上隐约可见即可</li>
<li>留白和点缀的多少应当根据风格确定</li>
</ul>
<p>装饰元素的分布方法：</p>
<ul>
<li>散点分布法</li>
<li>流星雨分布法</li>
<li>点状环绕分布法</li>
<li>放射发散分布法</li>
</ul>
<p>装饰元素的设计方法：</p>
<ul>
<li>渐变图形法</li>
<li>元素提取法</li>
<li>发散联想法</li>
</ul>
<h2 id="启动页设计"><a href="#启动页设计" class="headerlink" title="启动页设计"></a>启动页设计</h2><p>启动应用程序后，进入主功能界面之前一般会有一张图或一个动画，在程序进行加载时显示，加载完成后消失，这就是启动页。</p>
<p>启动页本身不是为了展示艺术品，而是解决用户会因为等待时间过长产生厌烦的问题。PC时代一般都是大型软件和网游才有启动页，移动端应用程序启动页应用变得非常广泛了。</p>
<p>启动页设计有以下四种形式：</p>
<ul>
<li>快速启动型启动页，尽量让用户不去感知界面的存在，无缝衔接到应用中。这样的形式有两种实现方法，第一种是把App首页背景图作为启动页，第二种是把首页加载状态作为启动页，但这样的设计具有局限性，仅适合轻量级应用，使用量较少。</li>
<li>品牌传递型启动页，这样的启动页是比较常见的，通常包括三个要素：产品图标，产品名称，宣传口号。部分启动页还会加入如开发者信息等其他信息，这样的启动页能加深用户的直观印象，拉近与用户的距离，强调品牌性格。</li>
<li>节日氛围型启动页：这样的启动页多以插画形式出现，一般会在节日或特殊纪念日时出现，时效性很强。当然也有一些直接用普通插画当启动页的，这样的启动页会很吸引用户的注意力，所以在设计插画时应当用心一些。</li>
<li>广告推广型启动页：恰饭启动页，无非就是弹广告了，这样的启动页在设计时和节日氛围型差不太多，细节之处其实在于没多少用户愿意看广告，所以最好给个倒计时提示或能点击跳过（恶心心做法：跳过按钮做成跳转按钮，参照几年前的某app）</li>
</ul>
<p>设计启动页的注意事项：</p>
<ul>
<li>避免过度设计，不能画的太花里胡哨，做到简洁耐看就足够了。</li>
<li>避免高频率改动，启动页往往可以代表产品的第一印象，频繁更换会造成心理感觉等待时间加长，如果像QQ，微信那样长时间不换的，用户甚至有时候回感受不到启动页的存在，这只是心理感受，并不代表实际时间一定变短了。</li>
</ul>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>UI设计</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中对数组的各种操作方法</title>
    <url>/2021/02/23/javascript-array/</url>
    <content><![CDATA[<p>数组是最简单的内存数据结构。JavaScript里也有数组类型，它可以储存一系列值。在JavaScript中，可以在数组中保存不同类型的值，尽管不建议这么做，但大多数语言都没有这个能力。</p>
<p>这里记载一下JavaScript中数组的一些常见用法，以及在ES6+中新增的方法。</p>
<p><img src="https://i.loli.net/2021/03/04/NDigGuxwbCSOfzU.jpg"></p>
<a id="more"></a>

<h2 id="数组的增删改查"><a href="#数组的增删改查" class="headerlink" title="数组的增删改查"></a>数组的增删改查</h2><p>增：声明、创建和初始化数组，使用<code>new</code>关键字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">233</span>);</span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>其实也可以直接使用一个中括号来声明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br></pre></td></tr></table></figure>

<p>增也可以理解为从数组中增加元素。分为在末尾插入，在开头插入，从中间任意位置插入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.push(); <span class="comment">// 从末尾插入</span></span><br><span class="line">arr.unshift(); <span class="comment">// 从开头插入</span></span><br><span class="line">arr.splice(<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 从索引3开始，插入值1, 2, 3（第二个参数是要删除的长度，这里不删除所以写0）</span></span><br></pre></td></tr></table></figure>

<p>删：从数组中删除元素。</p>
<p>删除分为从末尾删除，从开头删除，从中间任意位置删除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.pop(); <span class="comment">// 从末尾删除</span></span><br><span class="line">arr.shift(); <span class="comment">// 从开头删除</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 从索引2开始，连续删除包括此索引在内的后3个元素</span></span><br></pre></td></tr></table></figure>

<p>改：修改数组中元素的值。</p>
<p>可以直接通过下标访问数组的元素，并对其赋值，这里和其他传统语言是一样的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">2</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>查：搜索数组中的元素。</p>
<p>搜索有两个方法，<code>indexOf</code>方法返回与参数匹配的第一个元素的索引，<code>lastIndexOf</code>方法返回与参数匹配的最后一个元素的索引。</p>
<p>比如一个数组是<code>[2,3,3,3]</code>，使用第一个方法查找3返回1，使用第二个方法查找3返回3。</p>
<p>在ES6中，有了两个新的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.find(func); <span class="comment">// 接收一个回调函数，搜索第一个满足回调函数条件的值</span></span><br><span class="line">arr.findIndex(func); <span class="comment">// 接收一个回调函数，搜索第一个满足回调函数条件的索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数示例</span></span><br><span class="line"><span class="keyword">const</span> func = <span class="function">(<span class="params">ele, idx, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (ele % <span class="number">13</span> === <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有符合条件的值，<code>find</code>将返回<code>undefined</code>，<code>findIndexOf</code>将返回<code>-1</code>。</p>
<p>ES7中新增了<code>includes</code>方法，判断数组中是否存在某个元素，有返回true，没有返回false，很好理解。</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>JavaScript只支持一维数组，并没有矩阵，但是可以利用数组内能放任何类型数据的特性，让每个数据元素都是一个数组，就能做到二维数组的效果了。</p>
<p>输出二维数组时除了使用传统的二重循环，也可以使用<code>console.table()</code>获得更好的观感。</p>
<p><img src="https://s3.ax1x.com/2021/02/23/yqjkTg.png"></p>
<h2 id="JavaScript数组特色方法"><a href="#JavaScript数组特色方法" class="headerlink" title="JavaScript数组特色方法"></a>JavaScript数组特色方法</h2><p>在JavaScript里，数组是经过改进的对象，这意味着创建的每个数组都有一些可用的方法。</p>
<ul>
<li><p>数组合并</p>
<p>适用于多个数组合并成一个数组，使用<code>concat</code>方法。此方法向一个数组中传递数组，对象或者元素，此方法将按照给定的顺序连接所有元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.concat(brr, crr, drr, err);</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器函数</p>
<p>迭代数组中的元素可以使用循环语句，也可以使用内置的迭代器。</p>
<p><code>every</code>方法接受一个函数，从头开始尝试迭代数组中的每个元素，直到有一个返回false。</p>
<p><code>some</code>方法与<code>every</code>方法相反，会迭代数组的每个元素，直到有一个返回true。</p>
<p><code>forEach</code>方法无论返回什么，都会把整个数组迭代完，可以理解为for循环的另一种表现形式。</p>
<p><code>map</code>方法和<code>filter</code>方法是两个能够返回新数组的迭代方法，依然是传入一个函数，<code>map</code>方法返回一个只含有true或false的数组，长度与原数组一致，代表每个元素经过函数操作后的返回值，而<code>filter</code>函数返回的数组是原来数组的子集，代表通过函数操作后返回true的值。</p>
<p><code>reduce</code>方法接收一个有以下四个参数的函数：<code>previousValue</code>，<code>currentValue</code>，<code>index</code>，<code>array</code>，后两个参数是可选的。这个函数会返回一个将被叠加到累加器的值，方法停止执行后会返回这个累加器。如果要对一个数组中所有元素求和，这个就比较有用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.every(func);</span><br><span class="line">arr.some(func);</span><br><span class="line">arr.forEach(func);</span><br><span class="line"><span class="keyword">let</span> brr = arr.map(func);</span><br><span class="line"><span class="keyword">let</span> crr = arr.filter(func);</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">previoius, current</span>) =&gt;</span> previous + current);</span><br></pre></td></tr></table></figure>
</li>
<li><p>for…of</p>
<p>这个做项目经常用了，直接用数组中的元素作为迭代中的i。</p>
</li>
<li><p>@@iterator对象</p>
<p>通过<code>Symbol.iterator</code>访问，大概是这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value;</span><br></pre></td></tr></table></figure>

<p>不断地调用下面的next方法，就可以依次得到数组的值。数组迭代结束之后next方法就返回<code>undefined</code>。</p>
</li>
<li><p>获取迭代器</p>
<p>数组的<code>entries</code>方法返回包含键值对的<code>@@iterator</code>，使用next方法得到元素之后可以调用<code>key</code>属性获取位置（下标），<code>value</code>属性获取值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> test = arr.entries();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> test) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>键值对在构造数据结构的时候是很有用的。</p>
<p>数组的<code>keys</code>方法返回包含数组索引的<code>@@iterator</code>，<code>values</code>方法返回的<code>@@iterator</code>包含数组的值。它们返回的属性名都是value，同时还附带一个done属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> testk = arr.keys();</span><br><span class="line"><span class="keyword">const</span> testv = arr.values();</span><br><span class="line"><span class="built_in">console</span>.log(testk.next(), testv.next());</span><br></pre></td></tr></table></figure>

<p>一旦没有可迭代的值，value会变成<code>undefined</code>，done会变成<code>true</code>。</p>
</li>
</ul>
<p>以上所有方法为ES6+实现，如果浏览器不支持，需要上Babel。</p>
<ul>
<li><p>from方法</p>
<p><code>Array.from</code>方法根据已有的数组创建一个新数组，还可以传入一个用来过滤值的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arr);</span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="built_in">Array</span>.from(arr, filterFunc);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Array…of方法</p>
<p>根据传入的参数创建一个新数组，配合展开运算符<code>...</code>也可以起到复制数组的作用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">let</span> arrCopy = <span class="built_in">Array</span>.of(...arr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>fill方法</p>
<p>使用静态值填充数组，第一个参数必选，为填充内容，第二个第三个参数内容可选，为填充的开始位置和结束位置，如果不填某个参数则默认直接到头。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>(<span class="number">6</span>).fill(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>(<span class="number">6</span>).fill(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="built_in">Array</span>(<span class="number">6</span>).fill(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>j);</span><br></pre></td></tr></table></figure>
</li>
<li><p>copyWithin方法</p>
<p><code>copyWithin</code>方法复制数组中的一系列元素到同一数组指定的起始位置。</p>
<p>比如要把<code>[1, 2, 3, 4, 5, 6]</code>变成<code>[4, 5, 6, 4, 5, 6]</code>，就可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.copyWithin(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 第一个参数代表开始粘贴位置，第二个参数代表开始复制位置，第三个参数代表结束复制位置，第三个参数可选。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>排序方法</p>
<p>可以使用<code>reverse</code>方法对数组进行逆序。使用<code>sort</code>方法对数组进行从小到大的<strong>字符串字典序</strong>排序，这一定要注意，1后面会变成10而不是2，这看起来不太对劲，所以可以在<code>sort</code>方法内部传入一个比较函数，如果能保证里面都是数字的话，这样写是OK的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure>

<p>排序方法可以对多关键字数组进行自定义排序，构建一个自定义比较函数就OK。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [&#123;</span><br><span class="line">  name: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  age: <span class="number">10</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  name: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  name: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  age: <span class="number">15</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> comp = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.age &lt; b.age)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (a.age &gt; b.age)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.sort(comp));</span><br></pre></td></tr></table></figure>

<p>对字符串排序时，尽管按照字典序，但比较字符时也会按照ASCII值，如果不想受到大小写的影响，需要传入一个忽略大小写的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;Ana&#x27;</span>, <span class="string">&#x27;ana&#x27;</span>, <span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;John&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> func = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.toLowerCase() &lt; b.toLowerCase())</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (a.toLowerCase() &gt; b.toLowerCase())</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.sort(comp));</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出数组为字符串</p>
<p>把数组中所有元素输出为一个字符串，使用自带的<code>toString</code>方法即可，学习过Java的同学应该对这个方法并不陌生。</p>
<p>如果想要用分割符把元素隔开，可以使用<code>join</code>方法，后面参数带个字符作为连接符即可。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数组</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS选择器 学习笔记1</title>
    <url>/2021/02/22/css-selector-note1/</url>
    <content><![CDATA[<p>今天读了一本非常会整活的书：《CSS选择器世界》，这本书的封面写着“颠覆对CSS的认知”，我仅详细阅读到三分之一，就已经把我的认知颠覆的地覆天翻了。总结起来就是非常会整活，但也有很多值得学习的干货，这里把一些经典内容整理成笔记，时间关系最终没有读完，以后还会再来看这本书的。</p>
<p><img src="https://i.loli.net/2021/03/04/9zsB15xSNwO8rXq.jpg"></p>
<a id="more"></a>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>CSS选择器分为四类，选择器，选择符，伪类，伪元素。</p>
<ul>
<li>选择器：平常使用的CSS声明块前面的标签、类名等。</li>
<li>选择符：表示后代关系的空格（ ），表示父子关系的尖括号（&gt;），表示相邻兄弟关系的加号（+），表示兄弟关系的波浪线（~），表示列关系的双管道（||）。</li>
<li>伪类：通常与浏览器行为和用户行为相关联，可以看成CSS世界的JavaScript。</li>
<li>伪元素：伪元素是一个附加至选择器末的关键词，允许你对被选择元素的特定部分修改样式。</li>
</ul>
<p>CSS选择器只有一个全局作用域，以前出现过伪类<code>:scope</code>，用来匹配局部作用域，但现在被舍弃了。</p>
<p>CSS选择器具有命名空间namespace，让来自多个XML词汇表的元素的属性或样式之间没有冲突。但是使用命名空间解决冲突的方式都可以用其他选择器组合解决，所以也没啥大用。</p>
<p>无效CSS选择器特性几乎是IE独有的一个花活，假如你把一些有效选择器和一个无效选择器写在一起，那么这几个选择器都将一起无效。这个特性可以区分IE和其他浏览器（我？？？）</p>
<h2 id="CSS选择器优先级"><a href="#CSS选择器优先级" class="headerlink" title="CSS选择器优先级"></a>CSS选择器优先级</h2><p>CSS优先级有着不可逾越的等级制度（后面就bug打脸了），前四个等级由CSS选择器决定，后两个等级由书写形式和特定语法决定。</p>
<ul>
<li>0级：通配符，选择符，逻辑组合伪类</li>
<li>1级：标签选择器</li>
<li>2级：类选择器、属性选择器、伪类</li>
<li>3级：ID选择器</li>
<li>4级：style内嵌属性</li>
<li>5级：!important</li>
</ul>
<p>CSS优先级的计算规则是数值计数法，每个选择器都可以对应一个数值，选择器组合即数值相加，数值越高优先级越高。</p>
<p>规则：0级+0，1级+1，2级+10，3级+100。当两个选择器优先级相同时，按照后来者居上的原则，后出现的优先适用。</p>
<p>选择器的优先级不考虑DOM的位置。如果需要增加CSS优先级，可以增加嵌套，或者增加一个标签选择器，但是这样增加的代码的耦合度，有个小技巧是重复选择器自身，借助必然会存在的属性选择器也可以。</p>
<p>其实数值计数法不是很严谨，如果有10个1级标签选择器写在一起，按算法就和2级类选择器相同等级了，但实际上应该无论加多少都不应该越级，不过这个例子很不现实，毕竟应该不会有人写10个标签选择器嵌套的阴间CSS，所以数值计数法也是可以使用的。</p>
<p>在2015年之前，浏览器中有一个很奇怪的现象，根据等级制度，id选择器要比类选择器高一级，但如果把类选择器叠到256个以上，就会把等级突破…</p>
<p>（吐槽：这种bug到底是怎么找出来的…）</p>
<p>出现这种bug的原因是类名以8字节字符串存储，能容纳的最大值是255，所以当出现256个以上的类选择器时，内存会溢出到ID区域，不过现在采用16字节存储的字符串就不会出现这种现象了，能容纳足够多的类选择器（除非你真的闲着没事堆65536个类选择器。。）</p>
<h2 id="CSS选择器命名"><a href="#CSS选择器命名" class="headerlink" title="CSS选择器命名"></a>CSS选择器命名</h2><p>现在实际上已经没有严格意义上的对大小写敏感的选择器了，这个在后面章节有详细讨论。</p>
<p>最常见的错误是类名选择器和ID选择器以数字开头，但实际上可以通过转义字符来使其强行数字开头。比如不可以用数字<code>1</code>开头，但是可以用数字1的十六进制转码<code>\31</code>表示，但是这样表示需要在后面加空格与其他部分区分，如果不想加空格，可以表示成<code>\000031</code>，将高位的0补齐就可以了。</p>
<p>其实，首字符支持的字符集有大小写a到z，下划线，非ASCII字符（中文，全角字符等），双短横线，单短横线带其他合法字符，后面的字符支持的字符集有大小写a到z，0到9，下划线，短横线以及非ASCII字符。然而这个规则可以通过转义字符“escape”掉，对于非字符集中出现的字符，使用转义字符转化一下也是可以的。</p>
<p>这意味着你甚至可以使用emoji字符当做类名编写CSS，这样在别人查看你源代码时，能看到代码里出现了很多表情，这似乎也挺有趣的。</p>
<p>CSS选择器的命名是一个哲学问题。如果你开发的项目是小项目，独自开发，生存期短的，那可以完全放飞自我。CSS随便写名，中文，emoji，各种高级选择器都可以用起来，但多人协作可就万万不可这样了。有些自我良好的开发人员写的CSS代码其实质量堪忧，但他们自己根本意识不到这个问题。</p>
<p>建议使用短命名，语义问题可以不怎么关心。理论上推荐组合命名，但具体也应看实际开发情况有所取舍。建议项目中CSS样式添加一个统一的前缀，各个业务模块一定要采用多名称组合的命名方式。应当尽量避免命名冲突。面向属性的命名优点在于CSS重用率高，性能好，即插即用，方便快捷，但不足是适用场景有限，容易被过度使用增加维护成本。面向语义的命名优点是应用场景广泛，可以实现非常精致的布局效果，不足在于代码啰嗦，效率一般。如果是小项目建议使用面向语义，大项目两者一起使用。</p>
<p>不应当在命名中使用拼音，可以从HTML标签或者特定值中寻找灵感，也可以从CSS伪类和HTML布尔属性中寻找灵感。没有任何理由在实际项目中使用id选择器，尽量不要嵌套选择器，使用无嵌套的纯类名选择器，不要歧视面向属性的命名。</p>
<p>可以将一个网站的页面归为下面几块：公用结构，公用模块，UI组件，精致布局和一些细枝末节。除了细枝末节之外都不适合使用面向属性的类名，细枝末节比较适合。</p>
<p>应当正确使用状态类名，最佳实践方法就是使用<code>.active</code>，<code>.checked</code>等这样的状态类名进行交互。但是状态类名本身不能存在CSS样式，这样实现交互控制能有效降低日后的维护成本，可读性也增加了。</p>
<p>不建议使用驼峰类名，驼峰命名建议给JavaScript DOM用。组合命名的个数5个为极限，CSS基础样式使用类选择器，没有层级没有标签。</p>
<h2 id="CSS选择符"><a href="#CSS选择符" class="headerlink" title="CSS选择符"></a>CSS选择符</h2><p>当包含后代选择符的时候，整个选择器的优先级与祖先元素的DOM层级没有任何关系，这时要看落地元素的优先级，CSS选择器是独立于整个页面的。</p>
<p>使用子选择符的主要目的是为了避免冲突，通过限制关系使得结构更加稳固，但同时也失去了弹性和变化，需要审慎使用。</p>
<p>相邻兄弟选择符会忽略文本节点和注释节点，只认元素节点，可以配合伪类进行低成本实现交互效果。</p>
<p>相邻兄弟选择符的性能比随后兄弟选择符性能要高，但CSS如果不达到数量级讨论性能没有意义。</p>
<p>为什么没有前面兄弟选择符？因为浏览器解析HTML文档是从前往后，从外及里的，这个技术本身实现不难，但不做的原因是CSS和HTML本身的渲染机制决定了这东西大概率不会存在，现在是，以后也是。</p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>日常来点面试题2021.2.21</title>
    <url>/2021/02/21/daily-interview-question-2021-02-21/</url>
    <content><![CDATA[<p>今天看看CSS相关的内容。</p>
<p><img src="https://i.loli.net/2021/03/04/bvKAO6z2d5FCyxt.jpg"></p>
<a id="more"></a>

<p>问题：</p>
<ol>
<li>CSS有哪些基本选择器？它们的权重如何表示？</li>
<li>CSS的引入方式有哪些？link和@import的区别是什么？</li>
<li>浮动元素引起的问题与解决方法？</li>
<li>position的值分别相对于哪个位置定位？</li>
<li>CSS选择器都有哪些？</li>
<li>CSS哪些样式可以继承？哪些不可以？</li>
<li>什么是CSS Sprite？</li>
<li>如何居中一个div？</li>
<li>display的值与作用？</li>
<li>如何使用盒模型实现三栏布局？（左右200px，中间自适应）</li>
</ol>
<p>回答：</p>
<ol>
<li>基本选择器分三类，类选择器，id选择器，标签选择器。选择器的权重分为四个等级，可以用0.0.0.0表示这四个等级。!important关键字优先级最高，内联样式优先级可以看成1.0.0.0，id选择器可以看成0.1.0.0，类，属性，伪类选择器可以看成0.0.1.0，元素，伪元素选择器可以看成0.0.0.1，通配符没有优先级贡献。当选择器混合使用时，层级权重可以递增，比如同时使用id和类选择器可以写成0.1.1.0。</li>
<li>引入方式有三种，行内style属性，HTML内style标签，link引入外部css文件。@import方式只能加载CSS，link方式也可以加载如RSS等其他事务。link引用的CSS在页面加载时同步加载，使用@import加载的CSS需要等到网页完全载入后再加载，属于异步加载。link是XHTML标签，无兼容问题，@import是在CSS2.1中提出的，不支持低版本浏览器。link的标签是DOM元素，可以使用JavaScript控制，@import是一种方法，JavaScript不可控制。</li>
<li>父元素的高度无法被撑开，影响与父元素同级的元素，与元素同级的非浮动元素会被遮盖，如果一个元素浮动，则该元素之前的元素也需要浮动，否则会影响显示结构。解决办法是为父元素设定固定高度，父元素设置<code>overflow: hidden;</code>即可清楚浮动，让父元素高度被撑开，使用<code>clear: both;</code>也可以清除元素浮动。也可以使用通用类clearfix：<code>.clearfix:after&#123;content: &#39;&#39;; display: &#39;block; clear: both;&#125;</code></li>
<li>relative表示相对定位，相对于自己本身所在正常文档流中的位置进行定位，absolute表示绝对定位，相对于最近的根元素进行定位。fixed表示固定定位，相对于浏览器视口或frame进行定位。static为默认值，没有定位，出现在正常文档流中。sticky是粘性定位，用于做吸顶效果。</li>
<li>id选择器，类选择器，标签选择器，相邻选择器（+），子选择器（&gt;），级联选择器（ ），通配符选择器（*），属性选择器（[]），伪类选择器（:hover等），伪元素选择器（::before）</li>
<li>font-size，color等可以继承，border，padding，margin，width，height等不可以继承。</li>
<li>雪碧图，把网页中的一些图片整合到一张图片文件中，再利用<code>background-image</code>，<code>background-position</code>等CSS设置进行定位，显示出图片，这样可以减少网络请求量。</li>
<li>一般情况使用<code>margin: 0 auto</code>即可（块级元素），如果是行内元素，可以对父级元素使用<code>text-align: center</code>。</li>
<li>block为块级元素，none为不显示，inline为行内元素，inline-block为默认宽度为内容宽度，可以设置宽高同行显示，list-item是指像块类型元素一样显示，并添加样式列表标记。还有flex为flex布局。</li>
<li>核心点：设定三个float为left，左右盒子宽度200px，中间盒子宽度100%，其他css稍微写点美化一下就好了。</li>
</ol>
]]></content>
      <categories>
        <category>日常来点面试题</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>《规律与逻辑·用户体验设计法则》 学习笔记5</title>
    <url>/2021/02/21/ui-note5/</url>
    <content><![CDATA[<p>相比文字而言，图标可以让人在更短的时间内认知并了解信息，并且能大大提升视觉美观性；尽管界面设计中一般都选择系统默认字体，但一些运营活动风格的界面中，字体设计也是非常重要的方面；一个好的界面不仅要求整体布局合理，还要注意细节的处理。</p>
<p>该部分记录了在用户界面设计中的图标，字体与细节的规律。笔记摘自《规律与逻辑》。</p>
<p><img src="https://i.loli.net/2021/03/04/q2ryDbeiZ5w7KYX.jpg"></p>
<a id="more"></a>

<h2 id="用户界面中的图标"><a href="#用户界面中的图标" class="headerlink" title="用户界面中的图标"></a>用户界面中的图标</h2><p>使用图标比使用文本更具优势，因为图标简单，醒目且友好。但需要注意，如果图标使用不当会造成负面影响，比如在敏感位置使用识别度不高的图标可能会诱导用户误操作，同时图标放置位置不合适或风格不统一会带来很大的违和感。</p>
<h3 id="应用程序图标"><a href="#应用程序图标" class="headerlink" title="应用程序图标"></a>应用程序图标</h3><p>应用图标代表着用户对产品的第一印象。从某种程度上来说，用户可以通过应用图标判断出一款产品的好坏。应用图标设计形式多样，风格也多变。从最早图形化界面兴起时的像素风，到高分辨率屏幕问世后拟物化的登场，直到现在主流审美的扁平化，再到特殊设计的拟态风，对图标的改变就是：越来越抽象。拟物化图标通常是现实事物的反映，符合人们在现实生活中的认知，而到扁平化时代，图标内不再包含太多的信息，抽象元素占比越来越大。抽象元素看起来变简单了，但其实对设计提出了更高的要求。</p>
<p>抽象元素的优点就是可以让用户第一眼看到图标就知道这大概是什么东西（除非很抽象的那种），并且可以使得品牌具有独特性。抽象设计把控难度较大，如果非常抽象，则会降低识别度，无法很好地与其他元素区分开来。</p>
<p>在应用图标设计中，运用文字的优点就是可以让用户更容易记住产品，用户对汉字的敏感度其实远高于图形。但文字图标的缺点也是显而易见的，由于文字形状的固定，其品牌延展性将较差，在营造产品格调时文字图标的难度要比图形图标要大，且文字图标并不太适合用于小众产品。</p>
<p>采用产品吉祥物作为图标的方式也是比较流行的做法。很多品牌索性直接把吉祥物做成了图标，相比于图形和文字而言，这样的设计方式会更亲切一些，但在视觉上容易产生类似雷同的情况。</p>
<p>对于体量较小或功能单一的产品（比如系统自带软件，手电筒，计算器，指南针等），为了更加清晰传递产品属性，也可以直接使用物品本身的形状作为图标，强调其工具属性，这种方法并不适合对体量较大的产品使用。</p>
<p>在设计应用图标时，应当注意做到尽量简洁，因其显示尺寸较小（仅120px左右的正方形），在小尺寸下可能会因为显示不清晰而导致图像失真，这也意味着直接使用照片制作图标是大忌。设计风格独特，符合产品性格，色彩鲜活明亮则可以更加吸引用户。</p>
<h3 id="App内功能性图标"><a href="#App内功能性图标" class="headerlink" title="App内功能性图标"></a>App内功能性图标</h3><p>功能图标的样式有很多，作用也不相同。不同图标表达的意义不同，其样式、复杂程度以及大小也有所不同。功能图标可以让界面充满设计感，提高用户交互效率。</p>
<p>功能图标设计原则：</p>
<ul>
<li>预见性。功能图标存在的最大意义是提高用户获取信息的效率，要做到脱离文字也能了解含义，如果为了好看而失去了识别性就本末倒置了。设计师可以进行相关元素的联想，然后将它处理得尽量贴合表意。</li>
<li>美观性。在保证识别性的前提下应该尽量美观。要尽量做到美观，除了造型与配色的选择，细节处理上也同样重要。将不同样式的图标放在合适的位置才能达到美观的目的。这里需要特别注意在设计线性图标时不要使用反白的方式，因为线条无法压住大面积的色块，如果需要反白，请使用面性图标。</li>
<li>统一性。功能图标的数量往往较多，保证图标的统一性显得尤为重要。统一的图标可以提升产品的品质感，降低用户认知成本，提升使用效率。风格上的统一很好理解，视觉大小的统一是一个难点。人的视觉存在着误差，有时保证两个图标的统一时，在视觉观感上却不一定协调。在设计时如果出现视觉观感协调问题，则需要更换图标或者微调大小。粗细统一、端点统一和圆角统一是细节上需要注意的点。不仅是图标之间需要注意这三个统一，单个图标内的设计也要遵循这三个统一。但针对不同表意目的的目标，可以不用过多强调这三个统一。</li>
</ul>
<p>功能图标表现形式与适用场景：</p>
<ul>
<li>线性图标：提炼图形的轮廓勾勒而成的图标，线条描边多为1pt，描边越粗视觉层级越高，所以大部分线性图标视觉层级是较低的。多在同一产品内且功能入口较多的情况使用，主要功能入口很少使用。线性图标不能过于复杂，图标在界面中越小就要越简单。纯色线性图标适合大多数产品，多色线性图标更显活泼和年轻化，视觉层级高，需要谨慎使用。</li>
<li>面性图标：面性图标类似于使用颜色将图标的主要区域完全填充，显示面积较大，更容易吸引用户的视觉，一般常用于一些重要的快捷入口处。面性图标分形状图标和反白图标两种类型。反白图标是指图标底色使用彩色，图标本身全白，形状图标则是指没有图标底色，形状带有颜色。使用面性图标需要注意图形风格与设计语言的统一。</li>
<li>线面结合性图标：线性图标与面性图标的整合体，多了一些细节，视觉层级更高，常用在功能入口，空状态以及标签栏等位置。线面结合性图标突显年轻、文艺，对属性偏稳重的产品不太适用。</li>
</ul>
<h2 id="用户界面中的字体"><a href="#用户界面中的字体" class="headerlink" title="用户界面中的字体"></a>用户界面中的字体</h2><p>摘要中也有说，设计用户界面与设计艺术海报不同，绝大部分情况下使用的是系统默认字体。但对于字体的选择其实也是有说法的。</p>
<p>首先是衬线字体与无衬线字体。衬线字体的横竖笔画粗细不一致，且笔画开始和结束的位置都有额外修饰。在扁平化风格时代来临之前，衬线字体的笔画有粗有细，阅读体验比较好。但扁平化风格之后，一切装饰似乎都显得多余，目前衬线字体在应用中很少出现了，但一些需要塑造产品性格的标题当中仍然会使用衬线字体。</p>
<p>字体有字形结构，笔画和细节特征这三个构成要素。粗笔画的字体在视觉上其笔画的负空间较小，经常作为视觉中心并起到强调作用。粗笔画字体能形成一种压迫感，给人的感受为阳刚、沉重、严肃、坚硬。细笔画的字体负空间较大，结构疏朗清透，给人以纤细、优雅、放松、文艺、时尚的感觉。过粗的字体会造成用户视觉负担加重，引起不适；过细的字体识别度较差，不利于信息的传递。较高的字体显得瘦一些，相对偏女性化，给人以时尚优雅轻盈的感觉，较低的字体显得胖一些，给人以沉稳厚重的感受，易于产生信赖感。字体的视觉中心点越高，字体越轻盈，滑稽，有趣味；字体的视觉中心点越低，字形越笨拙，淳朴，可爱。字体结构越松散，留白越多，便可给人以轻松透气随性的感受，字体越紧凑，留白越少则给人紧张庄重有力度的感觉。</p>
<p>黑体是无衬线体的代表，特点：笔画简单，横竖均匀，手机界面容易识别，充满现代感。</p>
<p>宋体和楷体在以往的书籍排版与印刷中很常用，但现代设计力求简洁，所以这两种字体已经不再大规模使用，如果需要营造中国风氛围则可以使用。</p>
<p>圆体给人的感觉是亲和力十足，用于儿童类产品或女性类产品较多。</p>
<p>书法体风格突出，识别度相对差一些，基本上不用于大篇幅文本甚至文字较多的标题，多用于短标题。书法体可以营造中国风氛围，体现出刚劲和大气。</p>
<p>特殊字体指一系列使用倾斜，变形手法特殊处理过的字体，这类字体造型别致，容易引起人们关注。</p>
<p>在使用字体时应当注意分析判断字体性格是否和产品特性相符，不可盲目使用。</p>
<h2 id="用户界面中的细节规律"><a href="#用户界面中的细节规律" class="headerlink" title="用户界面中的细节规律"></a>用户界面中的细节规律</h2><p>一个好的界面不仅要求整体布局合理，还要求注意细节的处理。</p>
<p>圆角产生亲和力，尖角产生距离感。使用圆角元素可以让界面更加具有亲和力，但要注意相同的版式应当让圆角大小统一。</p>
<p>使用圆角让界面产生亲和力的同时也会缺乏稳重感，而尖角设计可以为产品制造稳重与权威的感觉，但尖角会让用户对产品产生一些距离感。</p>
<p>箭头在界面设计中几乎是不可或缺的元素，不同的箭头代表不同的意义。右箭头一般而言表示进入新的界面，也可以指引用户向右滑动屏幕。左箭头一般出现在界面的左上角，并且提示用户可以返回前一页。上下箭头在界面中一般表示展开与收起，当界面中信息过多需要隐藏，不想让用户直接看到全部内容时，可以使用上下箭头。同时上下箭头也含有赞同反对之意（参见知乎，最右这样的app）。圆圈箭头一般代表者刷新与同步，比如换一批内容，同步消息记录等。</p>
<p>界面投影应当尽量使用在大面积的信息卡片上，避免将投影的颜色直接设为黑色，建议吸取背景色作为投影的颜色，然后降低一些明度和纯度即可。一般情况下，用户界面中的投影强度都不会太明显，淡淡的投影可以让卡片富有层次感。</p>
<p>分界线在用户界面中起到的作用是分割信息版块。如果用点线面在形容界面的元素，文字是点，分界线是线，图片是面。当点过多，内容过于琐碎时，就需要使用分界线分割，但是图片太多时一般并不需要添加分割线，因为图片的边界本身就起到了分割的作用。提示性短线尽量出现在状态栏，它存在的意义是让用户了解自己现在所处的位置和状态。</p>
<p>左对齐是界面设计比较常用的对齐方式，对于一些字段长度不确定的列表，左对齐可以确定每一行开始的点，看起来更加整齐。居中对齐主要的作用是制造一种仪式感，比如新闻主标题和滚动歌词一般是居中显示的，但居中显示不适用于内容信息比较复杂且板块较多的界面。</p>
<p>在图文混排列表中，如果图片比文字高，文本不需要刻意地和图片的上下两边对齐，否则会看起来出现视觉断层，俗话说“上顶天，下顶地，中间留空气”，保留一些上下间距可以让文字更具有关联性。如果文字高度超过了图片高度，只需要保持文字纵向对齐就可以了。</p>
<p>当标题与内容需要在同一行中呈现时，如果标题字数固定，可以在固定范围内显示，并且尽量做到标题和内容各自对齐。标题后面紧跟内容会因为标题长度不同而导致信息展示比较混乱。</p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>UI设计</tag>
      </tags>
  </entry>
  <entry>
    <title>日常来点面试题2021.2.20</title>
    <url>/2021/02/20/daily-interview-question-2021-02-20/</url>
    <content><![CDATA[<p>抽出点时间看一些面试题，补充一些基础知识。今天看一些HTML相关的题目。</p>
<p><img src="https://i.loli.net/2021/03/04/BHNmX65c3Mk1dJ4.jpg"></p>
<a id="more"></a>

<p>问题：</p>
<ol>
<li>浏览器页面由哪三层构成，分别是什么，作用是什么？</li>
<li>HTML5的优缺点</li>
<li>对Web标准以及W3C的理解和认识</li>
<li>HTML与XHTML的区别</li>
<li>什么是静态和动态网页？</li>
<li>DOCTYPE的作用是？如何区分严格模式与混杂模式？区分它们有什么意义？</li>
<li>如何调试和查看网页源代码？</li>
<li>语义化的主要目的是什么？</li>
<li>锚点的作用？如何创建？</li>
<li>列举常用的结构标签并描述其作用</li>
</ol>
<p>回答：</p>
<ol>
<li><p>构成：结构层、表示层、行为层，分别对应HTML，CSS，JavaScript。HTML实现页面结构，CSS完成页面表现与风格，JavaScript实现客户端的逻辑功能业务。</p>
</li>
<li><p>优点：网络标准统一、多设备、跨平台、即时更新、提高可用性与用户体验、加入新的语义标签、给站点带来更多多媒体元素、对SEO友好、适用于移动应用程序和游戏。<br>缺点：安全问题，web storage、web socket这样的功能容易被黑客利用，盗取用户个人信息。完善性和兼容性，不同浏览器对HTML5支持程度不同，IE9以下几乎全军覆没。对开发者而言提高了技术门槛，HTML5性能在某些平台上较低。</p>
</li>
<li><p>标签要闭合，英文小写，不要嵌套混乱，用标签语义化提高搜索的概率，使用外链式的CSS，JS使结构、样式、行为分离，内容能被更广泛的设备访问，代码精简、开发组件化、代码易维护、可复用，改版省级方便。</p>
</li>
<li><p>HTML是一种基于Web页面的设计语言，XHTML是一种基于XML，语法严格，标准的设计语言。两者主要的不同是XHTML元素必须正确嵌套，元素必须关闭，标签必须小写，必须有根元素，HTML没有这些限制。</p>
</li>
<li><p>静态网页是指没有数据交互的网页，没有数据库参与，没有服务端数据加载，也可以理解为只有HTML+CSS+JavaScript做成的网站，这里的JavaScript只考虑一些简单的逻辑处理。动态网页是指有后台参与的网页，数据从数据库中提取，需要有后台逻辑支持。以前的动态网页有ASP，JSP，PHP等，现在有ajax技术之后，采用异步加载技术的页面也可以理解成动态网页。（有动画的网页不一定是动态网页，这里的动态指数据）</p>
</li>
<li><p>DOCTYPE声明位于文档中的最前面， 处于标签之前。 告知浏览器的解析器， 用什么文档类型规范来解析这个文档。严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。在混杂模式中， 页面以宽松的向后兼容的方式显示。 模拟老式浏览器的行为以防止站点无法工作。DOCTYPE 不存在或格式不正确会导致文档以混杂模式呈现。</p>
<p>严格模式就是浏览器根据Web标准去解析页面的方法，是一种严格要求的DTD，不允许使用任何表现层的语法，混杂模式是一种向后兼容的解析方法。触发严格模式需要在HTML标签前声明正确的DTD，触发混杂模式则在文档开始前不声明DTD，或者在DOCTYPE前加入XML声明。</p>
</li>
<li><p>在Windows系统下，按F12打开开发者调试工具，或者右键检查。查看网页源代码直接对页面右键点击选择。</p>
</li>
<li><p>用正确的标签做正确的事情。HTML语义化可以让页面内容结构化，便于浏览器解析和搜索引擎解析，并提高代码的可维护性和可重用性。比如少用无语义的div，多用有语义的header，section，footer等。</p>
</li>
<li><p>锚点是文档中某行的一个记号，类似书签，用于链接到文档中某个位置。当定义锚点后，可以创建跳到该锚点的链接。使用a元素创建锚点时指定name属性可以创建，对其他元素可以指定id为其命名。</p>
</li>
<li><p>结构标签专门用于标识页面的不同结构，相对于使用div元素而言，结构标签可以实现语义化。常用的比如header页眉，nav导航栏，section文档中一个具体组成，article独立于文档的其他部分内容，footer脚注，aside额外组成，如广告栏侧边栏和相关引用信息。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>日常来点面试题</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工程简史 学习笔记</title>
    <url>/2021/02/20/A-brief-history-of-front-end-engineering/</url>
    <content><![CDATA[<p>不好好了解一下过去，也便很难真正理解当今。</p>
<p>这次来学习《前端工程化 体系设计与实践》中的第一章：前端工程简史，将其中精华部分加以个人理解做一些摘抄整理。</p>
<p><img src="https://i.loli.net/2021/03/04/F9NvgZEnIXrdzu8.jpg"></p>
<a id="more"></a>

<p>前端工程出现的根本原因是前端工程师所负责的客户端功能逻辑在不断复杂化。现在的前端工程师已经不再做往年“切图仔”的工作，而是采用一种更加规范化、工程化的模式进行各种网站、应用、小程序的开发。想要弄明白前端工程化的来历，还得从web的老祖宗开始说起。</p>
<p><strong>什么是前端工程化？前端工程化是一系列工具和规范的组合，规范为蓝本，工具为实现。</strong></p>
<h2 id="前端工程发展历史"><a href="#前端工程发展历史" class="headerlink" title="前端工程发展历史"></a>前端工程发展历史</h2><p>1990年，Tim Berners Lee发明了世界上第一个网页浏览器WorldWideWeb。1995年，Brendan Eich用了10天时间完成了第一版网页脚本语言（后定名为JavaScript），这是网页应用开山鼻祖的年代，当时的网络条件与计算机硬件条件整体都是一个比较落后的状态，网页基本都是静态的，那时的脚本语言最初设想仅仅是完成一些简单的表单校验。</p>
<p>（吐槽：直到现在完成表单校验也是一个令人头大的工作）</p>
<p>对于那个时期的网页脚本语言来讲，它只需要做到功能简单、语法简洁、容易学习和部署就可以了。当时的Web应用完全以服务端为重，同时兼顾着客户端浏览器的开发，时代限定了那时并没有专门的前端工程师。</p>
<p>前端技术的第一次大变革源自2005年AJAX技术的问世。AJAX带来的异步请求和局部刷新彻底改变了网页的交互模式，同时此时网络速度的增长与个人计算机的普及给网站带来了更多的用户，用户对网站的需求也越来越多。此时便出现了第一批“最原始的”前端工程师，但他们的工作也仅限于处理用户交互和UI，此时相当多的前端工程师其实是做设计出身的，所以当时也会称他们为网页美工，“切图仔”的外号也是从这个时代来的。但受限于此时浏览器JavaScript引擎的性能，尽管有了AJAX，但受限于JavaScript引擎的性能，浏览器仍然无法处理大量的JavaScript逻辑，此时的功能逻辑仍然十分简单（十几行，几十行，几百行左右）。</p>
<p>AJAX技术起步于微软Outlook的XMLHTTP组件，微软将其作为ActiveX组件的一部分加入IE5。随后其他浏览器厂商实现了一个同样功能的JavaScript对象：XMLHttpRequest（微软你好惨），随后，W3C在2006年正式发布了XMLHttpRequest规范草案。自此，Web不仅是提供静态展示的网站，而且是一种由浏览器展现，资源寄存于Internet的应用程序。</p>
<p>时间推移到2008年，Google推出了高性能JavaScript引擎Google V8，采用JIT（实时编译）技术解释JavaScript代码，极大地提升了JavaScript的运行性能，使浏览器承载成千上万行JavaScript逻辑代码成为可能。引擎性能如同起飞的提升使得以前必须依靠服务器完成的功能可以转移到浏览器中，此时业内开始提倡REST（具象状态传输）风格的Web服务API与SPA单页应用风格的客户端。此时前端工程师不再仅仅承担交互与UI的工作，也要承担浏览器端逻辑的开发，工作职责进一步完善。</p>
<p>2009年，Node.js问世将JavaScript语言带到了服务端开发领域，但此时发布的第1版Node.js仅支持Linux和Mac OS X系统。目前（2021年）已经有很多公司使用Node.js应用到企业级产品中，尽管仍然无法撼动Java这种业界老大哥的地位，但Node.js对前端生态圈的促进是起到了巨大的推动作用的。Node.js带来的“大前端”模式已经在Web开发领域当中蔓延。Node.js实现异步操作的核心是Event Loop（事件驱动）。</p>
<p>在2011年，Node.js发布了Windows版本，在Web开发界进一步流行了起来。Node.js改变了人们对JavaScript的看法，即便是AJAX，也没能做到让JavaScript脱离浏览器生存，但Node.js做到了。Node.js证明了JavaScript能做的事情越来越多，而不仅是局限于在浏览器里写点交互逻辑。JavaScript学习浪潮的兴起也加速了ECMAScript规范的迭代。如果说AJAX为前端带来了第一次新生，那Node.js就为前端带来了第二次新生。</p>
<p>Node.js并非是一个JavaScript框架，而是一个可以使用JavaScript语言开发服务端应用的运行环境。同时，Node.js也是实现同构JavaScript开发的关键，这催生出了很多优秀的前端框架，比如React和Vue。</p>
<h2 id="前端工程师技能栈"><a href="#前端工程师技能栈" class="headerlink" title="前端工程师技能栈"></a>前端工程师技能栈</h2><p>从最初的重交互与UI，轻JavaScript的开发模式，到三者一把抓，再到“大前端”的客户端服务端通吃，前端工程师的工作内容与职责在不断拓宽。可以总结出前端工程师的技能栈：</p>
<ul>
<li>硬技能：HTML CSS JavaScript相关技术，这是前端工程师必须掌握的三项核心技能。数据结构、算法、软件工程等基础知识对前端工程师而言同样重要。</li>
<li>软技能：用户体验与性能。前端工程师的产出物直接面向用户，应当保证产品拥有良好的用户体验，还必须具备性能优化的意识和技能。</li>
<li>扩展技能：以Node.js为首的Web客户端相关知识本身。了解Web应用从前到后的工作流程和整体架构模型，有助于前端工程师编写更合理的客户端逻辑。</li>
</ul>
<p>总结起来，前端工程师是承载用户层所有功能的资源产出着，不仅是客户端最终呈现给用户的HTML/CSS/JavaScript等资源成品，而且还包括这些资源从零开始到最终产出的生产流水线所涵盖的所有环节。也就是，既包括成品，又包括过程。</p>
<h2 id="前后端分离与前端工程化"><a href="#前后端分离与前端工程化" class="headerlink" title="前后端分离与前端工程化"></a>前后端分离与前端工程化</h2><p>从传统网站到SPA再到同构JavaScript，前端工程师的工作已经不断加重，使用原始的前后端耦合串行开发流程已经不能满足现代Web产品的需要，于是前后端分离思想应运而生。</p>
<p>前后端分离的核心是解耦，通过合理的分工将前端工程师与后端工程师的职责区分独立开来，改善前后端协作中拖慢开发进度的环节，提高工作效率。</p>
<ul>
<li>从开发角度来讲，前后端分离的宗旨是实现并行开发，缩短开发周期。</li>
<li>从测试角度来讲，前后端分离令前端工程师和后端工程师更快捷、精准地对问题进行定位。</li>
<li>从部署角度来讲，前后端分离将静态文件和动态文件分离部署并结合回滚策略，简化了部署流程，增强了应用程序的健壮性。</li>
</ul>
<p>对于前端工程师来说，后端工程师唯一的产出就是数据。“大前端”负责的并不是真正的Web服务层，而是中间层，这也是“大前端”与“全栈”的根本区别，前端工程师仍然不需要接触数据库的CRUD操作。</p>
<p>在测试阶段，前后端分离能解决的是集成测试阶段的问题及时定位，通过明确责任承担角色。测试工程师等同于内测用户，他们反馈的问题就是用户反馈的问题。前端工程师负责所有与用户直接接触的功能和逻辑，自然是反馈过程的直接责任人。</p>
<p>前后端分离不仅仅是通过技术手段解决问题，技术和工具永远只是辅助手段，前后端分离的本质仍然是分工和角色的细分。前端工程化的最终目的之一就是实现更合理、更便利的前后端分离开发环境。前端工程化的主要目标是解放生产力、提高生产效率。具体的衡量准则为“快、准、稳”。工程化方案的核心目标之一就是在保证质量的前提下，尽可能提高产品的开发速度。工程化要解决的就是尽量减少低级的逻辑错误，降低集成测试阶段消耗的时间成本。</p>
<h2 id="前端工程化的进化历程"><a href="#前端工程化的进化历程" class="headerlink" title="前端工程化的进化历程"></a>前端工程化的进化历程</h2><ol>
<li>混沌形态：前端写demo，后端写逻辑，然后套模板。这种时候是前端开发刚刚兴起的时候，Web产品的交互逻辑比较简单。在混沌形态下，前端工程师产出的资源除了CSS外，都需要后端工程师进行二次处理才可以上线，甚至有时候连CSS都得二次处理，此时毫无前端工程化可言。</li>
<li>采用了AJAX的前后端分离形态：后端工程师负责前端逻辑开发的混沌形态被打破，改为前端逻辑、样式、和HTML交由前端工程师开发，这是催生前端工程化萌芽的关键一步。但此时仍然出现很多问题，比如开发阶段想要使用很多工具解决问题（ES规范不一致，CSS预编译器，图片压缩，资源定位等），有些JavaScript代码依赖数据接口交互但此时接口没开发完，静态文件仍然需要依靠后端工程师部署，这三个问题作为开发层面、协作层面、部署层面的三个典型问题代表在这个阶段存在着。所以人们在此基础上再次进行了多次优化。</li>
<li>加入构建流程的前后端分离形态：构建流程可以确保前端工程师使用有助于提高开发和维护效率的框架，规范进行源代码的编写，此时能够解决开发阶段需要工具的问题，只需要在借助工具的开发结束之后使用构建工具转换一下再交付后端就OK了。但协作层面和部署层面的问题依旧存在。</li>
<li>加入本地开发服务器的前后端分离形态：本地开发服务器本质上是一个Web服务，比如Mock服务，通过提供模拟接口和数据解决前端JavaScript对接口数据API依赖的问题，但这里需要前后端商定接口API文档的详细规范，不然会出问题。采用“假数据”的方式能够解决协作层面的问题，现在只剩下部署层面的问题了。</li>
<li>加入静态动态资源分离部署的前后端分离形态：优化部署的基本原则是，确保单方问题的修复不需要调动多方资源。假如上线的网站上某个图片需要更换或者出了bug，那理应只换掉出问题的图片即可，但现在讨论的前后端分离开发模式下需要前后端配合再次重新部署项目，这样的工作效率是非常低下的。通过将动态静态资源分别部署，就可以减少耦合工作，提高迭代与维护效率。这样如果是静态文件（不一定非得是图片，CSS也算，HTML有时候也算）出了问题，前端工程师只需要修改对应的静态文件即可，并不需要牵扯到动态资源的重新部署，方便了很多。</li>
</ol>
<p>此时的前后端分离模式并非完美的，前后端工程师的分工也并非最合理，理想模式等到以后再来学习吧。</p>
<h2 id="前端工程化的3个阶段"><a href="#前端工程化的3个阶段" class="headerlink" title="前端工程化的3个阶段"></a>前端工程化的3个阶段</h2><ol>
<li>本地工具链——工程化不等同于工具化。工程化的核心并非工具，其最终目的是为了提高研发效率以及保证Web产品的线上质量。工具的作用是将规范具化为功能并且在一定程度上将开发者限定在既有规范内。开发者使用统一的工具链，遵循统一的规范进行业务代码的编写，利于多人协作与程序的维护。</li>
<li>管理平台——进一步淡化差异，加深规范。本地工具链形态的工程化虽然解决了部分痛点问题，但所有模块都在本地工作，必然会受到环境差异性的影响，环境的差异性在一定程度上会影响构建产出代码的一致性。此外，本地工具链形态的权限不设限也带来了安全隐患，如果人人都能使用部署工具向生产环境部署文件，那是非常危险的，权限必须严格控制。使用集中管理的云平台便可以淡化环境差异性、权限集中管理、项目版本集中管理。</li>
<li>持续集成——前端工程化的目标是融入整体。即便是到达管理平台形态，前端工程化方案解决问题的本质仍然是前后端的工作解耦，尽管提高了双方的工作效率，但各自的工作流还是独立的，最后不可避免的要进行人工的融合工作。不论前端工程化的功能如何完备，规范如何严谨，需要谨记的是，前端工程化必然是整体Web工作流中间的一个子集方案。前端工程化最终的完美形态必然与整体工作流结合，作为持续集成方案中的一环。</li>
</ol>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ol>
<li>规范设计原则——用户至上。规范分两部分：工程化方案自身的配置API规范以及方案对代码编程范式的约束规范。编程规范的设计原则着重于代码的可移植性，减少对代码的捆绑性。</li>
<li>架构设计原则——扩展至上。除能够解决现阶段的功能需求以外，对隐含需求的支持度也是评估一套工程化方案的标准之一。在设计工程化方案架构时，应当秉持“内核轻量、扩展丰富”的原则。</li>
</ol>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>原来的文章都跑到哪里去了？</title>
    <url>/2021/02/12/why-they-gone/</url>
    <content><![CDATA[<p>这是一篇类似于更新说明相关的文章，简单说一下Shawn Zhou这多半年都干啥去了，以及为什么博客会变成了现在这个样子。</p>
<p><img src="https://s3.ax1x.com/2021/02/12/yDHDKI.jpg"></p>
<a id="more"></a>

<h2 id="我的博客发生了什么"><a href="#我的博客发生了什么" class="headerlink" title="我的博客发生了什么"></a>我的博客发生了什么</h2><p>由于一些意外情况，博客源文件丢了。重建过程很麻烦，而且我开学之后事情非常多，所以就没有管博客的事情。<br>年前年后这段时间里，把博客的各种东西重新整了一遍，将以前拆分发布的学习笔记合并了许多，删掉了一些很水的，没什么值得回顾的东西，简单收拾一下之后就变成了现在这个样子。</p>
<p>从入坑前端开发以来，重新审视一下自己的博客，以及用到的各种东西，突然有一种豁然贯通，茅塞顿开的感觉，以前看起来头大的东西，再看起来反而感觉如此熟悉。</p>
<p>接下来打算要重新把各种东西拾起来，好好的学点东西了。</p>
<p>顺带一提，图集还在继续更新，友链站和开发站仍然继续使用，资源站就撤掉了，资源站似乎意义不大。</p>
]]></content>
  </entry>
  <entry>
    <title>《规律与逻辑·用户体验设计法则》 学习笔记4</title>
    <url>/2020/07/04/ui-note4/</url>
    <content><![CDATA[<p>界面设计中的版式设计是视觉设计的核心，也是视觉设计的基础。界面板式作为颜色的框架支撑，在设计中必然占据核心地位。</p>
<p>该部分学习笔记为第一大块内容，版式。笔记摘自《规律与逻辑》。</p>
<p><img src="https://s1.ax1x.com/2020/07/04/NvqNlD.jpg"></p>
<a id="more"></a>

<p>界面设计操作顺序：</p>
<blockquote>
<p>内容呈现-&gt;应用场景与信息层次-&gt;版式设计-&gt;色彩与细节的处理</p>
</blockquote>
<h2 id="统一与变化"><a href="#统一与变化" class="headerlink" title="统一与变化"></a>统一与变化</h2><p>考虑到用户会长时间停留在某个界面，因此统一列表样式是有必要的。然而单一的列表也会让用户感到疲劳。可以通过版式设计让列表呈现不同的模块变化。</p>
<p>统一是主导，变化是从属。遵循统一规范的同时，再进行版式上的变化，会让界面看起来整体感更强，又不会让人产生烦闷的感觉。需要权衡视觉疲劳感和交互效率之间的平衡点，在设计时这个需要好好考虑。</p>
<p>界面图标的设计同样需要遵循这一设计原则，在设计成套的图标时，在统一配色、线条粗细和长短的前提下，外形上可以不受约束地进行美化。</p>
<h2 id="对比与调和"><a href="#对比与调和" class="headerlink" title="对比与调和"></a>对比与调和</h2><p>对比是为了强调差异化，让界面信息更有主次之分。调和是为了寻找共同点，调节界面的舒适感。</p>
<p>针对大小对比，大的方面有板块之间的面积对比，小的方面有字体之间的字号对比。字号可以代表层级，如主题字信息层级最大，简介文字信息层级次之，话题名称以及评论点赞等信息层级最小。适当的对比调和可以让信息清晰可见，又避免了过多无意义的对比使得界面信息杂乱。</p>
<h2 id="对称与平衡"><a href="#对称与平衡" class="headerlink" title="对称与平衡"></a>对称与平衡</h2><p>界面设计中的版式对称与平衡是一个统一体，常表现为既对称又平衡。从视觉上讲叫做寻求人心理上的稳定感。</p>
<p>说实话，我读这一块的时候，感觉什么是对称什么是平衡在主观上讲可能会差异很大，没有办法想到一个简单的评判标准，只能说是结合自己的审美来考虑，简单来讲就是有点玄学。</p>
<h2 id="节奏与韵律"><a href="#节奏与韵律" class="headerlink" title="节奏与韵律"></a>节奏与韵律</h2><p>最基本的要求：通过版式设计给予用户明确的阅读顺序引导，并且要做到有始有终。在这里，有始有终是一种态度，即使是单页面也要给用户明确的视觉起点和视觉终点，而针对长图或多版面的设计更应该如此。</p>
<p>用户的一般视觉浏览习惯为从左到右，从上到下，由题目到正文。无论是使用电脑端还是手机端，这个阅读顺序都不例外。在界面设计中，如果在标题、图片和栏目上都能有所变化，在视觉上就能形成跳跃式的点线面效果，这样用户在浏览的时候就会有一种节奏感。</p>
<p>对于以图片展示信息为主的页面，比如电商，用户一般通过标题判断不出是否需要此商品，更多的是基于对此商品图片的判断，所以根据视觉浏览习惯，建议将图片放在左侧，而描述信息放在右侧。目前的主流电商平台商品页都是这么做的。而对于新闻类页面，则不再是图片为主，而是标题为主，此时可以将图片放在右侧或者下方，将重点留给新闻的标题。</p>
<p>好的版式是界面的导游，优秀的设计不需要明显的一二三四来引导用户先看什么再看什么，其本身的设计效果就能决定用户的视觉走向。扩展一下上方的用户视觉浏览习惯，其实还有从有彩色到无彩色，从饱和度高到饱和度低，从大元素到小元素，从复杂元素到简单元素，从衬线字体到无衬线字体，从特殊字体到通常字体从留白较多到留白较少等等。同时，在白色背景下，颜色越深视觉层级越高，在黑色背景下，颜色越浅视觉层级越高。</p>
<h2 id="亲密性原则"><a href="#亲密性原则" class="headerlink" title="亲密性原则"></a>亲密性原则</h2><p>在同一个版面中，关联性较强的元素一定要相邻，关联性不是很强的元素一定要明显地隔开。一般情况下，相邻的两个事物大多存在着一定联系。在设计中，应该把有关联的内容放在一起，没有关联的信息明显隔开，界面中的信息就会让人感到清晰直观，并且识别度高。</p>
<p>比如图片和文字堆叠显示的列表，我们只需要将同一单元下的图片和文字设定小间距，不同单元之间设定大间距，这样不需要人为划分分割线，用户也能知道什么文字对应的什么图片。而如果文字和图片的间距完全一致，用户在向下滑动浏览时就会感到迷惑。</p>
<h2 id="相似性原则"><a href="#相似性原则" class="headerlink" title="相似性原则"></a>相似性原则</h2><p>如果一个版面的某几个元素在外形上是相似的，那么用户会认为这几个元素是有关联的。所以在界面设计中，给不同布局的元素相似的视觉特征，会激发用户对界面分组和联结的本能。相似的视觉特征主要表现在颜色，形状，大小，方向等元素上。</p>
<p>比如在设计计算器页面时，不应该把数字键和符号键设置为同种颜色，这样用户在使用时会加大误触概率。正确的做法是将数字键设置为一种颜色，符号键设置为另一种颜色，用户就可以很好地进行区分。</p>
<h2 id="卡片-分界线-无框"><a href="#卡片-分界线-无框" class="headerlink" title="卡片/分界线/无框"></a>卡片/分界线/无框</h2><p>目前界面设计常用的版式设计风格主要分为三种：卡片、分界线和无框。这三种风格各有各的应用场景。</p>
<p>卡片风格就是把界面中各版块的信息用卡片的形式承载起来，让界面直观清晰。非常适合用在一些列表页里。同时手机端的卡片由于与现实卡片大小相似，也可以让用户联想到现实中的卡片，所以也可以承载一些现实生活中的信息。卡片风格最适合的场景：单个界面需要获取较多信息时</p>
<p>分界线风格是最传统的分割方式，一般出现在各信息段落或板块之间，分界线的使用可以让界面更有规律。使用分界线风格的最大好处在于，达到了信息区分的目的，又不损失界面的整体性</p>
<p>无框风格是近年来兴起的一种极简设计风格。但无框风格设计难度较大，如果使用不当反而会导致界面信息杂乱。在包含图片较多的界面中可以采用无框风格，其实也是一种伪分界线风格，因为图片本身就可以起到分割线的作用，所以就没有必要再添加框线元素了。</p>
<h2 id="留白"><a href="#留白" class="headerlink" title="留白"></a>留白</h2><p>留白在设计中是不可或缺的元素。留白的真正意义是留出空间，并不一定非得要留出白色，也可以是其他颜色。只要是没有进行过度装饰的区域都可以称作留白区域。</p>
<p>需要注意留白需规范合适。信息卡片的上下左右间距最好相等，卡片内信息之间的距离也避免过近，不同的模块之间需要留出足够的间距，可以让界面看起来更加整洁透气，空间感更强。</p>
<p>利用留白还可以强调重点，制造信息的差异化，这也是界面设计中常用的一种技巧。减少多余的元素和颜色，多一些留白，可以将用户的视线快速引领到需要重点表达的信息上，大面积的留白可以突出重点信息，或者突出层次感。信息周围留白越多，便意味着该信息越容易成为视觉焦点。</p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>UI设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《规律与逻辑·用户体验设计法则》 学习笔记3</title>
    <url>/2020/07/04/ui-note3/</url>
    <content><![CDATA[<p>视觉设计能力是用户体验设计师的必备能力，也是基础能力。应当先了解基本原则，根据原则把版面做到整体看起来舒适， 再尝试突破理论原则进行创新。</p>
<p>该部分学习笔记为第一大块内容，颜色。笔记摘自《规律与逻辑》。</p>
<p><img src="https://s1.ax1x.com/2020/07/04/NvUtYD.jpg"></p>
<a id="more"></a>

<h2 id="用户界面设计中的色彩"><a href="#用户界面设计中的色彩" class="headerlink" title="用户界面设计中的色彩"></a>用户界面设计中的色彩</h2><h3 id="色彩理论基础"><a href="#色彩理论基础" class="headerlink" title="色彩理论基础"></a>色彩理论基础</h3><p>下面这个玩意叫色相环。</p>
<p><img src="https://s1.ax1x.com/2020/07/04/NvUO1J.md.jpg"></p>
<ul>
<li>三原色：光的三原色，包括红黄蓝。在实际使用中使用的以RGB（红，绿，蓝）居多，以此为基础可以调配出多种颜色。</li>
<li>间色：两种原色混合后得到的颜色， 比如黄+蓝=绿，蓝+红=紫，红+黄=橙</li>
<li>复色：两种间色或一种原色与其相对应的间色混合得到的颜色</li>
<li>互补色：色相环中呈180°角的两种颜色</li>
<li>同类色：色相环中呈45°向的两种颜色</li>
<li>对比色：色相环中呈120°-135°角的两种颜色</li>
<li>邻近色：色相环中呈90°向的两种颜色</li>
<li>冷色：色相环中偏向蓝，绿的色相</li>
<li>暖色：色相环中偏向红，橙的色相</li>
<li>无彩色：黑白灰</li>
<li>色相：色彩的主要特征，是区别不同色彩的标准，不同的色相是由射入人眼的光线的光谱成分决定的</li>
<li>纯度：色彩的鲜艳程度，色彩含有色成分的比例越大，则纯度越高。当颜色掺入无彩色时，纯度会发生变化</li>
<li>明度：色彩的亮度，针对同一种颜色，混入不同的黑色或白色后，会产生不同明暗的层次感。黄色明度最高，蓝紫色明度最低，红绿明度中等。纯度发生改变时，明度一般发生改变。</li>
</ul>
<h3 id="色彩在界面设计中的作用"><a href="#色彩在界面设计中的作用" class="headerlink" title="色彩在界面设计中的作用"></a>色彩在界面设计中的作用</h3><p>由于用户需要长时间浏览页面，所以每一种色彩都应该带有功能性，尽量避免为了丰富而添加不必要的色彩。比如彩色文字会让用户提升点击欲望，而灰色文字则可能会被认为不可点击。</p>
<ul>
<li>厘清整体架构，用户接触到一个产品界面时，看到的往往是由底色、几何色块、图标、按钮等元素构成的图形符号系统，清晰的色块分布可以让整个版面层次感更强，更容易让用户理解</li>
<li>明确视觉层级关系，不同的内容应该呈现出不同的层级关系。红色在视觉层级上最高，重要按钮和重要文字一般使用红色</li>
<li>突出产品风格，色彩的搭配可以反映出产品的风格和属性。比如电商类一般用橙红色，工具类一般用蓝绿色，内容类一般用净白色</li>
</ul>
<h3 id="色彩的对比"><a href="#色彩的对比" class="headerlink" title="色彩的对比"></a>色彩的对比</h3><ul>
<li>同类色对比<ul>
<li>优点：营造出和谐统一的界面效果</li>
<li>缺点：容易让界面显得太过稳重，让人觉得乏味</li>
<li>适用于品牌格调鲜明的场合，如网易云音乐，整个界面基本贯穿红色这一色相</li>
</ul>
</li>
<li>互补色对比<ul>
<li>优点：让画面更具张力，营造出视觉反差，吸引用户关注</li>
<li>缺点：较难把控，如果控制不当会让界面看起来非常俗气，或看起来刺眼</li>
<li>一般采用“大调和，小对比”的原则，将一种颜色大面积显示，另一种对比色局部点缀显示</li>
<li>可以采用明度差距较大的互补色，这样不会造成刺眼效果，比如黄色和紫色</li>
<li>比如简书app，主色为红色， 将一些按钮设置为绿色可以提升按钮视觉层级，提升点击欲望</li>
</ul>
</li>
<li>纯度对比<ul>
<li>优点：可以让页面分清主次，将重要的元素提升明度，会更容易被注意到</li>
<li>缺点：颜色纯度过高，尤其是多种高饱和度颜色同时出现时，会看起来不舒服，当然纯度也不宜太低，会让界面显得脏乱沉闷</li>
<li>实例：支付宝app的口碑页列表</li>
<li>纯度对比越弱，画面冲击力越弱，表现越含蓄，适合长时间近距离观看</li>
<li>纯度对比越强，画面冲击力越强，表现越明朗，表现效果更直观</li>
</ul>
</li>
<li>明度对比<ul>
<li>物体受不同明度背景的影响，可以产生不同的视觉感受</li>
<li>黑色和白色是最强的明度对比组合，黑色与深灰色，白色与浅灰色是较弱的对比组合</li>
<li>可以展现出色彩的层次感，空间感，立体感</li>
<li>对比合理可以让信息展现更直观，提升阅读效率</li>
<li>一般来说，明度越低的物体越靠后，明度越高的物体越靠前</li>
</ul>
</li>
<li>面积对比<ul>
<li>同面积红+绿不好看，大面积绿+小面积红好看，大面积红+小面积绿也好看</li>
<li>处理某种颜色太跳跃的问题：可以改变色相和纯度，但是也可以改变颜色所占面积，跳跃色占面积较小，柔和色占面积较大</li>
</ul>
</li>
<li>动静对比<ul>
<li>指的是花哨与纯净的对比</li>
<li>太过稳重的搭配容易造成视觉疲劳，太过动感的视觉搭配容易引起视觉不适，适当进行动静对比可以解决这一问题</li>
</ul>
</li>
</ul>
<h3 id="色彩的性格与重量"><a href="#色彩的性格与重量" class="headerlink" title="色彩的性格与重量"></a>色彩的性格与重量</h3><p>当然，以下结论只是常规认知上，也常有用于另外情景的情况。</p>
<ul>
<li><p>冷色会让用户产生正义、平静、安全、理智、高科技的感受</p>
</li>
<li><p>暖色会让用户产生积极、喜庆、食欲和亲近的感受。</p>
</li>
<li><p>白色象征纯洁、神圣、信任、安静，给人感觉平淡，视觉层级低，常用于内容类产品</p>
</li>
<li><p>蓝色象征着诚实、希望与科技，耐看，让人感到平静，长时间浏览不会产生浮躁心理。但是不适用于娱乐产品</p>
</li>
<li><p>红色象征着热情、性感、自信、充满能量。在音乐类，电商类等需要活跃气氛的app中可以使用，但是不适用于医疗类，安全类app</p>
</li>
<li><p>橙色与红色相近，但橙色更具有亲切感和活力感。可以增加食欲和消费欲望，所以在电商，食品类app使用较多，但是橙色浏览时间较长会让人烦躁。</p>
</li>
<li><p>黄色象征着青春、活力、创意和乐趣，特点是明度极高。一般在定位为年轻人的产品中使用，但是缺乏权威感和稳重感，并且较难把控。</p>
</li>
<li><p>绿色象征着安全、自由、新鲜、生命力，给人感觉温和，用于强调安全感并想要获取用户信任的场合。比如安全类，理财类app</p>
</li>
</ul>
<p>色彩的重量是人的一种心理感受，重量一般由明度决定，明度较高的颜色给人的感觉较轻，明度较低的颜色给人的感觉较重。明度由重到轻可以排列成黑红紫蓝绿黄白。同色系中明度越高重量越轻。</p>
<p>通过对色彩的把控可以让重量更为合理。比如较多图片的界面，导航栏可以使用浅色，避免深色过多导致产生视觉负担。针对文字较多的界面，导航栏可以使用深色，这样可以人为增加页面的重量感，避免在视觉上感觉太轻。</p>
<h3 id="不同色彩的应用场景"><a href="#不同色彩的应用场景" class="headerlink" title="不同色彩的应用场景"></a>不同色彩的应用场景</h3><ul>
<li>60+30+10色彩搭配原则：60%主色，30%辅助色，10%点缀色</li>
<li>有彩色一般应用在按钮、图标、提示性元素上</li>
<li>无彩色一般应用在字体、分界线、背景元素上</li>
<li>主题色是一款产品给用户留下第一印象的颜色，一般情况下主题色要占比60%以上</li>
<li>辅助色一般伴随着主题色出现，当界面中需要提示的内容不止一种时，就可以用辅助色加以区分</li>
<li>点缀色出现的场景有如下几种。1是需要区分的信息有两种或两种以上，2是界面中有信息需要被特别强调，3是界面内主题色与辅助色色系相同时平衡画面</li>
<li>体量较小或特殊属性的产品会使用单色，体量较大的产品3种颜色也远远满足不了要求，此时可以使用点缀色辅助显示，穿插使用颜色。</li>
</ul>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>UI设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《规律与逻辑·用户体验设计法则》 学习笔记2</title>
    <url>/2020/06/28/ui-note2/</url>
    <content><![CDATA[<p>不符合设计规范的设计很难被用户接受，也会极大地增加开发难度。界面设计严格按照规范来执行，是对用户体验设计师的基本要求。</p>
<p>该部分学习笔记摘自《规律与逻辑》。</p>
<p><img src="https://s1.ax1x.com/2020/06/28/NgVFx0.jpg"></p>
<a id="more"></a>

<h2 id="App基础布局规范"><a href="#App基础布局规范" class="headerlink" title="App基础布局规范"></a>App基础布局规范</h2><p>进行界面设计的第一步是了解市面上手机尺寸的规范和分辨率。但是市面上手机尺寸繁多，尺寸不尽相同。针对每一种机型都设计一套显示方案显然是不合理的，所以我们需要去了解不同手机屏幕之间的差距，还要找出之间的共性，同时应该学习布局中的理论规范。</p>
<h3 id="显示理论基础"><a href="#显示理论基础" class="headerlink" title="显示理论基础"></a>显示理论基础</h3><p>首先引入单位dpi，dpi是dots per<br>inch的缩写。原用于表示打印机每英寸（约2.54cm）能打印的墨点数。这个数值越高，打印出来的东西就越清晰，当dpi高到一定程度时，人眼将无法感受到墨点的存在，看到的图片就会越来越清楚。</p>
<p>然后引入单位ppi，ppi是pixels per<br>inch的缩写。表示每英寸可以容纳多少个像素点。类似打印机打印图像，屏幕显示图像使用的是许许多多的发光点。对于屏幕来说，ppi用于描述发光点的密度，也就是单位面积下发光点的数量。一般我们将屏幕上的一个发光点称作是一个像素。ppi可以认为是一个物理单位，因为一块屏幕在出厂时，其尺寸和像素点的数量就已经是确定的。</p>
<p>以iPhone8为例，其手机屏幕宽度约为5.8cm，高度约为10.4cm，屏幕大小为4.7英寸（可根据勾股定理计算得出），像素尺寸为1334px×750px，也就是说每行可以容纳750个发光点，每列可以容纳1334个发光点。其实，1334px×750px也是iPhone6，iPhone7的屏幕分辨率。根据苹果提供的参数信息，iPhone8的ppi值为326，也就是说，在iPhone8中，每英寸（对角面积）可以容纳326个像素点。</p>
<p>我们应该避免询问“一个像素是多大”这种问题，因为 <strong>像素点的大小通常是不确定的</strong><br>。虽然像素的显示要基于物理上的屏幕发光点，但是脱离了物理屏幕这个大前提，讨论像素就没有了大小可言。比如iPhone8<br>Plus，其屏幕像素尺寸为1920px×1080px，而常见的笔记本电脑屏幕像素尺寸也是1920px×1080px，iPhone8<br>Plus的屏幕再大也不会有笔记本屏幕的尺寸大，所以即使像素尺寸一样，其物理大小也是不一样的。</p>
<p>基于上述讨论，可以知道，如果在设计界面时， <strong>只关注屏幕尺寸通常是不合理的</strong><br>。而通过屏幕尺寸和像素尺寸计算出的ppi值才是真正需要关注的数据。ppi的计算公式如下：</p>
<p><img src="https://s1.ax1x.com/2020/06/28/NgnjAO.png"></p>
<p>其中，x为屏幕的长度像素数，y为屏幕的宽度像素数，z代表屏幕尺寸。以iPhone8为例，x=750px，y=1334px，z=4.7inch，代入公式可以计算出ppi约为325.61，四舍五入后得到ppi值为326，与上方讨论得到的数据一致。</p>
<p>同时根据ppi公式还可以反推出，在同样屏幕尺寸（即z不变）的情况下，一条同为长x像素的线条，在不同ppi值的显示下，显示展现出的长度并不相同。比如在iPhone8中，显示一条326px的线，由于iPhone8的ppi值为326，这条线的显示长度为1inch。假设将iPhone8的ppi值降低一半，到达163ppi，那么326px的线将显示为2inch。这是因为163ppi的屏幕每inch只有163像素，所以在显示326像素的内容时需要多花一倍的长度。</p>
<h3 id="逻辑大小与像素大小"><a href="#逻辑大小与像素大小" class="headerlink" title="逻辑大小与像素大小"></a>逻辑大小与像素大小</h3><p>这里暂且定义 <strong>逻辑大小为人对物体真实大小的认知</strong><br>。人的视觉对于对象尺寸的判断是根据逻辑大小来决定的，以一本书为例，无论这本书离我们有多远，在我们的认知中，书的大小“就是那么大”，不会因为我离着这本书很远而感觉这本书“实际变小了”，这是不符合现实的，我们只会感觉“看起来变小了”。我们所认知的大小，就是书本的实际大小，这个实际大小，就可以作为书本的逻辑大小。在以后的讨论中，<br><strong>凡是牵扯到逻辑大小，均指从人的认知上看起来的大小。</strong></p>
<p>物体真实尺寸不同，逻辑大小就不相同，给人的认知就会不一样，在眼中呈现的视觉大小也就不一样。像素大小相同，逻辑大小不一定相同。根据之前的讨论：</p>
<blockquote>
<p><strong>像素点的大小通常是不确定的</strong> 。虽然像素的显示要基于物理上的屏幕发光点，但是脱离了物理屏幕这个大前提，讨论像素就没有了大小可言。</p>
</blockquote>
<p>比如一个300×300的像素点阵，在大屏幕上和小屏幕上所使用的显像单元都是90000个，尽管他们的像素大小是一样的，但是能清楚地感受到两者显示的实际大小不一样，正是因为“1像素”的真实大小不同，造成了这个差距。<br><strong>屏幕像素数量不同，在图形有相同像素大小的情况下，图形的显示大小会不一样。</strong></p>
<p>可以举例，对于一个64×64的icon，在iPhone8 Plus上显示的大小就会比iPhone8要小，因为iPhone8<br>Plus的ppi要比iPhone8更大。那么如果我们假设这个情况更为极端，某个屏幕的分辨率是另一个屏幕的好几倍，那么显示差距悬殊将会更大。业界通用的解决方法是将高ppi屏幕下的显示放大某倍，就可以将不同ppi屏幕下的逻辑大小控制到基本一致。这就是为什么我们感觉大屏幕的手机比小屏幕的手机看着更清楚，因为一般都会将显示部件进行放大。</p>
<p>在引入了放大这个操作后，就有了逻辑像素与实际像素这两个不同的概念。</p>
<h3 id="逻辑像素与实际像素"><a href="#逻辑像素与实际像素" class="headerlink" title="逻辑像素与实际像素"></a>逻辑像素与实际像素</h3><p>试想一个问题：假如我们在为div绘制边框时，使用了<code>border: 1px solid black;</code>这样的CSS进行设置，那么显示预览时，我们可以看到一个黑色的边框，并且大脑会收到认知，这是一个1px的边框。但是，这个边框真的是1px吗？</p>
<p>实际上很多情况下并不是。在我们大脑中存在的1px是一个逻辑像素，根据上方逻辑大小的讨论，这个1px是我们看到的1px，它是逻辑大小。但是无论在iPhone8中显示，还是在iPhone8<br>Plus中显示，其占用的显像单元却并不是1px的显像单元，而应该是有好多px的显像单元。如果真的在手机上使用1px的显像单元显示1px，恐怕人眼很难看清楚。</p>
<p>从iPhone4S起，苹果采用了一种叫做Retina的技术。这种技术支持把更多的像素当成一个像素来使用，这样可以提高显示的细腻度。</p>
<blockquote>
<p>所谓“Retina”是一种显示标准，是把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度。由摩托罗拉公司研发。最初该技术是用于Moto<br>Aura上。这种分辨率在正常观看距离下足以使人肉眼无法分辨其中的单独像素。也被称为视网膜显示屏。</p>
</blockquote>
<p>在使用了Retina的iphone4S中，一个1×1的物理像素点可以容纳2×2个像素，所以在其上一代手机iPhone3GS中的显示方案放在iPhone4S中就会显示的非常小，因为实际大小会缩为原来的二分之一。解决方法其实很简单，将设计稿中的全部元素等比放大为原来的2倍，就可以完美兼容iPhone4S。</p>
<p>现在的手机都是向着分辨率越来越高的方向发展的，所以应该尽量优先保证高分辨率的屏幕显示效果。在设计贴图中常见到文件后缀有@2x，@3x等字样，其中不带此类字样的用于普通屏幕，带@2x的用于Retina屏幕，带@3x的用于iPhone<br>Plus系列机型。</p>
<p>规律：实际像素除以放大倍率，得到的是逻辑像素，若两个屏幕中的逻辑像素相同，其显示的实际大小也是相同的。</p>
<p>在iOS系统中，逻辑像素的单位是pt，普通像素的单位是px，在Android系统中，逻辑像素的单位是dp，普通像素的单位是px。</p>
<p>有了逻辑像素可以用来做什么？在进行UI设计时，只需要按照逻辑像素大小进行设计即可，在生成素材时加入@2x，@3x，即可得到高分辨率机型采用的素材，不用再为某些类机型单独做设计。（当然，iPhone<br>X是一个很例外的机型，后面需要单独处理）</p>
<h3 id="利用理论知识进行机型适配"><a href="#利用理论知识进行机型适配" class="headerlink" title="利用理论知识进行机型适配"></a>利用理论知识进行机型适配</h3><p>Android机的尺寸比iPhone多得多，分辨率高低跨度很大，但是我们可以根据各种设备的ppi划分成几个区间，并为不同的区间设定不同的放大倍率，这就可以做到统一了标准。至于一些老掉牙的小屏幕机型，在做设计时如果没有特殊需要一般就不需要考虑了，毕竟这样的设备现在也没多少人在继续使用了。</p>
<p><img src="https://s1.ax1x.com/2020/06/28/NgtAht.md.jpg"></p>
<p>对于iPhone<br>X的适配，重点关注应该是在其头部刘海和底部标签栏与工具栏。这两部分被苹果官方定义为非安全区域，不可以在非安全区域显示任何有效信息。上方不安全区的高度为44pt，下方不安全区的高度为33pt。在适配顶部导航栏，顶部banner，底部按钮，开屏大图时需要特殊注意，这块内容属于经验之谈，不太好呈现在书面上，这里就不做记录了。</p>
<h2 id="界面布局中的栅格系统"><a href="#界面布局中的栅格系统" class="headerlink" title="界面布局中的栅格系统"></a>界面布局中的栅格系统</h2><p>在App界面设计中，栅格系统的应用不仅可以让界面看起来更美观，还可以提升程序开发的效率。给界面留出边距这一设计方式可以被视作最基础的栅格系统。</p>
<h3 id="8px原则"><a href="#8px原则" class="headerlink" title="8px原则"></a>8px原则</h3><p>读中感觉不明其意，读完感觉，妙啊！</p>
<p>8px原则有两个不同的版本，一种是印刷行业使用的硬栅格，即将元素都放到8px大小的栅格中，一种是App设计中使用的软栅格，即保证元素之间的距离为8px的整数倍数即可。整合起来说，8px原则就是在设计中所有元素的长宽和间距都可以被8px整除。当然这里的8px是基于@2x情况下讨论的，在@3x情况下就是12px，不放大的话就是4px。当然，这里的px理解为pt或者dp也是完全可以的。</p>
<p>8px的由来不是没有道理的，简而言之，如果采用其他比较小px的原则的话，在一些小分辨率屏幕下会导致分辨率的像素参数出现小数，这就会导致元素出现虚边。但是现在来看的话，8px原则适用的320×480作为1×的时代已经过去了，我们可以把这个原则推广一下：</p>
<p><strong>只要给界面中所有元素定义一个最小单位，一切元素的尺寸都是它的整数倍，就可以解决元素的适配问题。</strong></p>
<p>读完后脑中瞬间想到rem，妙啊！rem就是一个相对大小的单位，1rem默认为16px，在开发中以rem作为标准就可以让写出来的东西变得很整齐。</p>
<h2 id="常见的布局和适用场景"><a href="#常见的布局和适用场景" class="headerlink" title="常见的布局和适用场景"></a>常见的布局和适用场景</h2><ul>
<li>标签式布局<ul>
<li>也称网格式布局，用于承载重要的功能，各模块之间保持相对独立，一行不要超过五个。设计时注意保持风格和细节上的统一。</li>
<li>优点：各个入口清晰呈现，方便用户快速查找信息</li>
<li>缺点：扩展性较差</li>
<li>例子：支付宝主界面的各种功能选项</li>
</ul>
</li>
<li>列表式布局<ul>
<li>适用于较长的文字信息组合界面布局，不适合在信息层级过多且字段内容不确定情况下使用</li>
<li>优点：信息展示直观，节省界面空间，浏览效率高，字段长度不受限制，可以错行显示</li>
<li>缺点：单一的列表页容易让人产生视觉疲劳，需要穿插其他板式让页面看起来富有变化</li>
<li>例子：知乎问题推荐，b站视频页下方的相关视频推荐</li>
</ul>
</li>
<li>卡片式布局<ul>
<li>是在栅格系统上更进一步进行规范布局的方式，将整个界面切割为多个区域，方便设计迭代，视觉效果统一</li>
<li>优点：最能支持图文混排，适用于信息组合层级较多的情况</li>
<li>缺点：太费空间，用户可能需要大面积扫视才能获取到想要的信息。在不适合的场合强行使用卡片式布局会降低使用效率</li>
<li>例子：淘宝中“我的淘宝”页面</li>
</ul>
</li>
<li>瀑布流布局<ul>
<li>界面内卡片大小不一致，产生错落视觉效果的布局称为瀑布流布局</li>
<li>适用于图片为主信息的情况，一般是两列并行，偶见三列情况</li>
<li>适合电商和小视频等界面，不适合文字过多或强调产品稳重性的场合</li>
<li>优点：极大提升交互效率，制造丰富的视觉体验</li>
<li>缺点：过于依赖图片的质量，如果图片质量不高，产品的格调会受影响</li>
<li>例子：淘宝商品页，闲鱼商品页</li>
</ul>
</li>
<li>多面板布局<ul>
<li>适合在内容和分类都较多的情况下使用</li>
<li>侧边栏显示竖排列标签，内容页显示相关内容</li>
<li>优点：展示信息效率较高，操作效率较高，减少跳转，分类直观</li>
<li>缺点：分类很多的情况下，侧边栏较窄，不利于单手操作</li>
<li>例子：京东商城商品页</li>
</ul>
</li>
<li>手风琴布局<ul>
<li>常见于两级结构的页面中，用户可以点击展开折叠</li>
<li>优点：可承载较多信息，保持界面的间接性，减少页面跳转，减少点击次数</li>
<li>缺点：同时打开多个的情况下，分类标题不好找，界面布局容易被打乱</li>
<li>例子：QQ分组列表页</li>
</ul>
</li>
</ul>
<h2 id="App基础组件规范"><a href="#App基础组件规范" class="headerlink" title="App基础组件规范"></a>App基础组件规范</h2><ul>
<li>状态栏</li>
</ul>
<p>状态栏是显示手机信号，时间，电量等信息的区域，一般是白色和黑色两种方案，此处一般不特殊设计。在状态栏背景颜色不确定时，缺省设置为背景白色。</p>
<ul>
<li>导航栏</li>
</ul>
<p>位于状态栏的下方，一般显示当前界面的名称。Android系统的导航栏标题基于导航栏左边缘对齐，iOS系统的导航栏标题基于整体居中对齐。两者的相同之处在于左侧一般提供返回按钮，右侧为当前界面的功能按钮，按钮可以是文字可以是图形。iOS的导航栏高度一般为44pt（逻辑像素375×667pt），Android的导航栏高度一般为56dp（逻辑像素360×640dp）。</p>
<ul>
<li>标签栏</li>
</ul>
<p>位于界面的最下方，提供界面的切换，功能入口和界面导航等功能。作用是指示当前界面所处的位置和可以前往的方向。在视觉上着重解决“我在哪里”，所以需要清晰且高亮地标注当前界面所处的位置。标签可以是纯图，可以是纯文，可以是上图下文。iOS的标签栏高度一般为49pt（逻辑像素375×667pt），Android的导航栏高度一般为48dp（逻辑像素360×640dp）。Android系统中的标签栏也可以在上方显示（由于Android系统存在界面虚拟按键，现在全面屏的普及也使得这个规矩弱化了，放上放下都行）</p>
<ul>
<li>工具栏</li>
</ul>
<p>工具栏与标签栏显示位置相同，但同一界面中，工具栏与标签栏只能同时显示一条。一般作用是承载一些对当前界面做一些操作的按钮（区别于标签栏的导航），一行不可超过5个，当超过5个时，最后一个显示为“更多”样式。iOS的工具栏高度一般为44pt（逻辑像素375×667pt），Android的工具栏高度一般为48dp（逻辑像素360×640dp）。</p>
<h2 id="App字体规范"><a href="#App字体规范" class="headerlink" title="App字体规范"></a>App字体规范</h2><p>其实一般不怎么需要改字体的。</p>
<p>iOS11中系统默认中文字体为“苹方体”，英文和数字默认字体为“San<br>Francisco”。Android8.0系统默认字体为“思源黑体”，英文和数字默认字体为“Roboto”。</p>
<p>字号规范相比字体来讲比较灵活，可以为每个产品都定一个自己的字号规范。但是一定要规定一个最小字号（小于此字号则会影响识别性），同时字号必须是整数，相同表意字段的字号必须一致。比如一级，二级，三级标题，大规模正文文本信息，非重要提示信息，非必读型信息，图标提示信息，它们之间的字号必须有区别，但是必须要保持整体一致。</p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>UI设计</tag>
      </tags>
  </entry>
  <entry>
    <title>《规律与逻辑·用户体验设计法则》 学习笔记1</title>
    <url>/2020/06/27/ui-note1/</url>
    <content><![CDATA[<p>是时候找个时间学习一下新知识，沉淀一下在无尽的开发中根基摇摆不定的自己了。</p>
<p>该部分学习笔记摘自《规律与逻辑》。</p>
<p><img src="https://s1.ax1x.com/2020/06/27/NyWmKs.jpg"></p>
<a id="more"></a>

<h2 id="互联网产品中的用户体验"><a href="#互联网产品中的用户体验" class="headerlink" title="互联网产品中的用户体验"></a>互联网产品中的用户体验</h2><p>对于电子产品来说，用户体验主要体现在如下几个方面。</p>
<ul>
<li>易用性。<ul>
<li>尽量减少用户的学习成本</li>
<li>提高交互效率</li>
<li>用尽量少的交互流程解决用户的需求</li>
</ul>
</li>
<li>容错性。<ul>
<li>指用户在进行错误的操作之后，系统可以妥善地进行处理，并可以继续保持操作的流畅性</li>
<li>容错性是产品最基本的要求</li>
</ul>
</li>
<li>产品视觉。<ul>
<li>设计的本质是让信息能更加完美、更加直观且更加优雅地传递，只要达到了这个目的 ，其他的元素就都显得多余了</li>
<li>产品的视觉感受是复杂还是简洁</li>
<li>产品的色彩使用和搭配是否合适</li>
</ul>
</li>
<li>板式表现。<ul>
<li>板式的好坏不仅会影响用户体验，还会在很大程度上影响程序开发的效率。</li>
<li>板式越有规律和逻辑，开发效率就越高</li>
<li>板式越混乱越多样化，开发效率就越低</li>
<li>板式举例：卡片式（淘宝）、列表式（今日头条）、抽屉式（改版前的B站用户信息栏）、标签式（没找到实例。。。）、瀑布流（闲鱼）</li>
</ul>
</li>
<li>情感化体现。<ul>
<li>情感化设计可以拉近用户与产品的距离。经过情感化设计的产品是有活力的，主要体现在有趣的配图或文案上。</li>
<li>用户并不喜欢与冰冷的机器交流，而更喜欢有温度的事物。</li>
<li>有关产品的提示性文字如果让人感到太过冰冷，就会让用户在心理上对产品产生距离感。常见情景：错误操作、界面为空、二次确认。</li>
<li>当今有很多产品把情感寄托在卡通形象中，通过卡通形象，可以赋予产品生命力，让用户更容易记住产品的品牌。实例：京东卡通狗、斗鱼卡通鲨鱼、美团卡通袋鼠。</li>
</ul>
</li>
</ul>
<h2 id="用户体验设计与平面设计的区别"><a href="#用户体验设计与平面设计的区别" class="headerlink" title="用户体验设计与平面设计的区别"></a>用户体验设计与平面设计的区别</h2><p>平面设计师的设计作品一般用于在短时间内传达信息，比如设计一张海报，让用户在短时间内进行关注。对于用户体验设计师来说，如何让产品好看且适合长时间浏览，并且不会让用户感到疲劳，又能让产品通过信息层级的梳理和版式设计传达出重要的信息，使用户可以更清晰直观地进行交互，是用户设计师需要思考的内容。</p>
<p><strong>用户体验设计的核心是制造解决需求的工具。</strong></p>
<p>用户体验设计中更注重处理的方面：</p>
<ul>
<li>信息层级</li>
<li>像素对齐</li>
<li>界面设计规范</li>
<li>在视觉效果舒适情况下看到尽可能多的内容</li>
</ul>
<p>用户体验设计相比平面设计有四个大方面下的主要区别。</p>
<h3 id="内容响应式"><a href="#内容响应式" class="headerlink" title="内容响应式"></a>内容响应式</h3><p>用户界面设计中，内容的呈现具有很多不确定性。比如文字长度可能很短，可能很长，也可能没有文字。同时考虑到屏幕宽度有限，在版式设计中需要考虑边缘的容错处理。简单来说，<br><strong>平面设计中的板式较为固定，而用户界面设计中的板式较为灵活。</strong></p>
<h3 id="长时间停留"><a href="#长时间停留" class="headerlink" title="长时间停留"></a>长时间停留</h3><p>用户在使用业务类（比如淘宝）等App时，一般会长时间停留并花较多时间去选购商品。一般平均停留时间为7分钟以上。基于这一点考虑，在进行用户界面设计时，板式往往讲究<br><strong>规整和耐看</strong> 。而海报，产品包装，名片等设计只是为了短时间内进行信息的明确传达，其板式往往会比较夸张，或加入一些创新性元素。</p>
<h3 id="阅读效率"><a href="#阅读效率" class="headerlink" title="阅读效率"></a>阅读效率</h3><p>对于用户界面设计来讲，每一个界面的存在都是为了完善一个交互流程。比如在用户获取信息的界面，如果设计太过形式感（设计比较零散），就会降低用户的阅读效率。因此用户界面设计中的板式通常都是紧凑且易读性较高的。举例，图书的封面可以有大面积留白，但内容页却不建议这么做。</p>
<h3 id="层级多样化"><a href="#层级多样化" class="headerlink" title="层级多样化"></a>层级多样化</h3><p>一种韩品需要传递给用户的信息较多，信息层级也随之多样化。如果在同一个界面中，不同表意的信息板式层级相同，就容易加大用户误操作的概率。比如租房类App界面，由于用户想要了解的信息较多，因此界面层级设计也应设置较多，需要花较多的心思对信息进行整合与归类。</p>
<h2 id="用户体验只是主观感受"><a href="#用户体验只是主观感受" class="headerlink" title="用户体验只是主观感受"></a>用户体验只是主观感受</h2><blockquote>
<p>“如果当初我去问顾客他们想要什么，他们只会告诉我：一匹更快的马。”——美国福特公司建立者亨利·福特</p>
<p>“你不能只问顾客想要什么，然后想办法为他们做出来。等你做出来，他们已经另有所爱了。”——美国苹果公司联合创办人史蒂夫·乔布斯</p>
</blockquote>
<p>用户体验是需要设计师通过用户反馈的问题对产品不断进行优化才能提升的。互联网产品迭代速度非常快，主要目的是通过不断“试错”并接收用户的反馈对用户体验进行不断优化。如果没有做到这一点，设计师很多看似有心的设计实则会起到反作用。</p>
<h2 id="用户体验设计师的职责与价值"><a href="#用户体验设计师的职责与价值" class="headerlink" title="用户体验设计师的职责与价值"></a>用户体验设计师的职责与价值</h2><p>用户体验设计师的终极目标：</p>
<pre><code>1. 满足用户需求，产品流畅易用，即UCD（User Centered Design）的概念
2. 满足产品需求，产品数据的正向提升，即UGD（User Growth Design）的概念
3. 满足设计者自身的需要，产品有体验上的创新</code></pre>
<p>设计师在工作中扮演的角色就是如何让这三个目标无限趋于平衡。或者根据产品当时的环境确定侧重点。用户体验设计包含传统设计过程中的多个门类，比如交互设计师、用户界面设计师、视觉设计师、用户研究专员等。用户体验设计需要考虑用户界面设计、交互设计、情感打造、用户研究、运营视觉设计等等多方面内容。</p>
<p>香港理工大学教授John Heskett提出的用户体验设计师的价值发挥主要表现在以下3个方面，这3个方面是循序渐进实现的：</p>
<ul>
<li>用户界面的修饰者，美化界面，这是最基础的价值</li>
<li>用户界面的区分者，打造产品不同的调性，让产品在同类产品中具有识别性。</li>
<li>用户界面的驱动者。设计师作为产品驱动者进行设计，能够在战略层有更多的表现，也是用户体验设计师获得价值感的关键所在。</li>
</ul>
<p>未来用户体验设计师的职责与价值所在： <strong>从数据中发现问题，然后利用交互和视觉方案去解决问题。</strong></p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>UI设计</tag>
      </tags>
  </entry>
  <entry>
    <title>WebPlus网站群平台往期bug整理+零碎知识</title>
    <url>/2020/05/29/webplus-bugfix/</url>
    <content><![CDATA[<p>整理一下最近在工作中遇到的一些问题和解决办法。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GWxQXV.jpg" alt="img"></p>
<a id="more"></a>

<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>下方示意图可以囊括大部分站群主页的结构。</p>
<p><img src="https://s1.ax1x.com/2020/05/29/tu60aj.jpg" alt="QQ图片20200515145643 (2)"></p>
<p>头图需要考虑加载速度，需要默认头图时请使用群文件的<code>qluheader.zip</code>，注意考虑加载速度，尽量不要使用200k以上的图片，如果需要请进行压缩。压缩图片的方式：</p>
<ol>
<li>PS 另存为jpg，选择画质时可以预览大小，但压缩很厉害时画质损失严重</li>
<li><a href="https://tinyjpg.com/">https://tinyjpg.com/</a> 上传的图片最大为5M，可以在画质损失基本看不出来的情况下压缩大小，压缩程度有限</li>
<li>把图片尺寸改小点，画图就行，重新调整大小</li>
</ol>
<p>全屏头图参考尺寸1920×700 留白头图参考尺寸1200×500，尺寸仅供参考并不固定</p>
<h2 id="主体调宽的做法与盒模型原理"><a href="#主体调宽的做法与盒模型原理" class="headerlink" title="主体调宽的做法与盒模型原理"></a>主体调宽的做法与盒模型原理</h2><p>遇到主体调宽需求时，实质上是调整页面的有效区域范围。一般的范围是1000px~1400px（1000px那种的已经算很小了，旧板式一般才会这么窄），对应的CSS在成熟的模板里都有设置，修改相关属性值即可。首先调整父元素的大小为需求大小，此时子元素由于外层变宽将会偏离，考虑好子元素的布局方式，简单试试应该要加多宽，反复调试，最终成型。当子元素显示错行，说明子元素的宽度之和超过了父元素，此时检查全部子元素的左右内外边距之和+内容宽度是否超过父级元素长度，将过长的部分改短。</p>
<p><img src="https://s1.ax1x.com/2020/05/29/tu62sU.jpg" alt="QQ图片20200515145651 (2)"></p>
<p><a href="https://www.runoob.com/htmldom/htmldom-tutorial.html">https://www.runoob.com/htmldom/htmldom-tutorial.html</a><br>拓展阅读：HTML页面的DOM树 有助于理解子级元素和父级元素</p>
<blockquote>
<p>小提示：在遇到修改header，footer的结构需求时，需要同时将一二三级页面都修改，因为HTML不如CSS那样通用，改CSS可以做到三个页面都适用，但牵扯到HTML或者站群设置的修改，记得把一二三级页面都改掉</p>
</blockquote>
<h2 id="难定位元素的控制方法"><a href="#难定位元素的控制方法" class="headerlink" title="难定位元素的控制方法"></a>难定位元素的控制方法</h2><p>这里使用到了后代选择器，这个选择器在网站组讲课时没有讲到，给大家科普一下。后代选择器用于选取某元素的后代元素，当需要修改一个难以添加class的元素时，可以在它的父级元素添加class后，通过后代选择器一层一层的找到要修改的元素。</p>
<p><img src="https://s1.ax1x.com/2020/05/29/tu64o9.png" alt="QQ图片20200515150022"></p>
<p>这里会发现要显示的东西在窗口内容处生成，在修改时无法定位到这个位置，所以我在窗口99的div加了一个class“sjgd”，在审查中定位到修改div，</p>
<p><img src="https://s1.ax1x.com/2020/05/29/tu6IiR.png" alt="QQ图片20200515150025"></p>
<p>可以发现他的路径是这样：</p>
<p><img src="https://s1.ax1x.com/2020/05/29/tu6oJ1.png" alt="QQ图片20200515150027"></p>
<p>所以选择器的写法是<code>.sjgd div div .focus-pagination</code></p>
<h2 id="如何生成静态页面、加入紧急队列"><a href="#如何生成静态页面、加入紧急队列" class="headerlink" title="如何生成静态页面、加入紧急队列"></a>如何生成静态页面、加入紧急队列</h2><p>用于解决站群预览显示为新页面而使用qlu域名访问显示旧页面的问题。简单来讲就是部署的网站没有及时更新。可以提高该网站生成的优先级从而解决此问题。</p>
<p>官方教程：<a href="http://www.sudytech.com/_s80/2016/1108/c1238a22705/page.psp">http://www.sudytech.com/_s80/2016/1108/c1238a22705/page.psp</a></p>
<h2 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h2><p>当需要设置标题居中，或者靠左靠右显示时，不能使用相对定位，绝对定位更不可以，一个潜在问题就是这样会导致文档流混乱，在复杂的div结构中使用定位可能会出现后期维护难处理的显示bug。定位适用于一些小点缀元素或者小按钮，比如轮播图切换按钮，有一些特殊的吸顶导航栏也会需要，目前咱还没遇到过这么高级的模板，但是标题不适用。另外非常不建议使用空格进行对齐，这种做法相当不professional，而且以后如果大家接触了要求手机端也会正常显示的模板的话，空格这种根本无法做到在多端下对齐。正常做法是在块级元素的CSS中设置<code>text-align: center/left/right</code>，强调块级元素，因为诸如span这种行内元素其宽度是等于<code>内容宽度+padding(L,R)</code>的，所以text-align会无效，但是h1,h2,p这种就可以，其宽度默认是继承父级元素的宽度的100%，也就是撑满整一行。如果是行内元素进行居中，先加一条<code>display: block;</code>就可以将行内元素转化为块级元素。</p>
<h2 id="模块设置拖动无效的bug的解决方法"><a href="#模块设置拖动无效的bug的解决方法" class="headerlink" title="模块设置拖动无效的bug的解决方法"></a>模块设置拖动无效的bug的解决方法</h2><p>模块设置拖不动的时候，一般是模板内引入了某个奇怪的js，表现为鼠标浮动到模块上不显示操作框，拖动无法执行。此时开检查会报这种错误：</p>
<p><img src="https://s1.ax1x.com/2020/05/29/tucKS0.png" alt="img"></p>
<p>解决方法是使用ctrl+f搜索script，可以找到全部的script标签，尝试删掉一些，几次尝试之后就可以找出造成问题的script标签。这个问题在环境学院更换模板和机械学院更换模板时均出现过，曾经我以为是错误的引入的jQuery，但是环境学院这个模板造成此bug的原因竟然是一行注释….</p>
<p><img src="https://s1.ax1x.com/2020/05/29/tucMlV.png" alt="img"></p>
]]></content>
      <categories>
        <category>站群工作组相关</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>站群</tag>
      </tags>
  </entry>
  <entry>
    <title>WebPlus网站群平台操作指南—进阶篇</title>
    <url>/2020/04/10/webplus-advanced/</url>
    <content><![CDATA[<p>上一篇文章中介绍了站群的基本操作方法和一些需要注意的地方，本篇整理一些比较复杂的操作。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GWxQXV.jpg"></p>
<a id="more"></a>

<h2 id="如何调整原始模板"><a href="#如何调整原始模板" class="headerlink" title="如何调整原始模板"></a>如何调整原始模板</h2><p>通常，拿到一个默认模版后，结构会比较混乱。所以我们应该想办法把它调整得协调一些。</p>
<p><img src="https://s1.ax1x.com/2020/04/10/GTwri4.jpg"></p>
<p>调整的思路其实是多样的，要根据实际的模板情况灵活运用。有冗余模块则去掉，有缺失模块则添加，如果出现样式问题则开审查调试样式。不过这里仍给出一个一般的操作顺序供以参考。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>第一步是删除。首先将模板中无用的模块或冗余的模块删除。</p>
<blockquote>
<p>注意：请提前备份好删除之前的模版，因为删除操作是无法撤销的。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/04/10/GTcxRU.jpg"></p>
<p>例如，站群默认设置的站点logo存在一些问题，我们需要把这个模块删掉，后期换上自制的logo。只需要点击模块右上角的叉号，在弹出框中点击确定后即可删除。</p>
<p>如果因遇到未知原因导致模块无法删除的，可以考虑在本地删除相应代码。</p>
<p><img src="https://s1.ax1x.com/2020/04/10/GTWzkR.jpg"></p>
<p>作为内嵌模块的代码有这样的一个规律，它们的最根层的div含有一个<code>frag=&quot;窗口xx&quot;</code>的属性。如果要对模块进行修改，改动这些地方的代码即可。</p>
<blockquote>
<p>对模块内部元素的直接CSS修改是有可能不生效的，如果有对模块的CSS修改需求，建议在预览界面使用审查定位到具体的CSS元素。</p>
</blockquote>
<h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>经过一番删除之后，现在的模板应该是一种比较干净的状态。接下来就可以在上面增加内容了。</p>
<p><img src="https://s1.ax1x.com/2020/04/10/GTfXgf.jpg"></p>
<blockquote>
<p>提示：在编辑界面看到的结构可能是显示不正常的，尽管预览时一切正常。这是站群的一个缺陷。</p>
</blockquote>
<p>点击右上角的设计按钮，可以看到整个页面的大概布局。在这个页面点击配置按钮即可返回编辑界面。</p>
<p><img src="https://s1.ax1x.com/2020/04/10/GT4JWq.jpg"></p>
<p>如果出现拖动模块报错的情况，类似下图，此时考虑清除模块配置或者直接点进编辑查看是否已经存在需要的模块。</p>
<p><img src="https://s1.ax1x.com/2020/04/10/GT5icV.jpg"></p>
<blockquote>
<p>注意：诸如导航栏等三个页面都会有的模块，应该在三个页面模板中都做出相应的修改。不能仅修改<code>main.htm</code>。</p>
</blockquote>
<h4 id="添加导航菜单"><a href="#添加导航菜单" class="headerlink" title="添加导航菜单"></a>添加导航菜单</h4><p>添加导航菜单时，先查看站点下的目录是否齐全，如果目录不全则先切换到栏目管理增加相应栏目。不要忘记同时添加栏目下的子栏目。顺序是不重要的，因为在添加时会以手动选择的顺序为主。</p>
<p><img src="https://s1.ax1x.com/2020/04/10/GT7vJH.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/04/10/GT7xWd.jpg"></p>
<p>将导航菜单模块拖动至导航栏所在的模块，即弹出配置页面。按照原型图的顺序依次点入即可。</p>
<p><img src="https://s1.ax1x.com/2020/04/10/GTbFj1.jpg"></p>
<h4 id="添加新闻列表"><a href="#添加新闻列表" class="headerlink" title="添加新闻列表"></a>添加新闻列表</h4><p>与添加导航菜单的操作类似，还是需要先拖动导航菜单模块到相应区域。当然，如果该区域已经有了导航菜单模块可以直接点击进入配置。</p>
<p><img src="https://s1.ax1x.com/2020/04/10/GTqtqx.jpg"></p>
<p>点击某一个栏目选择导入，该新闻列表就会展示此栏目下的文章标题。</p>
<blockquote>
<p>提示：如果你选择了多个栏目，在导入时会增加一个虚拟目录存放整合的信息，该虚拟目录不会在列表中显示。使用这个操作也可以做到信息聚合的作用。</p>
</blockquote>
<p>内容定义配置完毕后，有时还需要在展示配置中调整其他信息。</p>
<p><img src="https://s1.ax1x.com/2020/04/10/GTLkTK.jpg"></p>
<p>箭头所示的选项为平时修改频率较高的选项。窗口标题按照具体需求修改，显示条数需要根据实际显示效果确定，太多或太少都会不协调。标题长度默认为15字符，但是在有些比较宽的列表中太短的标题长度会导致右边有大量留白，此时可以考虑将标题长度适当加长，或直接改为-1（无限制）。More图标有些老师会要求去掉，在设置中修改选项就可以。</p>
<blockquote>
<p>注意：如果标题长度限制过长导致有些标题变成了两行显示，这一般是不被允许的，要考虑把显示长度调短一些。</p>
</blockquote>
<h4 id="添加轮播大图"><a href="#添加轮播大图" class="headerlink" title="添加轮播大图"></a>添加轮播大图</h4><p>轮播图模块的名称叫多图交替，一般位于导航栏正下方。对轮播图的修改一般是以尺寸和显示内容为主。有些模板会自定义好轮播图的样式，所以不需要我们去过多改动。</p>
<p>轮播图的本质其实仍然是一个新闻列表。播放的图片为文章的封面图。在基础篇中有提到过一个操作是，建立一篇只有图片的文章，放入轮播栏目内，即可完成单图片显示。如果需要轮播图点击进入具体文章，则简单修改即可。</p>
<p>展示方式中有两个是需要着重注意的。</p>
<p><img src="https://s1.ax1x.com/2020/04/10/GTXDWF.jpg"></p>
<p>与新闻列表类似，显示条数也要按照具体需求改动。缩略图的显示尺寸是需要重点考虑的问题。通常的，如果要做宽屏的大轮播，需要把显示模式改为指定高度。固定宽度的显示方式对多尺寸显示非常不友好，在制作响应式布局时会带来麻烦。</p>
<blockquote>
<p>注意：在改为指定宽度或指定高度模式时，未指定的参数会继承原来的设置。所以有时候你需要手动把宽高度按当前分辨率改好后再修改设置，这是站群的一个缺陷。通常内容主体部分的宽度为1200px，这或许是一个有借鉴意义的参考值。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/04/10/GTvKC8.jpg"></p>
<h3 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h3><p>将模块基本设置完毕后，接下来的任务是对页面的样式进行调整。</p>
<p>这可能会是一个漫长而又繁琐的过程。既需要按照原型图和需求去改，又要参照设计的基本原则。需要不断地重复这样的一个操作：把模板下载到本地，使用dw修改后再打包上传，在预览中调试页面并做出修改。这样来回几次后，直到基本满意，才算结束。</p>
<blockquote>
<p>注意：假如在某次操作后改动了模块内容，则必须要以当前最新改动的版本为基础进行修改，否则会修改掉对模块的设置。此时的下载请选择模板，配置及内容项。</p>
</blockquote>
<p>假如我要对这个导航栏做出改动：</p>
<p><img src="https://s1.ax1x.com/2020/04/10/G7ShxU.jpg"></p>
<p>现在这个模块有什么问题？</p>
<pre><code>1. 它不够居中
2. 按照需求，要把它的主题色变成蓝色</code></pre>
<p>接下来我们一点一点的尝试解决这两个问题。打开审查元素，定位到问题元素所在位置，分析此处代码。</p>
<p><img src="https://s1.ax1x.com/2020/04/10/G7pmLQ.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/04/10/G7pMon.jpg"></p>
<p>可以发现，该元素通过设定外边距来保持与相邻元素之间的间距。目前的左右间距为23px，但是这太小了。经过简单调试后，发现在36px时是可以正常显示的。</p>
<p><img src="https://s1.ax1x.com/2020/04/10/G7phFI.jpg"></p>
<p>但是在审查中修改的元素只能临时生效，想要保存这个修改要怎么办？看到这里：</p>
<p><img src="https://s1.ax1x.com/2020/04/10/G7pxf0.jpg"></p>
<p>这表示，当前选择器位于style.css的第91行，那么我们只需要在dw里跟踪到这个位置，并将修改同步，就可以了。</p>
<p><img src="https://s1.ax1x.com/2020/04/10/G79Zfx.jpg"></p>
<p>然后再来解决颜色的问题。首先定位到某一个选项，发现在这个选项的代码中没有对颜色的设置，所以我们一级一级的向上寻找，直到找到可以修改颜色的代码段为止。</p>
<p><img src="https://s1.ax1x.com/2020/04/10/G794HJ.jpg"></p>
<p>最终我们定位到这个元素：</p>
<p><img src="https://s1.ax1x.com/2020/04/10/G79qgK.jpg"></p>
<p>那么问题来了，这个颜色要修改成什么呢？为了保持与原模板的风格相似度，我选择改动为原海洋学院模板的主体颜色。打开现在的海洋学院网站，使用审查元素或吸色工具获取主体颜色。另外，注意到在footer部分也有同样的颜色配置，所以建议在替换时将那些颜色同时换掉。</p>
<p><img src="https://s1.ax1x.com/2020/04/10/G7CRPI.jpg"></p>
<p>然而，仍然有一些颜色我们没有修改，这仍然会影响用户体验。注意看下图：</p>
<p><img src="https://s1.ax1x.com/2020/04/10/G7C5M8.jpg"></p>
<p>鼠标浮动上去之后的显示颜色仍然是红色。要修改这个显示样式，仍然需要定位到控制它的CSS。</p>
<p><img src="https://s1.ax1x.com/2020/04/10/G7CxMT.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/04/10/G7P6yT.jpg"></p>
<p>hover型元素是无法直接聚焦到的，但是在开启审查元素面板时鼠标浮动会让控制此样式的代码显示出来。这样只需要按照相同的方式修改属性就可以。</p>
<blockquote>
<p>提示：直接点击右上角的示踪标记可以进入审查元素中的CSS编辑界面，hover元素鼠标移开代码就会在审查中消失，但是可以根据记忆在原CSS中进入所在位置修改，效果相同。</p>
<p><img src="https://s1.ax1x.com/2020/04/10/G7PGSP.jpg"></p>
</blockquote>
<p>修改完成的示例：</p>
<p><img src="https://s1.ax1x.com/2020/04/10/G7ivbF.jpg"></p>
<p>经过这样几番调整之后，你就可以把当前的本地文件夹打包成zip文件，上传到站群系统中了。之后再按照需求对其余的模块进行调试，直到基本满足效果。</p>
<h2 id="解决显示bug"><a href="#解决显示bug" class="headerlink" title="解决显示bug"></a>解决显示bug</h2><p>由于模板与模板之间不相同的特性，显示bug的类型非常繁杂，并且有可能并非是看到的错误。在模板显示出现问题时，可以往两个方向去思考。</p>
<p>第一个方向是由于出错位置本身的设置问题导致的错误，比如因为边距过大导致的导航栏折行bug。这种类型比较好办，只需要将出错位置直接定位修改即可。第二个方向是由于其他元素的设置问题导致原本显示正常的模块显示不正常。比如下图这种显示错位问题，看似是导航栏折行导致的显示错位，但是无论怎么修改导航栏都无法让显示变为正常。最后经过排查发现，是父级元素的宽度太窄，将其改大一些一切变回正常。</p>
<p><img src="https://s1.ax1x.com/2020/04/10/G7EMG9.png"></p>
<p><img src="https://s1.ax1x.com/2020/04/10/G7EOJJ.png"></p>
<p>当显示出现问题时，仍然可以选用上面那种一级一级向上排查的方法，考虑到所有可能的问题所在，比如边距，长宽等。耐心查错总能发现问题。</p>
<h2 id="高度自定义页面"><a href="#高度自定义页面" class="headerlink" title="高度自定义页面"></a>高度自定义页面</h2><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>对一些模板原生支持响应式，且需求需要适应移动端显示时，需要考虑响应式布局。这里我们以招生办公室主页为例。</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GHGB0e.jpg"></p>
<p>上图为最常见的宽屏PC端，旧式4:3屏幕上的显示是基本一致的，只是两边留白小了一些。</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GHGytA.jpg"></p>
<p>上图为pad端，在本模板中结构与手机端是一致的。</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GHGbpq.jpg"></p>
<p>上图为手机端。手机端由于机型繁杂多样，尺寸也可能不尽相同。在设计的时候我们可以仅以几种机型为例测试，可以直接使用Chrome调试中默认的iPhone尺寸作为调试基础，基本显示正常的话即可认为它能适应大部分机型。实际上，Android机型的尺寸和iPhone机型的尺寸大多是基本相同的，所以完全可以按照机型更少的iPhone端来进行测试，会方便一些。</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GHJP91.jpg"></p>
<p>以Responsive模式下进行的调试是可以任意改变屏幕尺寸的宽高的。这种方式比较灵活但也有它自己的局限性。在这个模式下，由于尺寸改变导致的显示bug，有可能并不是实际的显示bug，原因很简单，实际的设备并不会随意改变自己的尺寸。倒不如设定好某个尺寸后刷新一下页面，让它在这个尺寸下重新加载，这样看到的才是接近真实的效果。</p>
<p>在网页模板中，通常会留有独立出来的响应式设置CSS，比如<code>media.css</code>或<code>responsive.css</code>，建议将响应式代码写在这种专门的CSS里面，也是为了后续维护方便。</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GHtvB8.jpg"></p>
<blockquote>
<p>提示：由于解析顺序不同，响应式CSS应当在主CSS之后再进行引入，不然会导致响应式设置无效。</p>
</blockquote>
<p>要考虑到因为响应式设置造成的结构改变可能带来的问题，诸如显示错位等问题是非常常见的。仍然需要耐心修改并仔细调试。尽管并不要求模板能在任何的宽高尺寸下都可以显示正常，但必须要保证在主流分辨率下它是可以正常显示的。可以借助dw中的预览显示帮助确定响应式范围。</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GHNcVS.jpg"></p>
<p>上图红框中每一个标记都代表代码中有一个此种范围的媒体查询，在不同的范围之内存在着不同的样式设置。这也许能比较直观的帮助你调试。</p>
<h4 id="不要忘记真机测试"><a href="#不要忘记真机测试" class="headerlink" title="不要忘记真机测试"></a>不要忘记真机测试</h4><p>这是我个人的一点经验之谈，写在这里供给大家参考。在实际的开发中，我偶然发现到，预览的真机界面和实际的真机界面有时仍然是略有差距的，这不仅与机型相关，还与用户所使用的浏览器相关。在电脑端模拟上看似结构完整的，在真机上可能就会因为浏览器默认设置或尺寸的细微差异而导致结构错位。这就需要我们在设计响应式布局时要尽量设计的更能适应更多的尺寸条件，简单来说，不去强求，但尽量做到。</p>
<h3 id="嵌入自定义结构"><a href="#嵌入自定义结构" class="headerlink" title="嵌入自定义结构"></a>嵌入自定义结构</h3><p>有时候，站群提供的模块并不能满足全部的需求。比如招生办公室页面中专业介绍的菜单：</p>
<p><img src="https://s1.ax1x.com/2020/04/10/G7FfR1.jpg"></p>
<p>新教务处（开发中）的快捷入口：</p>
<p><img src="https://s1.ax1x.com/2020/04/10/G7kCdg.jpg"></p>
<p>甚至头部的logo都是自定义结构：</p>
<p><img src="https://s1.ax1x.com/2020/04/10/G7ZsUS.jpg"></p>
<p>这些站群中没有的结构只能依靠自己开发完成。拥有良好的盒模型构建基础的话写出这样的结构并不是一件困难的事情。需要注意的是代码块编写的位置和响应式。尽量不要把代码块放在模块里面，这可能会造成一些未知的结果，在编写之前最好明确一下页面的结构，确定好这块代码是要放在哪里和哪里之间。同时要考虑到的问题是，新加入的模块有可能破坏了原有的结构布局，比如依靠绝对定位的模块会出现高度“变矮”而表现出一种“穿模”的现象。此时需要改动一些CSS以适应新加入的模块。此外，如果引入了一些其他的框架库，可能会导致由于它的全局设置而改变了其他原本正常元素的显示方式。</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GHaMOx.jpg"></p>
<p>专业介绍列表中我使用了bootstrap的流式网格布局，但引入bootstrap导致了原本显示正常的页面出现了一些其他问题，后来我选择保留该模块，手动修复那些因引入bootstrap而导致显示错位的问题。</p>
<h4 id="自定义结构与站群模块的混合"><a href="#自定义结构与站群模块的混合" class="headerlink" title="自定义结构与站群模块的混合"></a>自定义结构与站群模块的混合</h4><p>实际上，站群的每一个目录建立好之后，进入它的链接也随之固定了。只需要掌握了链接生成的规律就能将进入某个模块的入口混合到自定义结构当中。</p>
<p>首先要明确要制作的页面的域名是什么，链接的地址必须是在那个域名之下。实际上，在调试的时候，显示的地址和实际的地址是不一样的。</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GHwddf.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/04/11/GHwDJg.jpg"></p>
<p>尽管都是招生办公室的主页，但是域名不一样，也就说明它们是不一样的页面。以<code>webplus.qlu.edu.cn</code>打头的地址是调试地址，链接模块时不能以这个为准，会造成打不开的现象。</p>
<p>我们任意点进一个二级页面，看它的地址是：</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GH0npQ.jpg"></p>
<p>接下来发挥合理作死精神，把可疑的2909换成2910试试？奇怪的事情发生了：</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GH0MXn.jpg"></p>
<p>它变成了下一个栏目。为什么会这样呢？我们进入栏目管理，就可以发现真相：</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GH00n1.jpg"></p>
<p>没错，起作用的是这个虚拟目录。我们只需要知道相对应的虚拟目录就可以进入到该列表中。有多级目录的话也是同理。</p>
<blockquote>
<p>提示：链接可以最短简化成下图这样。</p>
<p><img src="https://s1.ax1x.com/2020/04/11/GHDpqI.jpg"></p>
</blockquote>
<p>现在你就可以把一些栏目的链接通过此种方法找到，并写在自定义结构下的超链接中了。该操作的反向操作比较简单，即为在目录中添加外链，该部分已在基础篇有过讲解。</p>
<h2 id="信息采集与一键扒站"><a href="#信息采集与一键扒站" class="headerlink" title="信息采集与一键扒站"></a>信息采集与一键扒站</h2><p>本部分操作官方文档解释的很详细，这里将它们转载来。</p>
<h3 id="信息采集"><a href="#信息采集" class="headerlink" title="信息采集"></a>信息采集</h3><p>信息采集工具是针对互联网页面的源代码进行一定的人工分析，获取唯一规则后，由服务器端进行访问获取文章的标题，内容，发布时间，浏览次数等信息。站群中，只有站点管理员和系统管理员才拥有信息采集权限。简单来讲就是把一些非站群页面中的文章列表和正文通过一种类似于爬虫的东西全部爬进来，一般用于将非站群页面的网站转换到站群页面来。现在这样的需求应该比较少了。</p>
<p>详情请参考<a href="http://pro.webplus.net.cn/_s80/xxcj/list.psp">http://pro.webplus.net.cn/_s80/xxcj/list.psp</a></p>
<h3 id="一键扒站"><a href="#一键扒站" class="headerlink" title="一键扒站"></a>一键扒站</h3><p>用于把别的网站的页面转化成站群可用的模板，需要对页面结构比较熟悉，而且扒下来后可能会有很多bug需要修复。</p>
<p>详情请参考<a href="http://121.40.124.129/_s80/59/19/c1236a22809/page.psp">http://121.40.124.129/_s80/59/19/c1236a22809/page.psp</a></p>
]]></content>
      <categories>
        <category>站群工作组相关</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>站群</tag>
      </tags>
  </entry>
  <entry>
    <title>WebPlus网站群平台操作指南—初级篇</title>
    <url>/2020/04/08/webplus-tutorial/</url>
    <content><![CDATA[<p>网站群平台是我校用于维护官网页面的集成工具，尽管系统相对老旧一些，但仍然能完成完整的站点建设工作。为了方便后续同学的维护工作，提升学习效率，我将一些基本操作整理了下来，方便同学们查询阅读。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GWxQXV.jpg"></p>
<a id="more"></a>

<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>站群的操作几乎完全是前端方面的内容，基于模板+模块的形式，在模板内更改网站基本样式，在模块里设置具体显示内容。学校站点并不是不需要后端，而是后端被站群系统以图形化形式集成在了管理界面中。</p>
<p>对页面的调试可能是一个漫长而又繁琐的工作，请保持有充分的耐心。如果遇到实在无法完成的需求，请记得及时向老师或学长学姐联系。</p>
<p>在开始之前，你需要基本掌握以下内容：</p>
<ul>
<li>HTML/CSS语法基础，盒模型布局理论，响应式布局理论</li>
<li>Adobe Dreamweaver的基本操作方法</li>
<li>Adobe Photoshop的基本操作方法</li>
<li>在主流浏览器（如Chrome，Firefox等）使用审查元素调试页面的能力</li>
<li>校内VPN的使用方法（如果你在校外）</li>
</ul>
<p>本文默认你已经基本学会了这些内容，这里不会对这些内容做出过多提及。那么，我们开始吧。</p>
<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>登录学校站群系统需要校园网环境，如果不使用校园网的话是无法进入系统的。如果要在校外使用此系统，需要连接校内VPN。</p>
<p>打开<a href="http://webplus.qlu.edu.cn/">http://webplus.qlu.edu.cn/</a>，输入老师提供的账号密码，即可进入后台。如果是系统管理员的话，第一次进入的页面应该是这样：</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GfFmQJ.jpg"></p>
<p>这里是整个网站的后台设置，一般来说我们是不需要动这里的内容的，而且有些操作比较敏感，不慎操作容易造成事故。如果要修改某个具体页面的话，要在右上角的搜索框中进入要修改的页面。</p>
<p>搜索框内有下拉菜单，可以看到全部的院系页面分布。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GfFb6J.jpg"></p>
<p>如果你登录的是某个学院或者部门的分账号，则应该会直接进入对应的后台。</p>
<p>这里我们以学校教务处的页面为例。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GfkTEt.jpg"></p>
<p>在搜索框内可以搜索到对应页面，点击进入就能进入教务处后台。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GfAAv4.jpg"></p>
<p>有3个功能是我们最常使用的，这里对它们进行一些简单的介绍。</p>
<h2 id="模板管理"><a href="#模板管理" class="headerlink" title="模板管理"></a>模板管理</h2><p><img src="https://s1.ax1x.com/2020/04/08/GfAqd1.jpg"></p>
<p>这里是模板管理的界面，在这里可以查看模板的目录结构，修改模板内容，更改资源或更改代码。通常的，当我们需要修改页面上的结构或显示方式时，会用到这里的功能。</p>
<p>我们来简单说一下会用到的地方。</p>
<h3 id="整体模板管理"><a href="#整体模板管理" class="headerlink" title="整体模板管理"></a>整体模板管理</h3><h4 id="操作现有模板"><a href="#操作现有模板" class="headerlink" title="操作现有模板"></a>操作现有模板</h4><p><img src="https://s1.ax1x.com/2020/04/08/GfEloq.jpg"></p>
<p>这个模块是用来管理模板整体的，可以在多个模板之间切换，也可以上传新模板。默认模板为网站上线后默认展示的模板。点击左右两边的箭头按钮可以滚动查看不同的模板。在你进行修改工作时，一定要记清楚自己修改的是哪一个模板，避免出现修改混淆的情况。</p>
<p>当你要下载某一个模板到本地进行修改时，就点击这个下载按钮。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GfVC1U.jpg"></p>
<p>下载选项有三个，分别是仅模板，模板及配置，模板、配置及内容项。通常的，如果你要把某个网站的模板提取出来构建一个新网站的话，就选择仅模板，如果你要在已经配置好的模板上进行改动时，最好选择模板、配置及内容项，这样在上传之后不需要重新配置模块展示的内容。</p>
<p>当你要在现有的模板上覆盖上传时，就要点击这个修改按钮。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/Gfe2XF.jpg"></p>
<p>在这里可以上传本地已经改好并且压缩完毕的模板包，模板包规则如图所示。下面的模板名称，模板语言等默认不用修改，而模板状态和生成静态页面这两个按钮需要点击成启用才可以使用。本图演示的模板为默认模板，模板状态和生成静态页面是强制开启的，所以无法修改。非默认模板这两个按钮是可以点击修改的。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GfeIt1.jpg"></p>
<h4 id="创建新模板"><a href="#创建新模板" class="headerlink" title="创建新模板"></a>创建新模板</h4><p>要新建一个模板也是很简单的，只要点击此栏的“创建新模板”即可。创建新模板可以通过本地上传，也可以调取在线模板。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GfniP1.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/04/08/Gfneqe.jpg"></p>
<p>如果需要自己建立模板，可以在模板库中寻找模板进行创建。如果有提供的模板，则使用本地上传即可。</p>
<h3 id="模板目录结构"><a href="#模板目录结构" class="headerlink" title="模板目录结构"></a>模板目录结构</h3><h4 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h4><p><img src="https://s1.ax1x.com/2020/04/08/GfmH5n.jpg"></p>
<p>在站群系统中，所有的模板都是按照多级页面的结构来整体划分的。所以必须包含一级页面<code>main.htm</code>，二级页面<code>listcolunm.htm</code>还有三级页面<code>displayinfo.htm</code>这三个文件，它们的文件名是不可以被修改的。通过名字不难看出，一级页面便是我们通常所说的站点主页，二级页面为栏目模块的文章列表页，三级页面为文章正文页。这三个文件之外的文件便是页面需要的资源文件，比如要显示的图片，使用的CSS文件和JS文件等。一些比较小型的页面会将图片文件，CSS文件和JS文件放在同级目录下，但也会有一些比较复杂的页面将它们进行分类。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GfKknO.jpg"></p>
<blockquote>
<p>提示：在某栏目下只有一篇文章时，二级页面将直接显示正文。</p>
</blockquote>
<h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><p>对文件的操作通常有三种，这里简单一一介绍一下。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GfKIbD.jpg"></p>
<p>首先是源代码编辑按钮，点击后可以直接在站群系统内编辑代码文件，但除非临时修改或其他极端情况（如上传无效），一般不建议从这里对代码进行修改。这里的修改界面没有语法高亮，没有缩进，排版等提示，非常不方便使用，只能当作一个备用的解决方案使用。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GfMC5j.jpg"></p>
<p>中间的这个是模板配置按钮，点击后可以进入该页面的模板配置界面。该界面是配置模块等内容的核心界面，在后面的章节中将对它进行详细讲解。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GfMNZD.jpg"></p>
<p>最右边这个放大镜按钮为预览按钮，可以对该模板进行一个整体的预览，在这里显示的效果即为实际上线后显示的效果，通常会在这里打开审查对页面进行调试，修改存在的问题。该界面是调试页面的核心界面，在后面的章节中将对它进行详细讲解。</p>
<h2 id="栏目管理"><a href="#栏目管理" class="headerlink" title="栏目管理"></a>栏目管理</h2><p>栏目管理负责文件目录的增删改，每个目录都可以作为显示内容的载体，当需要建立某些栏目的时候，需要打开它的父级目录显示的列表，才能建立到正确的位置。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/Ghlz0f.jpg"></p>
<p>简单来说，这里的根目录是教务处，诸如教务处首页、教务管理、学籍管理等目录是在根目录下面。如果要建立一个与学籍管理相同层次的栏目，则需要点击教务处目录，再新建。如果点击学籍管理目录去新建栏目的话，它就会变成学籍管理目录下的子栏目。</p>
<p>对栏目的具体操作界面是这样的：</p>
<p><img src="https://s1.ax1x.com/2020/04/08/Gh34IO.jpg"></p>
<h3 id="增加与修改"><a href="#增加与修改" class="headerlink" title="增加与修改"></a>增加与修改</h3><p>默认情况下，增加栏目只需要写个名字就好。要注意同级目录下名字是不可以重复的。修改同理。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GhGk1H.jpg"></p>
<h4 id="高级属性"><a href="#高级属性" class="headerlink" title="高级属性"></a>高级属性</h4><p>高级属性中用到较多的为图中的三个选项。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GhGYBq.jpg"></p>
<p>导航栏中一般放置的是栏目，如果想让某个栏目直接链接到比如学校主页等特定页面的话，就需要使用外链功能。打开方式为当前窗口和新窗口两个方式。默认为当前窗口打开。如果需要新窗口打开则在这里调整。子栏目排序可以调整栏目的排列顺序，有新建在后和新建在前两个选项，如果有修改需求请在这里修改，如无则可以不动。</p>
<h4 id="列表显示配置"><a href="#列表显示配置" class="headerlink" title="列表显示配置"></a>列表显示配置</h4><p><img src="https://s1.ax1x.com/2020/04/08/Ght8jH.jpg"></p>
<p>在一些需要显示缩略图列表的场合需要用到这个功能。举例说明：</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GhtjPK.jpg"></p>
<p>这里的列表带有了缩略图，并且是多列显示。其显示方式便是由列表显示配置修改而成。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GhNEPf.jpg"></p>
<p>可以很明显的看到，这里的显示为图片列表，行列布局为4行2列。缩略图的尺寸也是可以固定的。</p>
<blockquote>
<p>注意：该布局模式并非现代化布局，使用的是不支持响应式的table，如果需要做到适应性布局建议使用<code>overflow: scroll;</code>限制区域。</p>
</blockquote>
<h2 id="文档管理"><a href="#文档管理" class="headerlink" title="文档管理"></a>文档管理</h2><p>文档管理负责的是三级页面中的内容，即文章正文。很多时候我们并不需要帮助撰写文章，这些文章都会由负责相关页面的老师编辑发布。但有时候是需要我们帮助发布一些文章的。这时候就需要用到这里的功能。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GhdYz8.jpg"></p>
<h3 id="增加与修改-1"><a href="#增加与修改-1" class="headerlink" title="增加与修改"></a>增加与修改</h3><p>点击增加或者修改，可以弹出这样的一个编辑界面。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GhdHSK.jpg"></p>
<p>和一般的word用起来区别不太大，如果老师给了word文档直接全选复制粘贴就能解决问题。可以通过预览查看展示效果，如果展示有问题则根据实际情况修改即可。完成的文章会处于定稿状态，还不会立即发布。需要点击发布才可以直接发布文章。默认发布文章以时间最新排序。</p>
<blockquote>
<p>提示：在文中上传的第一张图片会被默认为封面图，这在轮播图等图片展示组件内会被展示。所以有些轮播图可以使用正文内仅放一张图片来当作内容。</p>
</blockquote>
<h3 id="多栏发布"><a href="#多栏发布" class="headerlink" title="多栏发布"></a>多栏发布</h3><p>多栏发布一般用于这样的需求：</p>
<p>有多个栏目下拥有“通知公告”子栏目，现在想要在首页建立一个栏目，可以将这些通知公告聚合起来展示。</p>
<p>当然，手动操作是完全ok的，但如果文章数量很多，工作量可想而知。</p>
<p>多栏发布可以用于将多个栏目下的文章整合起来到一个栏目下，进行一个信息的聚合，方便展示。只要选中一个或多个文章，点击多栏发布，再点击要发布到的栏目，就可以了。</p>
<blockquote>
<p>提示：有多栏发布信息的目录文件夹会变成蓝色。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/04/08/Gh06rF.jpg"></p>
<h2 id="调试与改动"><a href="#调试与改动" class="headerlink" title="调试与改动"></a>调试与改动</h2><p>在拿到一份修改需求后，我应该怎么做？</p>
<p>简单来讲就是所见即所得，需要什么就做出什么。需要开栏目我就开栏目，需要加文章我就加文章。如果需要动结构或者模块，则需要慢慢调试。</p>
<h3 id="增加模块"><a href="#增加模块" class="headerlink" title="增加模块"></a>增加模块</h3><p><img src="https://s1.ax1x.com/2020/04/08/GhrOIJ.jpg"></p>
<p>以这个页面为例，它的结构非常简单明了，在header下面有一个导航栏，导航栏下面是大轮播图，中间的“教学服务”等板块为自定义内容，下面是新闻列表。</p>
<p>上方的选择菜单是可供选用的模块形式。由于模板已经基本写好了对应模块的CSS，所以这个大可不必太过担心，如果有显示问题再慢慢调整就可以。</p>
<p>最常用的三个模块是新闻列表，导航菜单和多图交替。新闻列表用于显示一切列举菜单的东西，包括各种形式的信息展示，点击进去是正文。而导航菜单一般用于显示目录列表，一般用于页面头部，点击进去是二级菜单。如果需要增加某个模块，只要把模块拖进相应的位置就可以。</p>
<blockquote>
<p>提示：当你拖动模块到一个已经有内容的模块上时有可能会报错，此时可以先清除模块配置再拖动进去。</p>
</blockquote>
<h3 id="改动模块"><a href="#改动模块" class="headerlink" title="改动模块"></a>改动模块</h3><p>当你把鼠标移动到某个模块上时，会出现一系列可选操作。这里目前只介绍修改和清除。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/GhsGJs.jpg"></p>
<p>点击这里可以对板块的内容进行修改。</p>
<p><img src="https://s1.ax1x.com/2020/04/08/Ghs0wF.jpg"></p>
<p>不同的板块其设置内容也不尽相同。以新闻列表为例，可以设置的内容有以上这些。诸如标题，显示条数，打开方式，标题长度，发布时间等样式可以在这里设置。</p>
<p><img src="https://s1.ax1x.com/2020/04/09/Ghy0jP.jpg"></p>
<p>在内容定义中可以添加目录，如果是新闻列表的话则会直接显示当前目录下的文章标题列表。如果是导航菜单的话会显示当前目录下的子目录列表。</p>
<p>一般来说，首先需要将模板下载到本地，用dw打开，在页面预览上使用审查排查可能存在的问题，或根据老师的需求修改样式。需要看的地方都有哪些呢？</p>
<ul>
<li>板块之间有没有不协调的位置，比如导航栏有没有被折成两行</li>
<li>模块有没有因为尺寸不合适越出应该出现的位置，此时需要改动一下模块的设置</li>
<li>样式有没有不协调的地方，有的话应该去修改对应的CSS</li>
<li>在移动端显示时有没有显示不正常，有的话应该要去修改</li>
</ul>
<h3 id="清除模块配置"><a href="#清除模块配置" class="headerlink" title="清除模块配置"></a>清除模块配置</h3><p>如果这个模块出现了设置问题，或者需要换入新模块，则需要清除模块配置。</p>
<p><img src="https://s1.ax1x.com/2020/04/09/Ghyghj.jpg"></p>
<blockquote>
<p>提示：该操作不可逆，请谨慎使用。</p>
</blockquote>
<h3 id="调试页面"><a href="#调试页面" class="headerlink" title="调试页面"></a>调试页面</h3><p>页面调试是一个很难仔细去讲的过程。因为不同页面之间的修改需求是不一样的，也需要随机应变的去修改一些属性。不过要相信的是，所有的样式问题都能找到它根本的设置问题。可以从审查中直接定位到出现问题的位置，再去排查。假如某个元素的显示不正常，但是这个元素没有相应的设置，这时候需要在审查里一级一级的向上跳着看他的父级元素是不是哪里设置出了问题，然后改参数或者加属性调整，直到满意后从dw里把刚才的修改实装一下。</p>
<p>简单来说，实践出真知。多调试总会找到调试的窍门。</p>
<p><img src="https://s1.ax1x.com/2020/04/09/Gh6lCj.jpg"></p>
<p>如果某个属性是定死在标签里面的，或者页面一动就会又变回来，那大概率这个属性是通过模块或者JS代码修改的。这样的操作起来就有一点麻烦。对于这样的情况，在之后的篇章中再继续讨论。</p>
<h2 id="危险操作"><a href="#危险操作" class="headerlink" title="危险操作"></a>危险操作</h2><p> <strong>要注意，有些操作是没有撤销的。</strong></p>
<p>比如在模块编辑时对模块的改动，以及覆盖上传模版，对栏目的修改，对文章的修改，有很多的操作无法进行撤销，如果出现了模块丢失或文章丢失，处理起来会比较麻烦。所以这里建议下手时一定要多加小心，对不清楚是否可以回退的操作一定要提前做好备份，以防万一。</p>
<p>一定要做好备份，一定要做好备份，一定要做好备份！</p>
]]></content>
      <categories>
        <category>站群工作组相关</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>站群</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js框架学习笔记整合</title>
    <url>/2020/02/07/vue-collection/</url>
    <content><![CDATA[<p>该部分笔记整合了我之前学习Vue框架时的相关内容，原笔记发布于2020年初。</p>
<p>当前博客显示的发布时间非真实时间，而是这些内容在当时发布时的最后发布时间。</p>
<p><img src="https://i.loli.net/2020/04/02/AzMcD1UseQk2IZo.jpg"></p>
<a id="more"></a>

<h2 id="简单认识Vue-js"><a href="#简单认识Vue-js" class="headerlink" title="简单认识Vue.js"></a>简单认识Vue.js</h2><p>Vue是一个渐进式的框架，什么是渐进式的呢？</p>
<ul>
<li>渐进式意味着可以将Vue作为应用的一部分嵌入其中，带来更丰富的交互体验。如果需要使用Vue重构项目，它的工程可以是一点一点来的，假如有多个非Vue技术栈页面，有的用jq，有的用原生，可以先改一部分，再改一部分，可以不全盘更换。</li>
<li>如果希望将更多的业务逻辑使用Vue实现，那么Vue的核心库以及其生态系统比如Core + Vue-router + Vuex，也可以满足各种各样的需求。如果是新项目使用Vue编写，则可以直接Vue全家桶，像隔壁后端的Spring Boot那样。</li>
</ul>
<p>在ES6中，用let定义变量，const定义常量。</p>
<p>编程范式：命令式编程：</p>
<ol>
<li>创建div元素，设置id属性</li>
<li>定义一个变量叫message</li>
<li>将message放在前面的div元素中显示</li>
<li>…</li>
</ol>
<p>逐行执行，先做什么，再做什么，这就是命令式编程</p>
<p>编程范式：声明式编程：</p>
<p>只需要告诉实例去管理哪个div，在里面写什么东西，这就可以了。</p>
<p>vue使用的是声明式编程，这个思想有点类似于面向对象。这种操作可以做到数据与页面完全分离，页面只需要管页面，数据交给js解决。如果采用命令式编程，则还需要重新绑定，在数据修改后重新使用一次<code>getElementByID()</code>，但是使用vue的话，假如div里面显示的东西是message，此时开审查，在控制台修改message的值，数据会跟着变动。这种形式也被称为响应式。</p>
<p>不想让显示随着数据的改变而改变？那就在标签内加入v-once属性</p>
<p>展示更复杂的数据，比如要展示一整个列表，不需要像以前那样ul里套多个li，使用<code>v-for</code>可以把一整个数组的全部数据遍历输出，只需要一个li。不再需要在JavaScript里完成DOM拼接。它仍然是响应式的。</p>
<p>methods属性里面定义各种方法，在里面调用app对象的变量前面要加this，代表当前对象中的变量，如果不加则它会从全局找变量。</p>
<p><code>@click</code>是<code>v-on:click</code>的一个语法糖。</p>
<p>开发中什么时候称之为方法，什么时候称之为函数？</p>
<p>方法：method 函数：function</p>
<p>在类中的成员函数称之为方法，在类外面的函数为函数。方法是和某一个实例或者对象挂钩的，是作为一个对象实例的属性的函数。</p>
<p>生命周期：事物从诞生到消亡的整个过程。</p>
<p>JavaScript中let和var的区别：参考<a href="https://www.jianshu.com/p/9f7f053f7204">https://www.jianshu.com/p/9f7f053f7204</a></p>
<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="插值操作"><a href="#插值操作" class="headerlink" title="插值操作"></a>插值操作</h3><p>Vue中常用的<code>&#123;&#123; &#125;&#125;</code>双大括号叫做Mustache语法（单词原意：胡子，胡须），这个用的是最多的。需要注意mustache语法只能用于html内容，不能用于html属性。</p>
<p>mustache语法中，不仅仅可以直接写变量，也可以写简单的表达式，复杂表达式可以使用computed属性。</p>
<p>使用v-html属性可以把字符串的内容以html形式解析。使用<code>v-text=‘属性’</code>也可以在页面上显示那个值，但是这样不够灵活，虽然标签内不再需要mustache语法，但是如果想加点什么这样就不行了， 内容会被v-text覆盖。</p>
<p>v-pre的功能与<code>&lt;pre&gt;&lt;/pre&gt;</code>类似，展示原来的mustache语法，不解析就输出。</p>
<p>v-cloak（单词原意：斗篷，遮蔽）执行的是这样的功能，有时候解析需要一些时间，在解析之前打印在屏幕上的内容是原生的mustache代码，这可能会给用户带来不好的浏览体验，即使它存在的时间很短。使用v-cloak可以让它在解析之前隐藏。实际上，v-cloak的官方功能是，在vue解析之前，div存在这个属性，在div解析之后，这个属性就将删除。刚才所述即是v-cloak的使用例子之一。顺带一提，对v-cloak使用CSS的语法规则是<code>[v-cloak]: &#123;&#125;</code>，这是一个我以前不太常用的选择器。</p>
<h3 id="绑定属性"><a href="#绑定属性" class="headerlink" title="绑定属性"></a>绑定属性</h3><p>这个东西用来修改html代码的属性，比如动态维护img标签的src属性，使其可以变换图片，这种叫做动态绑定img元素的src属性，还可以动态绑定a元素的href属性。可以使用<code>v-bind</code>指令，它可以用来动态绑定属性。动态的图片链接很可能是从服务器请求来的，使用vue将它放在data里面，再通过v-bind进行动态绑定属性。</p>
<p>使用例：<code>&lt;img v-bind:src=&quot;imgURL&quot; alt=&quot;&quot;&gt;</code>，其中imgURL代表data中的属性，里面存着一个图片链接。</p>
<p>很多时候都是这样，从服务器传回数据到vue中转，vue再把这些数据处理后传给DOM，就能在页面里显示那些内容。</p>
<p>语法糖：<code>&lt;img :src=&quot;imgURL&quot; alt=&quot;&quot;&gt;</code>，只在属性前面加一个冒号。</p>
<p>绑定属性也可以用来动态绑定CSS，即动态绑定class属性。class后接一个列表中的键值对，一个类名对应一个bool值，值为true表示有这个class，值为false表示没有这个class。这样写不妨碍正常加写死的class。</p>
<p>使用例：<code>&lt;h2 v-bind:class=&quot;&#123;类名1: bool, 类名2: bool&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</code></p>
<p>有时候这样的列表会让代码写的很长，看起来不方便，此时可以把这些属性绑定到一个method或者conputed里面。要注意放在里面的话使用变量需要加<code>this.</code>。</p>
<p>可以绑定一个数组：<code>class=[变量1, 变量2, ...]</code>，变量如果直接是名字则就是data后对应的值，如果是字符串则就是字符串的内容。</p>
<p>动态绑定style的时候，如果要设定某个数值是定死的，不能直接写数字，那样vue会把它认为是一个变量，此时需要加一个单引号括起来，直接按字符串解析，就ok。</p>
<p>例：<code>&lt;h2 :style=&quot;&#123;font-size: &#39;50px&#39;&#125;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</code>（这是一种key:value的写法）</p>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>computed属性。用于数据的组合。本质上是属性而不是方法，当某些情况需要将一些数据组合显示的时候（比如组合显示姓和名，组合显示书籍名称编号价格等信息），使用计算属性可以让代码更简洁直观。</p>
<p>例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>总价格：&#123;&#123;allPrice&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">		allPrice: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">let</span> sum = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; <span class="built_in">this</span>.books.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">				sum += <span class="built_in">this</span>.books[i].price;</span></span><br><span class="line">			&#125;</span><br><span class="line"><span class="javascript">			<span class="keyword">return</span> sum;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>计算属性有get和set方法，这一点和C#有点像，但是实际写的时候一般是没有set方法的，也就是说这个属性不可以被修改，即表明该属性为只读属性。如果需要修改属性则需要写上set，最好在函数里面传入一个变量，它代表修改的值，可以用它来执行一些操作。比如输入一个名字的话就可以传入后用split方法分割字符串，分割的结果保存在数组里，然后再把新的值传给原来的变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fullName: &#123;</span><br><span class="line">	set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">const</span> names = newValue.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">		<span class="built_in">this</span>.firstName = names[<span class="number">0</span>];</span><br><span class="line">		<span class="built_in">this</span>.lastName = names[<span class="number">1</span>];</span><br><span class="line">	&#125;,</span><br><span class="line">	get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tips：不要在html代码里写过于繁琐的逻辑，这样不利于展示。</p>
<p>使用计算属性比普通方法还具有性能优势，因为计算属性具有一个缓存的特性。当同样的计算属性值被打印多次时，如果不发生修改，这个计算属性只会被调用一次。但是如果使用普通方法，则每次打印都会调用一次，这会增加开销。</p>
<h2 id="v-bind绑定属性"><a href="#v-bind绑定属性" class="headerlink" title="v-bind绑定属性"></a>v-bind绑定属性</h2><p>需求：一个列表内使用v-for显示数组中的内容，并支持点击某项时颜色变化。</p>
<p>思路：v-for在进行遍历的时候可以拿出index关键字来使用，作为遍历的下标。这个下标是一会用来定位哪一项的。然后添加@click属性为一个传入了index值的函数，添加:class属性控制列表的CSS，它的启用禁用由currentIndex和index数值进行判断，使用严格相等判断符号<code>===</code>。</p>
<p>currentIndex作为一个状态存储，是在data里面提前声明好的。在methods里面完成@click调用的函数，让当前index的值赋给currentIndex。这样每次点击都会让currentIndex的值变为点击的那个index值，vue会判断currentIndex（当前点击的）是否等于index（遍历到的），如果相等就说明点击了这，启用CSS，文字变色。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>homework<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">			<span class="selector-class">.active</span> &#123;</span></span><br><span class="line"><span class="css">				<span class="selector-tag">color</span>: <span class="selector-id">#ff0000</span>;</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(m, index) in movies&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;liClick(index)&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active: currentIndex === index&#125;&quot;</span>&gt;</span></span><br><span class="line">				&#123;&#123;index&#125;&#125;-&#123;&#123;m&#125;&#125;</span><br><span class="line">				<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">				el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">				data: &#123;</span><br><span class="line"><span class="javascript">					movies: [<span class="string">&#x27;你的名字&#x27;</span>, <span class="string">&#x27;言叶之庭&#x27;</span>, <span class="string">&#x27;天气之子&#x27;</span>, <span class="string">&#x27;她和她的猫&#x27;</span>, <span class="string">&#x27;秒速五厘米&#x27;</span>],</span></span><br><span class="line">					currentIndex: -1</span><br><span class="line">				&#125;,</span><br><span class="line">				methods: &#123;</span><br><span class="line">					liClick(index) &#123;</span><br><span class="line"><span class="javascript">						<span class="built_in">this</span>.currentIndex = index;</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;) </span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>在前端开发中，需要经常和用户交互。这个时候就必须监听用户发生的事件，比如点击、拖拽、键盘事件等等。在Vue中使用v-on:click指令监听事件。这个东西其实之前用过。</p>
<p>其实不仅有v-on:click，还有keyup，监听按键抬起等事件。</p>
<p>当通过methods定义方法，以供@click调用时，需要注意参数的问题。如果该方法不需要额外参数，则方法后的括号可以不添加。但是注意，如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去。</p>
<p>如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件。如果直接传入event，会导致vue先认为它是一个变量，然后发现没有这个变量，就会报错。</p>
<p>tips：如果函数需要参数，但是没有传入，那么函数的形参为undefined。</p>
<p>事件冒泡：当事件发生后，这个事件就要开始传播(从里到外或者从外向里)。为什么要传播呢？因为事件源本身（可能）并没有处理事件的能力，即处理事件的函数（方法）并未绑定在该事件源上。例如我们点击一个按钮时，就会产生一个click事件，但这个按钮本身可能不能处理这个事件，事件必须从这个按钮传播出去，从而到达能够处理这个事件的代码中（例如我们给按钮的onclick属性赋一个函数的名字，就是让这个函数去处理该按钮的click事件），或者按钮的父级绑定有事件函数，当该点击事件发生在按钮上，按钮本身并无处理事件函数，则传播到父级去处理。（百度百科）</p>
<p>vue中处理事件冒泡的方法时使用v-on修饰符。比如<code>.stop</code>阻止事件的冒泡（停止冒泡），<code>.prevent</code>阻止表单提交后的自动发送数据，因为如果我要进行其他处理后再进行传输，默认的传输就必须阻止（停止默认行为）。还有<code>.keyCode</code>和<code>.keyAilas</code>，只当事件是从特定键触发时才触发回调。比如<code>@keyup.enter</code>就是只监听键帽抬起后的回车。<code>.native</code>用于自定义组件，监听组件根元素的原生事件。<code>.once</code>只触发一次回调（可用于阻止重复提交）。</p>
<p>需要多个修饰符的时候直接连着用。</p>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>使用v-if判断这个东西要不要被渲染出来。值为true就渲染，为false就不渲染。与if-else语句类似，有v-if，也有v-else。v-else是找到离他最近的v-if，如果条件不满足则渲染v-else里面的东西，如果v-if满足了，那么v-else里面的东西就不渲染。此外还有v-else-if，用法类似。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">&quot;score &gt;= 90&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else-if</span>=<span class="string">&quot;score &gt;= 80&quot;</span>&gt;</span>良好<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else-if</span>=<span class="string">&quot;score &gt;= 60&quot;</span>&gt;</span>及格<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else</span>&gt;</span>不及格<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="用户登录切换的案例"><a href="#用户登录切换的案例" class="headerlink" title="用户登录切换的案例"></a>用户登录切换的案例</h2><p>要做一个小切换选项，用户点击可以切换成邮箱登录或账号登录。</p>
<p>使用v-if和v-else就可以完成这个操作。设立两套渲染，然后按钮负责切换，设定一个状态变量判断当前是哪个，每次点击就把那个变量取反，让渲染变成另一套，就ok。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue登录切换<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;isUser&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户账号<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户账号&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;useremail&quot;</span>&gt;</span>用户邮箱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">id</span>=<span class="string">&quot;useremail&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户邮箱&quot;</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;switchMode&quot;</span>&gt;</span>切换类型<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">				el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">				data: &#123;</span><br><span class="line"><span class="javascript">					isUser: <span class="literal">true</span>,</span></span><br><span class="line">				&#125;,</span><br><span class="line">				computed: &#123;</span><br><span class="line">					</span><br><span class="line">				&#125;,</span><br><span class="line">				methods: &#123;</span><br><span class="line">					switchMode() &#123;</span><br><span class="line"><span class="javascript">						<span class="built_in">this</span>.isUser = !<span class="built_in">this</span>.isUser;</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是这样做有个小问题。如果在有输入内容的情况下切换了类型，会发现文字依然显示之前的内容。但是按道理讲是已经切换到另一个input元素去了，在另一个input元素中我们并没有输入内容，为什么会这样？因为Vue在进行DOM渲染时，出于性能考虑，会尽可能的复用已经存在的元素，而不是重复创建新的元素。在这个案例中，Vue内部会发现原来的input元素不再使用，直接作为else中的input来使用。如果不希望出现此类复用问题，可以给对应的input添加key，并且需要保证key的不同。</p>
<p>这样把代码改一下就可以了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;isUser&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户账号<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户账号&quot;</span> <span class="attr">key</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;useremail&quot;</span>&gt;</span>用户邮箱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">id</span>=<span class="string">&quot;useremail&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户邮箱&quot;</span> <span class="attr">key</span>=<span class="string">&quot;useremail&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;switchMode&quot;</span>&gt;</span>切换类型<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-show与v-if"><a href="#v-show与v-if" class="headerlink" title="v-show与v-if"></a>v-show与v-if</h2><p>v-show的用法和v-if非常相似，也用于决定一个元素是否被渲染。在开发中选择的依据是：v-if当条件为false时，根本不会有对应的元素在DOM中。v-show当条件为false时，仅仅是将元素的display属性设置成none，即DOM中有这个元素，但是CSS设置为不显示。当需要在显示与隐藏之间切换很频繁时，使用v-show，当只有一次切换时，使用v-if。</p>
<h2 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h2><p>第一种情况是遍历数组。在遍历的过程中可以获取索引值，也可以直接遍历。</p>
<p><code>v-for=&quot;item in xxx&quot;</code>这样只有一项的，就代表索引项。</p>
<p><code>v-for=&quot;(index, i) in name&quot;</code>这样有两项的，前一项代表索引项，后一项代表索引值。项数再增加则没有效果。</p>
<p>还有一种情况是遍历对象，输出每一个成员。js当中的对象是以键-值的形式出现的，如果只获取一个值，那么获取到的就是value，如果获取两个值，就会先获取value再获取key。如果此时还需要index，那就获取三个值，第三个值就是序号。</p>
<p>官方推荐在使用v-for时，给对应的元素或组件加上一个:key属性，为什么需要这个key？和Vue的虚拟DOM的Diff算法有关系。当某一层有很多相同的结点时，也就是列表结点时，我们希望插入一个新的结点。我们希望可以在B和C之间加一个F，Diff算法默认执行起来是这样的：把C更新成F，D更新成C，E更新成D，最后插入E，这样效率比较低。所以需要用key来给每一个结点做一个唯一标识，Diff算法就可以正确的识别此结点，找到正确的位置区插入新的结点。一句话总结，key的作用就是为了高效的更新虚拟DOM。</p>
<p>在Vue中，数据是响应式的，Vue会实时监听数据的变化，当数据变化时，会先改变虚拟DOM，然后虚拟DOM改变真实DOM，在网页上看到的显示就会改变。</p>
<p>push pop shift unshift splice sort reverse这些方法是支持响应式的。</p>
<p>push 从最后插入元素 ，可以一次加好几个</p>
<p>pop 从最后删除元素</p>
<p>shift 删除第一个元素</p>
<p>unshift 在数组最前面添加元素，可以一次加好几个</p>
<p>splice可以删除/插入/替换元素。第一个参数代表要从哪个位置开始进行操作，这个是必须要传入的。第二个参数代表一直删除到哪个位置，如果不写默认一直删除到最后。如果准备替换的话，第二个参数表示要替换几个元素。再往后传若干个值，会先按删除做，然后把那些值加进去。如果准备添加，第二个参数置为0，后面写要插入的元素。</p>
<p>sort对数组排序</p>
<p>reverse对数组逆序</p>
<p>注意，直接通过索引值修改元素不是响应式的，应尽量避免这种操作。如果要修改元素要使用splice。或者使用set。</p>
<p>使用方式：<code>Vue.set(要修改的对象, 索引值, 修改后的值);</code></p>
<h2 id="搭建一个购物车页面"><a href="#搭建一个购物车页面" class="headerlink" title="搭建一个购物车页面"></a>搭建一个购物车页面</h2><p>这是一个关于图书购物车界面的实现方法。点击购买数量的加减可以修改购买数量，可以移除某一项，最后能算总价格。</p>
<p>思路比较简单。第一步先是界面搭建，把表格画出来。定好写死部分的内容，数据部分由于是动态的所以只需要把空格子画出来就可以。在js文件里写好数据，然后用v-for显示出各项数据（v-for放在tr而不是td），这样基本的显示就ok了。</p>
<p>第二步加入一个叫做过滤器的东西。为什么要加这个东西呢？显示价格需要保留两位小数，并且加入货币单位，这个操作可以进行复用。当然用method也是可以的，但是vue有一个专门处理这块效果的东西叫做filter，用它进行格式化输出。</p>
<p>第三步让它支持改变购买数量。向显示购买数量的单元格添加两个button，并且监听点击事件，如果要增加就让<code>this.books[index].count++</code>，如果要减少就让它–，但是要注意不能减到1以下，0也不行，所以要加入一个值是否大于1的判断。然后可以用v-bind动态修改一个disabled，当数量为1时禁用减按钮的点击。</p>
<p>第四步加入移除按钮事件和总价格计算。移除按钮要监听一个删除事件，但是不能直接用pop和shift，因为我也有可能在中间删除，所以用的是<code>this.books.splice(index,1);</code>。总价格计算使用计算属性，用let变量，然后就是简单的for循环统计价格，并且返回价格，然后用过滤器格式化输出。</p>
<p>第五步加入判定购物车为空，在table标签外面套一个div写v-if，判断books.length是不是0，如果是0就不显示那个div，显示v-else所在的div，这个div里显示购物车为空。</p>
<p>完成效果：</p>
<p><img src="https://s2.ax1x.com/2020/01/29/1QXq0O.png" alt="img"></p>
<p>购物车.html文件内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue购物车<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/style.css&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;books.length&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">th</span>&gt;</span>书籍名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">th</span>&gt;</span>出版日期<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">th</span>&gt;</span>价格<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">th</span>&gt;</span>购买数量<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in books&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.id&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.date&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.price | showPrice(item.price)&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement(index)&quot;</span> <span class="attr">:disabled</span>=<span class="string">&quot;item.count &lt;= 1&quot;</span>&gt;</span></span><br><span class="line">								-</span><br><span class="line">							<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">							&#123;&#123;item.count&#125;&#125;</span><br><span class="line">							<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment(index)&quot;</span>&gt;</span></span><br><span class="line">								+</span><br><span class="line">							<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;remove(index)&quot;</span>&gt;</span>移除<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">h3</span>&gt;</span>总价格：&#123;&#123;totPrice | showPrice(totPrice)&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">h2</span>&gt;</span>购物车为空<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/main.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>style.css文件内容：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e9e9e9</span>;</span><br><span class="line">	<span class="attribute">border-collapse</span>: collapse;</span><br><span class="line">	<span class="attribute">border-spacing</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">16px</span>;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#E9E9E9</span>;</span><br><span class="line">	<span class="attribute">text-align</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">th</span> &#123;</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="number">#f7f7f7</span>;</span><br><span class="line">	<span class="attribute">color</span>: <span class="number">#5c6b77</span>;</span><br><span class="line">	<span class="attribute">font-weight</span>: <span class="number">600</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.js文件内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">	data: &#123;</span><br><span class="line">		books: [</span><br><span class="line">			&#123;</span><br><span class="line">				id: <span class="number">1</span>,</span><br><span class="line">				name: <span class="string">&#x27;计算机组成原理&#x27;</span>,</span><br><span class="line">				date: <span class="string">&#x27;2008-01&#x27;</span>,</span><br><span class="line">				price: <span class="number">58.50</span>,</span><br><span class="line">				count: <span class="number">1</span>,</span><br><span class="line">			&#125;, &#123;</span><br><span class="line">				id: <span class="number">2</span>,</span><br><span class="line">				name: <span class="string">&#x27;计算机网络&#x27;</span>,</span><br><span class="line">				date: <span class="string">&#x27;2017-01&#x27;</span>,</span><br><span class="line">				price: <span class="number">26.80</span>,</span><br><span class="line">				count: <span class="number">1</span>,</span><br><span class="line">			&#125;, &#123;</span><br><span class="line">				id: <span class="number">3</span>,</span><br><span class="line">				name: <span class="string">&#x27;数据结构&#x27;</span>,</span><br><span class="line">				date: <span class="string">&#x27;2015-02&#x27;</span>,</span><br><span class="line">				price: <span class="number">30.80</span>,</span><br><span class="line">				count: <span class="number">1</span>,</span><br><span class="line">			&#125;, &#123;</span><br><span class="line">				id: <span class="number">4</span>,</span><br><span class="line">				name: <span class="string">&#x27;操作系统&#x27;</span>,</span><br><span class="line">				date: <span class="string">&#x27;2014-05&#x27;</span>,</span><br><span class="line">				price: <span class="number">35.80</span>,</span><br><span class="line">				count: <span class="number">1</span>,</span><br><span class="line">			&#125;, </span><br><span class="line">		],</span><br><span class="line">	&#125;,</span><br><span class="line">	computed: &#123;</span><br><span class="line">		totPrice() &#123;</span><br><span class="line">			<span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.books.length; i++) &#123;</span><br><span class="line">				sum += <span class="built_in">this</span>.books[i].price * <span class="built_in">this</span>.books[i].count;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> sum;</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	methods: &#123;</span><br><span class="line">		increment(index) &#123;</span><br><span class="line">			<span class="built_in">this</span>.books[index].count++;</span><br><span class="line">		&#125;,</span><br><span class="line">		decrement(index) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.books[index].count &gt; <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">this</span>.books[index].count--;</span><br><span class="line">		&#125;,</span><br><span class="line">		remove(index) &#123;</span><br><span class="line">			<span class="built_in">this</span>.books.splice(index,<span class="number">1</span>);</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	filters: &#123;</span><br><span class="line">		showPrice(price) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&#x27;￥&#x27;</span> + price.toFixed(<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="表单绑定v-model"><a href="#表单绑定v-model" class="headerlink" title="表单绑定v-model"></a>表单绑定v-model</h2><p>v-model里面写一个属性，这个属性在vue里面和表单是双向绑定的，改变表单的属性值，vue中存储的属性值也会变，反之亦然。</p>
<p>v-model相当于两个指令的结合，可以简单理解成先用v-bind绑定属性，这样动了属性的话表单的内容会动。要做到表单的内容动了也让属性动，要用v-on监听输入事件，每次输入都把输入的值传给属性，这样就实现了双向绑定。（可以把v-model理解成一个语法糖</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  上面这段代码等同于下面这段代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;message&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;message = $event.target.value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当存在单选框时，使用v-model=属性名，可以将单选框和某个属性绑定。使用v-model绑定同一个属性名可以代替name的互斥效果。</p>
<p>复选框的v-model表示true或者false，true为选了这一项，false为没选这一项。单个选项用一个属性值就行，多个的话就得用数组。数组内部就不是true或者false了，是选中项的value</p>
<p><img src="https://s2.ax1x.com/2020/01/31/18FluD.png" alt="img"></p>
<p>和checkbox一样，select也分单选和多选两种情况，单选只能绑定一个值，当选中option中的一个时，会将它对应的value赋值到mySelect中，多选的话可以选中多个值，绑定的是一个数组，当选中多个值时，就会将选中的option对应的value添加到数组中。要注意，v-model是写在select里面的，不是写在option里面的。要让select选择多个需要在select标签内加入multiple属性。</p>
<p>值绑定：给动态的value赋值。input标签里面的value有时不能写死，需要从服务器传回一些数据再显示，可以通过v-bind:value动态的给value绑定值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">v-for</span>=<span class="string">&quot;student in class7&quot;</span> <span class="attr">:for</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;student&quot;</span> <span class="attr">:id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;choose&quot;</span>/&gt;</span>&#123;&#123;student&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>选择参与人员：&#123;&#123;choose.toString()&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">		el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">		data: &#123;</span><br><span class="line">			class7: [</span><br><span class="line"><span class="javascript">				<span class="string">&#x27;黎恩&#x27;</span>, <span class="string">&#x27;亚莉莎&#x27;</span>, <span class="string">&#x27;艾玛&#x27;</span>, <span class="string">&#x27;艾利欧特&#x27;</span>,<span class="string">&#x27;尤西斯&#x27;</span>, </span></span><br><span class="line"><span class="javascript">				<span class="string">&#x27;盖乌斯&#x27;</span>, <span class="string">&#x27;劳拉&#x27;</span>, <span class="string">&#x27;菲&#x27;</span>, <span class="string">&#x27;马奇亚斯&#x27;</span>, <span class="string">&#x27;库洛&#x27;</span>, </span></span><br><span class="line"><span class="javascript">				<span class="string">&#x27;米莉亚姆&#x27;</span>,</span></span><br><span class="line">			],</span><br><span class="line">			choose: [],</span><br><span class="line">		&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>v-model的三个修饰符：</p>
<p>lazy修饰符：默认情况下，v-model是默认在input事件中同步输入框的数据的，也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变，lazy修饰符可以让数据在失去焦点或者用户点击回车时才进行更新。（懒加载）<code>v-model.lazy=&quot;xxx&quot;</code></p>
<p>number修饰符：当默认情况下，在输入框中无论输入的是字母还是数字，都会被当作字符串类型进行处理。但是如果希望被处理的是数字类型，那最好直接把内容当成数字处理。number修饰符可以让输入框中的内容自动转化为数字类型。<code>v-model.number=&quot;xxx&quot;</code></p>
<p>trim修饰符：如果输入的内容首尾有很多空格，通常我们希望将其去除，trim修饰符可以过滤内容左右两边的空格。<code>v-model.trim=&quot;xxx&quot;</code></p>
<h2 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h2><p>什么是组件化？如果我们将一个页面中所有的处理逻辑全部放在一起，处理起来会变得很复杂，而且不利于后续的管理以及扩展。但如果我们将一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就变得非常容易了。组件化是Vue.js中的重要思想，它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。任何的应用都会被抽象成一棵组件树。</p>
<p>组件的使用分成三个步骤：创建组件构造器，注册组件，使用组件。创建组件构造器使用的是Vue.extend()方法，注册组件使用的是Vue.component()方法，在Vue实例的作用范围内可以直接使用组件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">cpn</span>&gt;</span>里面的内容会被忽略掉！<span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">			<span class="comment">// 使用``构建换行字符串（ES6）</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">const</span> cpnC = Vue.extend(&#123;</span></span><br><span class="line">				template:`</span><br><span class="line"><span class="handlebars"><span class="xml">					<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">						<span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">						<span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">					<span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span></span><br><span class="line">			&#125;);</span><br><span class="line"><span class="javascript">			Vue.component(<span class="string">&#x27;cpn&#x27;</span>, cpnC);</span></span><br><span class="line"><span class="javascript">			<span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">				el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">				data: &#123;</span><br><span class="line">					</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>调用Vue.extend()创建的是一个组件构造器，通常在创建组件构造器时，传入template代表我们自定义组件的模板。该模板就是在使用到组件的地方，要显示的HTML代码。</p>
<p>调用Vue.component()是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称。所以需要传递两个参数：1. 注册组件的标签名，2. 组件构造器。</p>
<p>组件必须挂载在某个Vue实例下，否则它不会生效。上面代码注册的组件叫做全局组件，意味着可以在多个Vue的实例下面使用。有时候一个项目里面可能会有多个Vue实例，全局组件可以适用于全部实例。</p>
<p>局部组件是在Vue实例里面注册的，只能在这个实例里面使用。注意是注册而不是创建，创建还是在外面，在外面注册就是全局组件，在里面注册就是局部组件。局部组件写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">	data: &#123;&#125;,</span><br><span class="line">	components: &#123;</span><br><span class="line">		cpn: cpnC,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>组件之间存在父子关系。组件可以嵌套注册，嵌套注册后不会影响组件的层次关系，仍然可以在root中注册。（越级使用必须越级注册）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">cpn2</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn2</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">cpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn1</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">const</span> cpnC1 = Vue.extend(&#123;</span></span><br><span class="line">				template:`</span><br><span class="line"><span class="handlebars"><span class="xml">					<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">						<span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">						<span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">					<span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span></span><br><span class="line">			&#125;);</span><br><span class="line"><span class="javascript">			<span class="keyword">const</span> cpnC2 = Vue.extend(&#123;</span></span><br><span class="line">				template:`</span><br><span class="line"><span class="handlebars"><span class="xml">					<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">						<span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">						<span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">						<span class="tag">&lt;<span class="name">cpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn1</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">					<span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span></span><br><span class="line">				components: &#123;</span><br><span class="line">					cpn1: cpnC1,</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line"><span class="javascript">			<span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">				el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">				data: &#123;&#125;,</span><br><span class="line">				components: &#123;</span><br><span class="line">					cpn1: cpnC1,</span><br><span class="line">					cpn2: cpnC2,</span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>语法糖：extend一步可以省略，并入到components里面，简化代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">		el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">		data: &#123;&#125;,</span><br><span class="line">		components: &#123;</span><br><span class="line">			cpn2: &#123;</span><br><span class="line">				template:`</span><br><span class="line"><span class="handlebars"><span class="xml">					<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">						<span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">						<span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">						<span class="tag">&lt;<span class="name">cpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn1</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">					<span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span></span><br><span class="line">				components: &#123;</span><br><span class="line">					cpn1: &#123;</span><br><span class="line">						template:`</span><br><span class="line"><span class="handlebars"><span class="xml">							<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">								<span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">								<span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">							<span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span></span><br><span class="line">					&#125;,</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有父子嵌套关系的话还能用语法糖吗？可能8行。</p>
<p>如果组件代码很多很长会看起来很乱，有一种模板抽离的写法。第一种写法使用script标签，定一个id用来传给component注册，写法是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-template&quot;</span> <span class="attr">id</span>=<span class="string">&#x27;cpn&#x27;</span>&gt;</span></span><br><span class="line">html代码</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者写成</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&#x27;cpn&#x27;</span>&gt;</span></span><br><span class="line">html代码</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="组件化开发-1"><a href="#组件化开发-1" class="headerlink" title="组件化开发"></a>组件化开发</h2><p>在组件内的代码是不能访问vue实例里面的数据的，如果不想要写死的数据，可能会想到用mustache语法输出变量，但其实这样不可以。组件是一个单独功能模块的封装，这个模块有属于自己的HTML模板，也应该有属性自己的数据data。即使组件可以访问vue实例中的data，这就要把所有的数据都放在vue实例中，实例就会很臃肿。vue组件应该有自己保存数据的地方。</p>
<p>那么就在component里面加入一个data对象就可以了？仍然不可以。vue规定，组件的data必须是一个函数，不写成函数形式会报错。可以让这个data直接返回一个对象，在里面写各种数据，这样就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        title: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，组件中的data为什么必须是一个函数？考虑到组件的复用问题，一个组件可能要被用在多个位置，如果组件中保存的数据为同一份，那么就相当于无形中把这些所有组件的数据都共享了，多个组件使用同一块数据可能会导致隐性的bug，会产生一些“连锁反应”，明明我动的是这个组件，结果全部的组件都跟着动了，这有时候不是我们想要的。把data封装成函数有一个好处，每次申请组件实例的时候都会去调用这个data函数，每次调用都会返回一个对象，多次调用就会返回多个对象，多个对象之间是不同的，本质上是地址不相同（JavaScript不能取地址，这一点比较遗憾），所以这样做就能保证每一个组件的数据都是独立的。而method就不需要封装成函数，该怎么写就怎么写就可以，方法是可以共享的，这个没什么问题。（据说这是一个面试题）</p>
<h2 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h2><p>子组件是不能引用父组件或者Vue实例的数据的，但是在开发中，往往经常用到数据在层级之间传递的操作。比如显示商品列表，服务器的请求是在最上层发出的，返回的数据也会在最上层，但是一般来讲商品列表并不会在最上层（想一想，li会在最顶上那一层，挨着body吗，应该是不会的），这个时候并不需要让子组件再发送一次网络请求，而是让父组件将数据传递给子组件。vue中有两种方式提供父子组件的通信，比如通过props向子组件传递数据，或者通过事件向父组件发送消息。两种方式对应的传递顺序不一样，刚才举的例子是父组件向子组件传递信息，但是子组件也可以向父组件传递信息，这种时候就要用后者的传递方式。</p>
<p>tips：vue实例可以看作是一个根组件，或者说叫root组件。</p>
<p>props基本用法：在组件中，使用选项props来声明需要从父级接收到的数据。值有两种方式，一种叫字符串数组，数组中的字符串就是传递时的名称。一种叫对象，对象可以设置传递时的类型，也可以设置默认值等。</p>
<p>注册组件后，使用props属性，值是一个数组，传入想要通信的数据的名字，在html代码里面的对应组件内，使用v-bind绑定属性，就可以实现父组件到子组件的通信。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:cclass7</span>=<span class="string">&quot;newclass7&quot;</span> <span class="attr">:cmessage</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;cclass7.toString()&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;cmessage&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">const</span> cpn = &#123;</span></span><br><span class="line"><span class="javascript">				template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">				props: [<span class="string">&#x27;cclass7&#x27;</span>, <span class="string">&#x27;cmessage&#x27;</span>],</span></span><br><span class="line">				data() &#123;</span><br><span class="line"><span class="javascript">					<span class="keyword">return</span> &#123;&#125;;</span></span><br><span class="line">				&#125;,</span><br><span class="line">			&#125;;</span><br><span class="line"><span class="javascript">			<span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">				el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">				data: &#123;</span><br><span class="line"><span class="javascript">					message: <span class="string">&#x27;hello&#x27;</span>,</span></span><br><span class="line"><span class="javascript">					newclass7: [<span class="string">&#x27;尤娜&#x27;</span>, <span class="string">&#x27;库尔特&#x27;</span>, <span class="string">&#x27;亚尔缇娜&#x27;</span>, <span class="string">&#x27;亚修&#x27;</span>, <span class="string">&#x27;缪洁&#x27;</span>],</span></span><br><span class="line">				&#125;,</span><br><span class="line">				components: &#123;</span><br><span class="line">					cpn,</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>props还可以是一个对象，需要类型验证时就有用了。可以限定类型，设定默认值，以及设定是否必须传值。在一些较低的版本中，类型是对象或者数组时，默认值必须是一个函数，就像上面说的组件的data必须是一个函数那样，不过我使用的这个版本中这个限制貌似去掉了。在开发中对象形式使用的多一些。验证时使用自定义类型也是可以的，可以不用JavaScript的自带类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">	cmessage: &#123;</span><br><span class="line">		type: <span class="built_in">String</span>,</span><br><span class="line">		<span class="keyword">default</span>: <span class="string">&#x27;aaaaaa&#x27;</span>,</span><br><span class="line">		required: <span class="literal">true</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	cclass7: &#123;</span><br><span class="line">		type: <span class="built_in">Array</span>,</span><br><span class="line">		<span class="keyword">default</span>: [],</span><br><span class="line">		required: <span class="literal">true</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>需要注意：这里不能使用驼峰式命名法，因为html部分全都会被认作小写，而js对大小写敏感，会导致报错，但是可以使用连字符。</p>
<p>子组件向父组件传递的一般是事件，比如我在菜单栏中有很多物品分类选项，点击某个就会在页面上显示相关的推荐商品，这种时候就要子组件向父组件传递一个点击事件，告诉父组件用户点击了什么。此时需要用$emit发射事件。在父组件使用v-on接收事件后，再去父组件的method里面用一个方法处理事件即可。即子传父用的是自定义事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">cpn</span> @<span class="attr">itemclick</span>=<span class="string">&quot;cpnclick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> </span></span><br><span class="line"><span class="tag">						<span class="attr">v-for</span>=<span class="string">&quot;item in categories&quot;</span></span></span><br><span class="line"><span class="tag">						@<span class="attr">click</span>=<span class="string">&quot;btnclick(item)&quot;</span>&gt;</span></span><br><span class="line">						&#123;&#123;item.name&#125;&#125;</span><br><span class="line">				<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">const</span> cpn = &#123;</span></span><br><span class="line"><span class="javascript">				template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line">				data() &#123;</span><br><span class="line"><span class="javascript">					<span class="keyword">return</span> &#123;</span></span><br><span class="line">						categories: [</span><br><span class="line"><span class="javascript">							&#123;<span class="attr">id</span>: <span class="string">&#x27;a&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;热门推荐&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">							&#123;<span class="attr">id</span>: <span class="string">&#x27;b&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;手机数码&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">							&#123;<span class="attr">id</span>: <span class="string">&#x27;c&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;家用家电&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">							&#123;<span class="attr">id</span>: <span class="string">&#x27;d&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;电脑办公&#x27;</span>&#125;,</span></span><br><span class="line">						]</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				methods: &#123;</span><br><span class="line">					btnclick(item) &#123;</span><br><span class="line"><span class="javascript">						<span class="built_in">this</span>.$emit(<span class="string">&#x27;itemclick&#x27;</span>, item);</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"> 			&#125;;</span><br><span class="line"><span class="javascript">			<span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">				el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">				data: &#123;&#125;,</span><br><span class="line">				methods: &#123;</span><br><span class="line">					cpnclick(item) &#123;</span><br><span class="line"><span class="javascript">						<span class="built_in">console</span>.log(<span class="string">&#x27;cpnclick&#x27;</span>, item);</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				components: &#123;</span><br><span class="line">					cpn,</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>大体分三步，子组件发射，父组件读取，父组件处理。</p>
<h2 id="父子组件的通信-1"><a href="#父子组件的通信-1" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h2><p>vue官方不推荐v-model双向绑定到组件传递信息的props里面，默认props是父传子的单向传递，一般不可修改，不能绑定到props，需要修改的话应绑定到data。</p>
<p>watch属性可以用于监听某个属性值的改变，假设监听某个名字为x的属性值，那么监听的函数名字也要叫x，带一个参数代表改变后的值，然后可以增加一些操作。（这个写法实测有点bug，等老师讲到这里我再详细记录吧。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:cnum1</span>=<span class="string">&quot;num1&quot;</span> </span></span><br><span class="line"><span class="tag">				 <span class="attr">:cnum2</span>=<span class="string">&quot;num2&quot;</span> </span></span><br><span class="line"><span class="tag">				 @<span class="attr">num1change</span>=<span class="string">&quot;num1change&quot;</span></span></span><br><span class="line"><span class="tag">				 @<span class="attr">num2change</span>=<span class="string">&quot;num2change&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">h2</span>&gt;</span>props: &#123;&#123;cnum1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">h2</span>&gt;</span>data: &#123;&#123;dnum1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;dnum1&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;num1Input&quot;</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">h2</span>&gt;</span>props: &#123;&#123;cnum2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">h2</span>&gt;</span>data: &#123;&#123;dnum2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;dnum2&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;num2Input&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">				el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">				data: &#123;</span><br><span class="line">					num1: 0,</span><br><span class="line">					num2: 0,</span><br><span class="line">				&#125;,</span><br><span class="line">				methods: &#123;</span><br><span class="line">					num1change(value) &#123;</span><br><span class="line"><span class="javascript">						<span class="built_in">this</span>.num1 = <span class="built_in">parseInt</span>(value);</span></span><br><span class="line"><span class="javascript">						<span class="built_in">this</span>.num1 = value;</span></span><br><span class="line">					&#125;,</span><br><span class="line">					num2change(value) &#123;</span><br><span class="line"><span class="javascript">						<span class="built_in">this</span>.num2 = <span class="built_in">parseInt</span>(value);</span></span><br><span class="line"><span class="javascript">						<span class="built_in">this</span>.num2 = value;</span></span><br><span class="line">					&#125;,</span><br><span class="line">				&#125;,</span><br><span class="line">				components: &#123;</span><br><span class="line">					cpn: &#123;</span><br><span class="line"><span class="javascript">						template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line">						props: &#123;</span><br><span class="line"><span class="javascript">							cnum1: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="javascript">							cnum2: <span class="built_in">Number</span>,</span></span><br><span class="line">						&#125;,</span><br><span class="line">						data() &#123;</span><br><span class="line"><span class="javascript">							<span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">								dnum1: <span class="built_in">this</span>.num1 == <span class="literal">undefined</span> ? <span class="number">0</span> : <span class="built_in">this</span>.num1,</span></span><br><span class="line"><span class="javascript">								dnum2: <span class="built_in">this</span>.num2 == <span class="literal">undefined</span> ? <span class="number">0</span> : <span class="built_in">this</span>.num2,</span></span><br><span class="line">							&#125;</span><br><span class="line">						&#125;,</span><br><span class="line">						methods: &#123;</span><br><span class="line">							num1Input(event) &#123;</span><br><span class="line"><span class="javascript">								<span class="built_in">this</span>.dnum1 = event.target.value; <span class="comment">// 获取监听事件中传回的值</span></span></span><br><span class="line"><span class="javascript">								<span class="built_in">this</span>.$emit(<span class="string">&#x27;num1change&#x27;</span>, <span class="built_in">this</span>.dnum1); <span class="comment">// 子传父</span></span></span><br><span class="line"><span class="javascript">								<span class="built_in">this</span>.dnum2 = <span class="built_in">this</span>.dnum1 * <span class="number">100</span>;</span></span><br><span class="line"><span class="javascript">								<span class="built_in">this</span>.$emit(<span class="string">&#x27;num2change&#x27;</span>, <span class="built_in">this</span>.dnum2);</span></span><br><span class="line">								</span><br><span class="line">							&#125;,</span><br><span class="line">							num2Input(event) &#123;</span><br><span class="line"><span class="javascript">								<span class="built_in">this</span>.dnum2 = event.target.value;</span></span><br><span class="line"><span class="javascript">								<span class="built_in">this</span>.$emit(<span class="string">&#x27;num2change&#x27;</span>, <span class="built_in">this</span>.dnum2);</span></span><br><span class="line"><span class="javascript">								<span class="built_in">this</span>.dnum1 = <span class="built_in">this</span>.dnum2 * <span class="number">100</span>;</span></span><br><span class="line"><span class="javascript">								<span class="built_in">this</span>.$emit(<span class="string">&#x27;num2change&#x27;</span>, <span class="built_in">this</span>.dnum1);</span></span><br><span class="line">							&#125;,</span><br><span class="line">						&#125;,</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="父子组件的访问方式"><a href="#父子组件的访问方式" class="headerlink" title="父子组件的访问方式"></a>父子组件的访问方式</h2><p>有时候需要父组件直接访问子组件，子组件直接访问父组件，或者子组件访问根组件，就需要用此类方法。父组件访问子组件需要用<code>$children</code>或者<code>$refs</code>，子组件访问父组件使用<code>$parent</code>。</p>
<p><code>this.$children</code>是一个数组类型，它包含所有子组件对象。在访问多个子组件中的一个的时候需要使用到下标（数组嘛，有些时候这不太方便。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">				我是子组件</span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">				el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">				data: &#123;</span><br><span class="line"><span class="javascript">					message: <span class="string">&#x27;你好&#x27;</span>,</span></span><br><span class="line">				&#125;,</span><br><span class="line">				methods: &#123;</span><br><span class="line">					btnClick() &#123;</span><br><span class="line"><span class="javascript">						<span class="built_in">console</span>.log(<span class="built_in">this</span>.$children);</span></span><br><span class="line"><span class="javascript">						<span class="built_in">this</span>.$children[<span class="number">0</span>].showMessage();</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				components: &#123;</span><br><span class="line">					cpn: &#123;</span><br><span class="line"><span class="javascript">						template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line">						methods: &#123;</span><br><span class="line">							showMessage() &#123;</span><br><span class="line"><span class="javascript">								<span class="built_in">console</span>.log(<span class="string">&#x27;showCTRL&#x27;</span>);</span></span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过<code>$refs</code>拿东西的话就方便多了，它是一个对象类型，默认为空，只需要给想拿东西的某个组件加上一个ref=“名字”，然后像下面代码这样使用，就可以了。有点像<code>getElementById()</code>的感觉，用起来很方便。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">cpn</span> <span class="attr">ref</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">				我是子组件</span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">				el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">				data: &#123;</span><br><span class="line"><span class="javascript">					message: <span class="string">&#x27;你好&#x27;</span>,</span></span><br><span class="line">				&#125;,</span><br><span class="line">				methods: &#123;</span><br><span class="line">					btnClick() &#123;</span><br><span class="line"><span class="javascript">						<span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.test.name);</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				components: &#123;</span><br><span class="line">					cpn: &#123;</span><br><span class="line"><span class="javascript">						template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line">						methods: &#123;</span><br><span class="line">							showMessage() &#123;</span><br><span class="line"><span class="javascript">								<span class="built_in">console</span>.log(<span class="string">&#x27;showCTRL&#x27;</span>);</span></span><br><span class="line">							&#125;</span><br><span class="line">						&#125;,</span><br><span class="line">						data() &#123;</span><br><span class="line"><span class="javascript">							<span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">								name: <span class="string">&#x27;我是子组件的name，看到这条消息说明已成功访问&#x27;</span>,</span></span><br><span class="line">							&#125;;			</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还有一种子组件向上获取父组件的方法<code>$parent</code>，甚至可以<code>$root</code>直接获取根组件，但是不推荐这样使用，因为如果父组件没有获取的这种属性，就会报错，这样会提高组件的耦合度，降低重用性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是子组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">				el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">				data: &#123;</span><br><span class="line"><span class="javascript">					message: <span class="string">&#x27;你好&#x27;</span>,</span></span><br><span class="line">				&#125;,</span><br><span class="line">				methods: &#123;&#125;,</span><br><span class="line">				components: &#123;</span><br><span class="line">					cpn: &#123;</span><br><span class="line"><span class="javascript">						template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line">						methods: &#123;</span><br><span class="line">							btnClick() &#123;</span><br><span class="line"><span class="javascript">								<span class="built_in">console</span>.log(<span class="built_in">this</span>.$parent.message);</span></span><br><span class="line">							&#125;</span><br><span class="line">						&#125;,</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p>英文名slot，翻译为插槽（轨迹系列游戏中称为结晶回路插孔)，插槽的目的是让原来的设备具备更多的扩展性，比如电脑的USB接口，就能插很多外接设备。组件的插槽是为了让封装的组件更加具有扩展性，让使用者可以决定组件内部的的一些内容到底展示什么。比如移动网站中的导航栏，几乎每个页面都会用到导航栏，导航栏一般来说是封装成一个插件，一旦有了这个组件，就可以在多个页面复用了。但是，不同的页面之间导航栏也是不一样的，使用者可以决定组件到底以怎样的形式展示。</p>
<p>如何封装组件？它们也有很多区别，但是也有很多共性。如果每一个单独去封装一个组件，显然不合适。比如每个页面都返回的话，这部分内容我们就要重复去封装。如果封装成一个的话好像也不太合理。有些左侧是菜单，有些是返回，有些中间是搜索，有些中间是文字，等等。封装的基本原则是：抽取共性，保留不同。最好的封装方式就是将共性抽取到组件中，将不同暴露为插槽。一旦预留了插槽，就可以让使用者根据自己的需求，决定插槽中插入什么样的内容。无论是搜索框，导航栏，还是文字，还是按钮，由使用者自己决定。</p>
<p>使用<code>&lt;slot&gt;&lt;/slot&gt;</code>标签设定一个插槽，如果想在插槽里放东西，就在组件的标签里面写对应的HTML代码。</p>
<p>如果一种功能（比如插槽里插一个按钮）用的比较多，插得多的话就会导致代码复用率增加，降低代码量可以使用插槽默认值，让它如果什么也不插就默认是一个按钮。做法是在template里面的slot标签里写上默认值的代码，就ok了。如果有多个标签同时放入到组件进行替换时，会将全部进行替换。</p>
<p>当子组件的功能复杂时，插槽很可能是多个。那么在有多个插槽的时候，我怎么知道插入哪一个呢？这时候需要使用具名插槽，给插槽起个名字（name=“xxx”）就可以。替换某个东西的时候，加入属性slot=“相同的名字”，就可以插入相同名字的插槽。</p>
<p>使用插槽功能，可以封装功能性比较强的组件了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;left&quot;</span>&gt;</span>返回<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;center&quot;</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;right&quot;</span>&gt;</span>菜单<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">				el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">				data: &#123;&#125;,</span><br><span class="line">				methods: &#123;&#125;,</span><br><span class="line">				components: &#123;</span><br><span class="line">					cpn: &#123;</span><br><span class="line"><span class="javascript">						template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h2><p>组件中使用的变量首先会从其所在的实例中寻找，而不是先寻找组件中。模板中的代码里面的变量作用域就会去组件里寻找了，因为模板的作用域是组件而不是实例。官方给出了一条准则：父组件模板的所有东西都会在父级作用域里面编译，子组件模板的所有东西都会在子级作用域里面编译。</p>
<p>作用域插槽：父组件替换插槽的标签，但是内容由子组件来提供。比如子组件中包括一组数据，需要在多个页面进行展示，某些界面是水平方向的，某些界面是列表形式的，某些界面是直接展示一个数组的，内容在子组件，希望父组件告诉它如何展示，这种时候就需要利用slot作用域插槽。使用<code>&lt;template slot-scope=&quot;slotProps&quot;&gt;</code>就可以获取到slotProps属性，然后访问它的data就可以获取。（注意这个实例已经被废弃了，现在我写这个代码编译不过，不知道是写的问题还是弃用问题。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这段代码编译不过 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;slot&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;item in slot.data&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">slot</span> <span class="attr">:data</span>=<span class="string">&quot;lang&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in lang&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">				el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">				data: &#123;&#125;,</span><br><span class="line">				methods: &#123;&#125;,</span><br><span class="line">				components: &#123;</span><br><span class="line">					cpn: &#123;</span><br><span class="line"><span class="javascript">						template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line">					&#125;,</span><br><span class="line">					data() &#123;</span><br><span class="line"><span class="javascript">						<span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">							lang: [<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;C#&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;Go&#x27;</span>],</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;,</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h2><p>这其实是JavaScript发展成熟后生成的产物，模块化借鉴于后端的一些概念。JavaScript在早期使用时仅仅是用来制作一些简单动画或简单的表单验证，当时的代码量相对较少，直接将代码写在<code>&lt;script&gt;</code>标签里面即可。随着ajax异步请求的出现，慢慢地形成了前后端的分离。客户端需要完成的事情越来越多，代码量与日俱增。为了应对代码量的剧增，人们将JavaScript代码放在多个文件中进行维护，但仍然无法避免全局变量重名等各种麻烦的问题。即使变量名重复的问题可以通过闭包函数限制作用域解决，但这也降低了代码的复用性，会导致代码冗余。</p>
<p>（这样一想，大型项目使用原生JavaScript开发还是真的难顶）</p>
<p>原生的模块化也是通过各种语法模拟出来的，而且变量命名有很大的规矩限制，现在随着前端发展越来越完善，模块化开发也变得越来越流行，成熟度也越来越高。可以将需要暴露到外面的变量，使用一个模块作为出口。首先在匿名函数内部定义一个对象，给对象添加各种需要暴露在外面的属性和方法，不需要暴露的直接定义即可，最后将这个对象返回，并且在外面使用一个变量接收。在main.js当中只需要使用属于自己模块的属性和方法即可。这就是模块最基础的封装，事实上模块的封装还有很多高级操作。比较幸运的是，到目前为止，前端模块化已经有了很多既有的规范，以及对应的实现方案。常见的模块化规范有：CommonJS、AMD（和另一个AMD不一样hh、CMD，还有ES6的Modules。</p>
<p>模块化有两个核心，导出和导入。</p>
<h2 id="ES6模块化的导入和导出"><a href="#ES6模块化的导入和导出" class="headerlink" title="ES6模块化的导入和导出"></a>ES6模块化的导入和导出</h2><p>主要使用ES6中的两个核心关键字，一个叫导入export，一个叫导入import。</p>
<p>比如我想导出一些变量，可供他人使用，那么需要执行这两步。</p>
<p>首先需要在引入这个JavaScript的时候这样写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;路径&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，引入的这个js文件就被当作一个模块，module类型为它添加了一个限定作用域，限定所有的变量都在本文件下的作用域。</p>
<p>然后我操作了一些变量，可以导出了，使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Shawn Zhou&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">let</span> job = <span class="string">&quot;student&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;name, age, height&#125;</span><br></pre></td></tr></table></figure>

<p>如果有某个JavaScript文件想要引入我的这几个变量，首先需要在html文件中使用那个文件，和上面写法一样，也是加入module的type。然后在里面这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;name, age, job&#125; <span class="keyword">from</span> <span class="string">&quot;./路径&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>然后这些变量就可以正常使用了。</p>
<p>想要导出函数或者导出类，就在定义函数或定义类的时候前面加上export关键字就可以了。也可以先把函数或类定义好，然后再使用export导出。导入操作相同，然后就该咋用咋用。</p>
<p>某些情况下，一个模块中包含的某个功能，我们并不希望给这个功能命名，而是让导入者自己给它命名，这时候就可以使用export default。但是这种默认的定义只能存在一个。在导入的时候，把大括号去掉，里面写上自己想定义的名字，就可以了。</p>
<p>（所以怎么感觉还是不太方便</p>
<p>如果我们希望某个模块中所有的信息都导入，一个个导入显然有点麻烦，通过<em>可以导入模块中所有的export变量，但是通常情况下我们需要给</em>起一个别名，方便后续的使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> info <span class="keyword">from</span> <span class="string">&#x27;./info.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这样，info就变成了一个大对象，包含info.js里面的全部导出内容，然后使用成员访问运算符就可以访问到相应的成员变量或者成员函数。</p>
<h2 id="使用vue-cli构建项目"><a href="#使用vue-cli构建项目" class="headerlink" title="使用vue-cli构建项目"></a>使用vue-cli构建项目</h2><h2 id="配置项目"><a href="#配置项目" class="headerlink" title="配置项目"></a>配置项目</h2><p>假设现在已经装好vue-cli和webpack了，嗯。。</p>
<p>首先用<code>vue ui</code>命令打开图形管理界面，在选择好的路径里新建一个项目，类型我选了自定义，但是我没改设置就点了下一步（我也不知道那些插件是干啥的hh，有一说一，这个确实看起来很不错。</p>
<p>创建完之后是这样的</p>
<p><img src="https://s2.ax1x.com/2020/02/08/1W8eYQ.png" alt="img"></p>
<p>点进去就是这样的</p>
<p><img src="https://s2.ax1x.com/2020/02/08/1W8QO0.png" alt="img"></p>
<p>这里面可以管理插件，设置依赖，配置啥的。</p>
<p>然后我在git建了一个库，顺便试试部署，把链接clone到本地，然后把代码啥的复制进去，然后使用<code>git add .</code>把所有的文件加进去，再使用<code>git commit -m</code>和<code>git push</code>推到GitHub上面去了。我这样做其实麻烦了一步，有一个命令是可以直接在clone的时候clone到那个文件夹的。</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>一般来说，一个刚创建的vue项目的目录结构是怎样的呢？</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">vue-supermall</span><br><span class="line">|- .editorconfig</span><br><span class="line">|- .gitnore</span><br><span class="line">|- babel.config.js</span><br><span class="line">|- LICENSE</span><br><span class="line">|- package.json</span><br><span class="line">|- package-lock.json</span><br><span class="line">|- readme.md</span><br><span class="line">|- /.git</span><br><span class="line">|- /node_modules</span><br><span class="line">|- /public</span><br><span class="line">|- /src</span><br><span class="line">  |- App.vue</span><br><span class="line">  |- main.js</span><br><span class="line">  |- /assets</span><br><span class="line">  |- /components</span><br></pre></td></tr></table></figure>

<p>我以我这个项目为例吧，刚创建的时候是这样，在src文件夹内保存着我们的源代码，而外面的部分则是一些别的东西。那么，把src文件夹展开，现在的这个项目里面有什么呢？</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">|- /src</span><br><span class="line">  |- App.vue</span><br><span class="line">  |- main.js</span><br><span class="line">  |- /assets</span><br><span class="line">    |- logo.png</span><br><span class="line">  |- /components</span><br><span class="line">    |- HelloWorld.vue</span><br></pre></td></tr></table></figure>

<p>这是一个基本的helloworld项目，可以看出，assets里面包含着使用的资源，像是图片文件，css文件都会放在这里，所以便于管理的话，一般来说会为这些资源建立文件夹。components里面包含着项目使用的组件，但是如果组件比较多的话也不太方便维护，所以一般还会再建立一个和components文件夹同级的文件夹views，代表一些大的视图，比如主页视图home，分类视图categories。在components里面一般会放一些公共组件，比如很多页面都要用到某个组件，那就放在components里面。公共的组件里面还可以细分为common和content，common里面放置的是一些整体的公共组件，我这个项目用完下个项目还会用的那种，就是可以复用的组件。content里面放一些针对于当前项目业务的公共组件。有了common文件夹的话，下次再需要建立什么项目时，可以直接把这个文件夹拖过去，方便使用。</p>
<p>然后还有router路由相关，store是vuex的状态管理相关，network是网络相关，common放一些公共资源，像是公共的js文件。比如公共常量文件<code>const.js</code>·，公共工具文件<code>utils.js</code>，混入文件<code>mixin.js</code>。</p>
<p>一般来说，开发一个新项目的时候，生成完毕的第一步就是划分目录结构。经过刚才的操作，src文件夹变成了这样：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">|- /src</span><br><span class="line">  |- App.vue</span><br><span class="line">  |- main.js</span><br><span class="line">  |- /assets</span><br><span class="line">    |- css</span><br><span class="line">    |- js</span><br><span class="line">  |- /common</span><br><span class="line">    |- const.js</span><br><span class="line">    |- utils.js</span><br><span class="line">    |- mixin.js</span><br><span class="line">  |- /components</span><br><span class="line">    |- /common</span><br><span class="line">    |- /content</span><br><span class="line">  |- /network</span><br><span class="line">  |- /router</span><br><span class="line">  |- /store</span><br><span class="line">  |- /views</span><br><span class="line">    |- /home</span><br><span class="line">    |- /categories</span><br></pre></td></tr></table></figure>

<p>基本的目录结构大概就是如此，其实可以以这个基础再细分。</p>
<h2 id="引入CSS文件"><a href="#引入CSS文件" class="headerlink" title="引入CSS文件"></a>引入CSS文件</h2><p>GitHub上有一个css标准化的文件，叫做<code>normalize.css</code>，用于标准初始化css，我也整了一个，放在assets里面的css文件夹，当然还需要自己来做一个<code>base.css</code>的东西，用于自定义的一些初始化内容，比如可以写这个：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;./normalize.css&quot;</span>);</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但其实base.css也不会只有这些东西。</p>
<p>然后要怎样在项目中使用呢？在<code>app.vue</code>里面，这样写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="keyword">@import</span> url(<span class="string">&quot;assets/css/base.css&quot;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以使用伪类在根元素内定义变量（没错，CSS里面可以定义变量）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">	<span class="attribute">--color-text</span>: <span class="number">#666</span>;</span><br><span class="line">	<span class="attribute">--color-high-text</span>: <span class="number">#ff5777</span>;</span><br><span class="line">	<span class="attribute">--color-tint</span>: <span class="number">#ff8198</span>;</span><br><span class="line">	<span class="attribute">--color-background</span>: <span class="number">#fff</span>;</span><br><span class="line">	<span class="attribute">--font-size</span>: <span class="number">14px</span>;</span><br><span class="line">	<span class="attribute">--line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>text代表普通文本的颜色，high-text代表高亮文本的颜色，tint代表用到的背景色，毕竟背景色不会都是白色。</p>
<p>这样在使用这些变量的时候，这样写：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">font-size</span>: <span class="selector-tag">var</span>(<span class="selector-tag">--large-size</span>);</span><br></pre></td></tr></table></figure>

<p>在定义样式的时候，使用<code>less</code>或者<code>scss</code>这种偏冷门语法会更容易定义变量，根据需要可以直接选用，webpack会帮助打包成CSS。</p>
<p>我把教程里的CSS文件抄下来了，好像还能给我补充一些知识点。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;normalize.css&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">	<span class="attribute">--color-text</span>: <span class="number">#666</span>;</span><br><span class="line">	<span class="attribute">--color-high-text</span>: <span class="number">#ff5777</span>;</span><br><span class="line">	<span class="attribute">--color-tint</span>: <span class="number">#ff8198</span>;</span><br><span class="line">	<span class="attribute">--color-background</span>: <span class="number">#fff</span>;</span><br><span class="line">	<span class="attribute">--font-size</span>: <span class="number">14px</span>;</span><br><span class="line">	<span class="attribute">--line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">	<span class="attribute">font-family</span>: <span class="string">&quot;Helvetica Neue&quot;</span>, helvetica, <span class="string">&quot;PingFang SC&quot;</span>, <span class="string">&quot;Hiragino Sans GB&quot;</span>,<span class="string">&quot;Microsoft yahei&quot;</span>,<span class="string">&quot;微软雅黑&quot;</span>,Arial, sans-serif;</span><br><span class="line">	<span class="attribute">user-select</span>: none; <span class="comment">/* 禁止用户鼠标在页面上选中文字或图片 */</span></span><br><span class="line">	<span class="attribute">-webkit-tap-highlight-color</span>: transparent; </span><br><span class="line">	<span class="comment">/* webkit是苹果浏览器引擎,tap点击,highlight背景高亮,color颜色,颜色用数值调节 */</span></span><br><span class="line">	<span class="attribute">background</span>: <span class="built_in">var</span>(--color-background);</span><br><span class="line">	<span class="attribute">color</span>: <span class="built_in">var</span>(--color-text);</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">	<span class="comment">/* vw是css3中的一个新的长度单位,是view width的简写,指可视窗口的宽度.假如宽度是1200px的话,那10vw就是120px */</span></span><br><span class="line">	<span class="comment">/* 此外,还有vh,指可视窗口的高度. */</span></span><br><span class="line">	<span class="comment">/* 百分之几的长和百分之几的宽,可以这么理解 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">	<span class="attribute">color</span>: <span class="built_in">var</span>(--color-text);</span><br><span class="line">	<span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clear-fix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">	<span class="attribute">clear</span>: both;</span><br><span class="line">	<span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="attribute">display</span>: block;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clear-fix</span> &#123;</span><br><span class="line">	<span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">	<span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">	<span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>css3学习笔记</title>
    <url>/2020/01/19/css3/</url>
    <content><![CDATA[<p>这里记载了关于CSS3相关的学习笔记，该部分内容是曾在2020年发布的。</p>
<p>当前博客显示的发布时间非真实时间，而是这些内容在当时发布时的最后发布时间。</p>
<p><img src="https://i.loli.net/2018/11/19/5bf2966b32e00.jpg"></p>
<a id="more"></a>

<h2 id="CSS3-边框"><a href="#CSS3-边框" class="headerlink" title="CSS3 边框"></a>CSS3 边框</h2><p>通过CSS3可以创建圆角边框，向矩形添加阴影，还可以使用图片来绘制边框，不需要借助PS就能完成这些操作。</p>
<p>可能用到的有<code>border-radius</code>（这个在之前的开发中经常用到）,<code>box-shadow</code>，还有<code>border-image</code>。</p>
<p>IE9及以上版本支持前两者，火狐，Chrome，Safari支持全部的属性。</p>
<p>以<code>moz-</code>，<code>ms-</code>，<code>webkit-</code>开头的属性是为了兼容更多浏览器的，效果和不加此前缀的一样。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>testdw<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span>  </span><br><span class="line"><span class="css">		<span class="selector-class">.box1</span> &#123;  </span></span><br><span class="line">			text-align: center;  </span><br><span class="line">			line-height: 50px;  </span><br><span class="line">			width: 200px;  </span><br><span class="line">			height: 50px;  </span><br><span class="line"><span class="css">			<span class="selector-tag">border</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#0BDC57</span>;  </span></span><br><span class="line">			border-radius: 30px;  </span><br><span class="line">		&#125;  </span><br><span class="line"><span class="css">		<span class="selector-class">.box2</span> &#123;  </span></span><br><span class="line">			text-align: center;  </span><br><span class="line">			width: 200px;  </span><br><span class="line">			height: 100px;  </span><br><span class="line">			line-height: 100px;  </span><br><span class="line">			border: 2px solid pink;  </span><br><span class="line">			background: pink;  </span><br><span class="line">			margin-top: 20px;  </span><br><span class="line"><span class="css">			<span class="selector-tag">box-shadow</span>: 10<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> <span class="selector-id">#888</span>;  </span></span><br><span class="line"><span class="css">			<span class="comment">/*	参数一：左右偏移量	*/</span>  </span></span><br><span class="line"><span class="css">			<span class="comment">/*	参数二：上下偏移量	*/</span>  </span></span><br><span class="line"><span class="css">			<span class="comment">/*	参数三：模糊半径	*/</span>  </span></span><br><span class="line"><span class="css">			<span class="comment">/*	参数四：阴影颜色	*/</span>  </span></span><br><span class="line">		&#125;  </span><br><span class="line"><span class="css">		<span class="selector-class">.box3</span> &#123;  </span></span><br><span class="line">			text-align: center;  </span><br><span class="line">			margin-top: 20px;  </span><br><span class="line">			width: 200px;  </span><br><span class="line">			height: 50px;  </span><br><span class="line">			line-height: 50px;		  </span><br><span class="line">			border: 15px solid transparent;  </span><br><span class="line">			border-image: url(https://www.runoob.com/images/border.png) 30 30 round;  </span><br><span class="line"><span class="css">			<span class="comment">/*	设置图片边框必须先设置边框属性，把边框的宽度设出来，颜色设为透明	*/</span>  </span></span><br><span class="line">			  </span><br><span class="line">		&#125;  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>  </span><br><span class="line">		这是一个圆角效果  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>  </span><br><span class="line">		这是一个阴影效果  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span>  </span><br><span class="line">		这是一个图片边框效果  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>吐槽：Dreamweaver不太好使，可能是我不会用，也可能是它真的不好使</p>
<h2 id="CSS3-背景"><a href="#CSS3-背景" class="headerlink" title="CSS3 背景"></a>CSS3 背景</h2><p>CSS3包含多个新的背景属性，提供对背景更强大的控制。</p>
<p><code>background-size</code>与<code>background-origin</code>这两个属性对IE9以上支持，火狐，Chrome，Safari，Opera支持。</p>
<p>前者用于控制背景图大小，常用。</p>
<p>后者用于相对内容框来定位背景图像，这个属性规定<code>background-position</code>属性相对于什么位置来定位。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS3背景<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span>  </span><br><span class="line">			div &#123;  </span><br><span class="line">				border: 1px solid black;  </span><br><span class="line">				padding: 35px;  </span><br><span class="line">				background-image: url(img/11.png);  </span><br><span class="line">				background-repeat: no-repeat;  </span><br><span class="line">				background-position: left;  </span><br><span class="line">				background-size: 10% 50%;  </span><br><span class="line">				margin-top: 10px;  </span><br><span class="line">			&#125;  </span><br><span class="line"><span class="css">			<span class="selector-class">.box1</span> &#123;  </span></span><br><span class="line">				background-origin: border-box;  </span><br><span class="line">			&#125;  </span><br><span class="line"><span class="css">			<span class="selector-class">.box2</span> &#123;  </span></span><br><span class="line">				background-origin: content-box;  </span><br><span class="line">			&#125;  </span><br><span class="line"><span class="css">			<span class="selector-class">.box3</span> &#123;  </span></span><br><span class="line">				background-origin: padding-box;  </span><br><span class="line">			&#125;  </span><br><span class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>  </span><br><span class="line">			测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<span class="tag">&lt;<span class="name">br</span>&gt;</span>  </span><br><span class="line">			测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<span class="tag">&lt;<span class="name">br</span>&gt;</span>  </span><br><span class="line">			测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<span class="tag">&lt;<span class="name">br</span>&gt;</span>  </span><br><span class="line">			测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<span class="tag">&lt;<span class="name">br</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span>  </span><br><span class="line">			测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<span class="tag">&lt;<span class="name">br</span>&gt;</span>  </span><br><span class="line">			测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<span class="tag">&lt;<span class="name">br</span>&gt;</span>  </span><br><span class="line">			测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<span class="tag">&lt;<span class="name">br</span>&gt;</span>  </span><br><span class="line">			测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<span class="tag">&lt;<span class="name">br</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span>  </span><br><span class="line">			测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<span class="tag">&lt;<span class="name">br</span>&gt;</span>  </span><br><span class="line">			测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<span class="tag">&lt;<span class="name">br</span>&gt;</span>  </span><br><span class="line">			测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<span class="tag">&lt;<span class="name">br</span>&gt;</span>  </span><br><span class="line">			测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试测试<span class="tag">&lt;<span class="name">br</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<h2 id="CSS3-添加文本效果"><a href="#CSS3-添加文本效果" class="headerlink" title="CSS3 添加文本效果"></a>CSS3 添加文本效果</h2><p><code>text-shadow</code>为文本添加阴影，参数与边框阴影的相同。</p>
<p><code>word-wrap</code>确定单词换行方式，当一行单词过长而恰好输出到边框边缘时，过长部分会越过边框进行输出，打破盒模型规范。使用<code>word-wrap: break-word;</code>可以把过长的单词换行显示。</p>
<p>与前面不同，这两个属性在IE10以上才会起作用，其他浏览器则全部支持。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS3背景<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span>  </span><br><span class="line">			h1 &#123;  </span><br><span class="line"><span class="css">				<span class="selector-tag">text-shadow</span>: 10<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> 5<span class="selector-tag">px</span> <span class="selector-id">#333</span>;  </span></span><br><span class="line">			&#125;  </span><br><span class="line"><span class="css">			<span class="selector-class">.box1</span> &#123;  </span></span><br><span class="line">				width: 200px;  </span><br><span class="line">				height: 400px;  </span><br><span class="line"><span class="css">				<span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#49FF33</span>;  </span></span><br><span class="line">				word-wrap: break-word;  </span><br><span class="line">			&#125;  </span><br><span class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span>&gt;</span>测试标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>  </span><br><span class="line">			qw er ty ui op qw er ty uiwerwfsdfsdghrsthdfgdfssdfhsegdfg op qw er ty ui op qw er ty ui op qw er ty ui op qw er ty ui op qw er ty ui op   </span><br><span class="line">			qw er ty ui op qw er ty ui op qw er ty ui op qw er ty ui op qw er ty ui op qw er ty ui op qw er ty ui op   </span><br><span class="line">			qw er ty ui op qw er ty ui op qw er ty ui op qw er ty ui op qw er ty ui op qw er ty ui op qw er ty ui op   </span><br><span class="line">			qw er ty ui op qw er ty ui op qw er ty ui op qw er ty ui op qw er ty ui op qw er ty ui op qw er ty ui op   </span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>使用下面的操作可以使用网络字体，在url里面填写对应的字体地址即可。</p>
<p>不过现在网络上的在线字库也有用SDK提供接口的，一般也都会给接入教程。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS3字体<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span>  </span><br><span class="line"><span class="css">			<span class="keyword">@font-face</span> &#123;  </span></span><br><span class="line">				font-family: test;  </span><br><span class="line">				src: url(&quot;&quot;);  </span><br><span class="line">			&#125;  </span><br><span class="line">			div &#123;  </span><br><span class="line">				font-family: test;  </span><br><span class="line">			&#125;  </span><br><span class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span>  </span><br><span class="line">			test  </span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<h2 id="CSS3-2D效果"><a href="#CSS3-2D效果" class="headerlink" title="CSS3 2D效果"></a>CSS3 2D效果</h2><p>通过CSS3转换，可以对元素进行移动translate、缩放rotate、转动 scale、拉长skew、拉伸matrix。</p>
<p>IE10+，火狐，Opera支持这些2D效果。</p>
<p>Chrome和Safari需要添加<code>-webkit-</code></p>
<p>IE9需要添加<code>-ms-</code></p>
<p>比如<code>-webkit-transform: rotate(30deg)</code>就是让它顺时针旋转30度。</p>
<p>API在菜鸟教程都能查到，我就先略过了。</p>
<h2 id="CSS3-3D效果与过渡"><a href="#CSS3-3D效果与过渡" class="headerlink" title="CSS3 3D效果与过渡"></a>CSS3 3D效果与过渡</h2><p>3D效果对浏览器的要求和2D效果一样，属性名还是<code>transform</code>。使用<code>rotateX()</code>和<code>rotateY()</code>控制X和Y方向的变化，参数还是角度。</p>
<p>通过CSS3，可以在不使用Flash或者JS的情况下，当元素从一种样式变换到另一种样式时为元素添加效果。</p>
<p>过渡效果对于IE10以上，火狐，Chrome，Opera是支持的，对于Safari需要加<code>-webkit-</code>。要实现过渡，需要确定希望把效果添加到哪个CSS属性上，并规定时长。</p>
<p>基本格式：<code>transition: 属性名 变化时间;</code>，指定多个时，一个属性名对应一个变化时间算一对，多对之间逗号隔开。</p>
<p>当事件发生（鼠标浮上，鼠标点击等）时，改变对应的属性，就能以动画的形式进行变化，而不是瞬间变化，这里可能需要用到<code>:hover</code>等选择器。</p>
<h2 id="CSS3-动画"><a href="#CSS3-动画" class="headerlink" title="CSS3 动画"></a>CSS3 动画</h2><p>使用<code>@keyframes</code>规则创建动画，在里面规定某项CSS样式，就能创建由当前样式逐渐改为新样式的动画效果。</p>
<p>IE10以上，火狐，Opera支持这个规则和<code>animation</code>属性，Chrome和Safari需要加<code>-webkit-</code>。</p>
<p>然后用<code>animation</code>调用刚才创建的动画就可以。通过至少规定动画的名称和时长这两个属性，就能将动画绑定到选择器。</p>
<p>使用一些关键字来区分阶段，它是不同于过渡的。过渡效果是简单的从一个变为另一个，而动画可以有不同的阶段，比如各种百分比阶段的时候操作是怎样的。不同的阶段可能会有不同的操作。当然也可以简单的使用from和to实现从一个变为另一个。</p>
<p>理论上讲，这是一个很强大的功能，可以用来做各种炫酷的骚气的网页动画，这部分内容值得深究。</p>
<h2 id="CSS3-多列"><a href="#CSS3-多列" class="headerlink" title="CSS3 多列"></a>CSS3 多列</h2><p>对文本进行多列布局，像报纸那样。word里面也有对应类似的功能（分栏）。</p>
<p>（其实这玩意用盒模型也能写的出来，就是麻烦，用多列做会方便一些）</p>
<p>属性有<code>column-count</code>确定分多少列，<code>column-gap</code>确定分隔宽度，<code>column-role</code>设定分栏样式等等</p>
<p>IE10以上和Opera支持多列，火狐需要<code>-moz-</code>，Chrome和Safari需要<code>-webkit-</code></p>
]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>html5学习笔记</title>
    <url>/2020/01/14/html5/</url>
    <content><![CDATA[<p>这里记载了关于HTML5相关的学习笔记，该部分内容是曾在2020年发布的。</p>
<p>当前博客显示的发布时间非真实时间，而是这些内容在当时发布时的最后发布时间。</p>
<p><img src="https://i.loli.net/2020/04/02/JR8cbUE39LtwPeT.jpg"></p>
<a id="more"></a>

<h2 id="H5音频"><a href="#H5音频" class="headerlink" title="H5音频"></a>H5音频</h2><p>HTML5提供了播放音频文件的标准，control属性供添加播放，暂停和音量控件。</p>
<p><code>&lt;audio&gt;</code>定义声音，<code>&lt;source&gt;</code>规定多媒体资源，可以是多个</p>
<p>使用src属性为audio标签提供资源，<code>controls=“controls”</code>提供控制控件</p>
<p>注意audio是双标签，中间的内容可以是“浏览器不支持”之类的话，代表浏览器无法解析这个标签，如果浏览器可以解析audio标签，则在页面里显示播放器。</p>
<p>有些浏览器对mp3等格式支持不是很好，可以这样解决：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;1.mp3&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;1.ogg&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>使用source标签提供资源。</p>
<h2 id="H5视频"><a href="#H5视频" class="headerlink" title="H5视频"></a>H5视频</h2><p>以前的时候，在浏览器中播放视频需要借助flash插件，现在随着flash慢慢淡出舞台，H5视频应运而生。flash插件播放视频有诸多不便，H5播放视频就可以解决这些问题。</p>
<p><code>&lt;video&gt;</code>定义视频，<code>&lt;source&gt;</code>规定多媒体资源，可以是多个，有两个属性，width和height定义宽高。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300px&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500px&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;1.mp4&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;1.webm&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span>  </span><br></pre></td></tr></table></figure>



<h2 id="H5拖放"><a href="#H5拖放" class="headerlink" title="H5拖放"></a>H5拖放</h2><p>拖放是一种常见的特性，即抓取对象以后拖到另一个位置。IE9以上，火狐，Opera12以上，Chrome以及Safari5以上支持拖放。</p>
<p>使用<code>draggable=&quot;true&quot;</code>设置元素为可拖放，使用<code>ondragstart</code>和<code>setData()</code>设置拖动什么，使用<code>ondragover</code>设置放到何处，使用<code>ondrop</code>进行放置。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>fuck<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span>  </span><br><span class="line"><span class="css">			<span class="selector-id">#div1</span> &#123;  </span></span><br><span class="line">				width: 300px;  </span><br><span class="line">				height: 300px;  </span><br><span class="line">				border: 1px solid black;  </span><br><span class="line">			&#125;  </span><br><span class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span>  </span><br><span class="line"><span class="javascript">			<span class="function"><span class="keyword">function</span> <span class="title">allowDrop</span>(<span class="params">ev</span>) </span>&#123;  </span></span><br><span class="line"><span class="javascript">				ev.preventDefault(); <span class="comment">// 阻止浏览器的默认事件  </span></span></span><br><span class="line">			&#125;  </span><br><span class="line"><span class="javascript">			<span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">ev</span>) </span>&#123;  </span></span><br><span class="line"><span class="javascript">				ev.dataTransfer.setData(<span class="string">&quot;Text&quot;</span>,ev.target.id); <span class="comment">// 定位控制元素  </span></span></span><br><span class="line">			&#125;  </span><br><span class="line"><span class="javascript">			<span class="function"><span class="keyword">function</span> <span class="title">drop</span>(<span class="params">ev</span>) </span>&#123;  </span></span><br><span class="line">				ev.preventDefault();  </span><br><span class="line"><span class="javascript">				<span class="keyword">var</span> data = ev.dataTransfer.getData(<span class="string">&quot;Text&quot;</span>);  </span></span><br><span class="line"><span class="javascript">				ev.target.appendChild(<span class="built_in">document</span>.getElementById(data));<span class="comment">// 放置  </span></span></span><br><span class="line">			&#125;  </span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span>&gt;</span>请拖动图片<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span> <span class="attr">ondrop</span>=<span class="string">&quot;drop(event)&quot;</span> <span class="attr">ondragover</span>=<span class="string">&quot;allowDrop(event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/11.png&quot;</span> <span class="attr">id</span>=<span class="string">&quot;d1&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ondragstart</span>=<span class="string">&quot;drag(event)&quot;</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<h2 id="H5-canvas"><a href="#H5-canvas" class="headerlink" title="H5 canvas"></a>H5 canvas</h2><p>画布是一个矩形区域，可以控制它的每一个像素。</p>
<p>canvas拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。但注意，canvas只是画布，不是画笔，只用于承载画面。</p>
<p>需要画笔操作的话，使用js控制。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>canvas<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;can&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span>  </span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&quot;can&quot;</span>);  </span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> cxt = c.getContext(<span class="string">&quot;2d&quot;</span>); <span class="comment">// 确定以2D方式绘制  </span></span></span><br><span class="line"><span class="javascript">			cxt.fillStyle = <span class="string">&quot;#0000FF&quot;</span>; <span class="comment">// 确定绘制颜色  </span></span></span><br><span class="line"><span class="javascript">			cxt.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>); <span class="comment">// 绘制一个矩形  </span></span></span><br><span class="line">			  </span><br><span class="line"><span class="javascript">			cxt.beginPath(); <span class="comment">//绘制圆使用,路径开始  </span></span></span><br><span class="line"><span class="javascript">			cxt.arc(<span class="number">200</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="built_in">Math</span>.PI*<span class="number">2</span>,<span class="literal">true</span>); <span class="comment">// 绘制圆  </span></span></span><br><span class="line"><span class="javascript">			cxt.closePath(); <span class="comment">// 记得再关闭路径  </span></span></span><br><span class="line"><span class="javascript">			cxt.fill(); <span class="comment">// 绘制图形输出到屏幕  </span></span></span><br><span class="line">			  </span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> img = <span class="keyword">new</span> Image(); <span class="comment">// 绘制图片的变量初始化  </span></span></span><br><span class="line"><span class="javascript">			img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 当图片加载完毕时才绘制  </span></span></span><br><span class="line"><span class="javascript">				cxt.drawImage(img,<span class="number">200</span>,<span class="number">200</span>); <span class="comment">// 绘制图像  </span></span></span><br><span class="line">			&#125;  </span><br><span class="line"><span class="javascript">			img.src = <span class="string">&quot;img/right.png&quot;</span>; <span class="comment">// 图片资源位置  </span></span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>  H5 SVG</p>
<p>什么是SVG？它指可伸缩矢量图形（Scalable Vector<br>Graphics），用于定义在网络上使用的矢量图形，它使用XML格式定义图形，在放大或者改变尺寸的情况下图形质量不会受到损失，SVG是万维网联盟的标准。</p>
<p>与其他图像格式相比，SVG的优势在于：</p>
<ul>
<li>它可以被文本编辑器创建和修改</li>
<li>可被搜索，索引，脚本化或压缩</li>
<li>SVG可伸缩</li>
<li>可在任何分辨率下高质量打印</li>
<li>可在图像质量不下降的情况下被放大</li>
</ul>
<p>IE9以上，火狐，Opera，Chrome以及Safari都支持内联SVG。</p>
<p>在<a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element">https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element</a><br>上可以找到大量SVG图形的API，还可以看到各个浏览器的兼容性信息。</p>
<p>使用.svg后缀的文件为矢量图形文件，内部代码即是SVG代码，方便图形重用。</p>
<p>使用<code>&lt;iframe src=&quot;svg.svg&quot; width=&quot;150px&quot; height=&quot;150px&quot; frameborder=&quot;no&quot;&gt;&lt;/iframe&gt;</code>就可以显示一个svg文件的图形。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>SVG<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewbox</span>=<span class="string">&quot;0 0 120 120&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span>  </span><br><span class="line">			<span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;60&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;60&quot;</span> <span class="attr">r</span>=<span class="string">&quot;50&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">circle</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;/<span class="name">svg</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewbox</span>=<span class="string">&quot;0 0 120 120&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span>  </span><br><span class="line">			<span class="tag">&lt;<span class="name">polygon</span> <span class="attr">points</span>=<span class="string">&quot;60,20 100,40 100,80 60,100 20,80 20,40&quot;</span>/&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;/<span class="name">svg</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<h2 id="H5-地理定位"><a href="#H5-地理定位" class="headerlink" title="H5 地理定位"></a>H5 地理定位</h2><p>在用户允许的情况下，使用H5的Geolocation<br>API获取用户的地理位置。IE9以上，火狐，Chrome，Safari以及Opera支持地理定位，如果设备支持GPS，则地理定位会更加精确，所以它对手机的支持相对好一些。</p>
<p>这个示例代码使用的是谷歌地图，由于某些原因测试不出来。国内的地图倒是有提供的api，做的挺完善，如果有需求可以去调用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>地理定位<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://maps.google.com/maps/api/js?sensor=false&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span>  </span><br><span class="line"><span class="javascript">			<span class="comment">// 获取当前地理位置  </span></span></span><br><span class="line"><span class="javascript">			<span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;  </span></span><br><span class="line"><span class="javascript">				navigator.geolocation.getCurrentPosition(<span class="function"><span class="keyword">function</span>(<span class="params">position</span>) </span>&#123;  </span></span><br><span class="line"><span class="javascript">					<span class="comment">// 设定地图参数,将用户当前的地理经纬度设置为地图中心点  </span></span></span><br><span class="line"><span class="javascript">					<span class="keyword">var</span> coords = position.coords;  </span></span><br><span class="line"><span class="javascript">					<span class="keyword">var</span> latlng = <span class="keyword">new</span> google.maps.LatLng(coords.latitude, coords.longitude);  </span></span><br><span class="line"><span class="javascript">					<span class="keyword">var</span> myOptions = &#123;  </span></span><br><span class="line">						zoom : 14,  </span><br><span class="line">						center : latlng,  </span><br><span class="line">						mapTypeId: google.maps.MapTypeId.ROADMAP  </span><br><span class="line">					&#125;  </span><br><span class="line"><span class="javascript">					<span class="comment">// 创建地图并在div中显示  </span></span></span><br><span class="line"><span class="javascript">					<span class="keyword">var</span> map1;  </span></span><br><span class="line"><span class="javascript">					map1 = <span class="keyword">new</span> google.maps.Map(<span class="built_in">document</span>.getElementById(<span class="string">&quot;map&quot;</span>),myOptions);  </span></span><br><span class="line"><span class="javascript">					<span class="comment">// 地图上创建标记  </span></span></span><br><span class="line"><span class="javascript">					<span class="keyword">var</span> marker = <span class="keyword">new</span> google.maps.InfoWindow(&#123;  </span></span><br><span class="line"><span class="javascript">						content : <span class="string">&quot;当前位置&quot;</span>  </span></span><br><span class="line">					&#125;)  </span><br><span class="line">					infowindow.open(map1, marker);  </span><br><span class="line">				&#125;)  </span><br><span class="line">				  </span><br><span class="line">			&#125;  </span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;map&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 2000px; height: 1000px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<h2 id="H5-Web存储"><a href="#H5-Web存储" class="headerlink" title="H5 Web存储"></a>H5 Web存储</h2><p>HTML5提供了两种在客户端存储数据的新方法：<code>localStorage</code>是没有时间限制的数据存储，一年以后数据仍可使用。<code>sessionStorage</code>是针对一个session的数据存储。之前数据存储是由cookie来完成的，但是cookie不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得cookie速度很慢而且效率也不高。</p>
<p>使用<code>localStorage</code>对数据进行存储是可以保存很长时间的，当浏览器关闭或刷新页面时输入的数据不会消失，而是会保存在<code>localStorage</code>里面。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>web存储<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span>  </span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> ta;  </span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> btn;  </span></span><br><span class="line"><span class="javascript">			<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span></span><br><span class="line"><span class="javascript">				ta = <span class="built_in">document</span>.getElementById(<span class="string">&quot;ta&quot;</span>);  </span></span><br><span class="line"><span class="javascript">				<span class="keyword">if</span> (<span class="built_in">localStorage</span>.text) &#123;  </span></span><br><span class="line"><span class="javascript">					ta.value = <span class="built_in">localStorage</span>.text;  </span></span><br><span class="line">				&#125;  </span><br><span class="line"><span class="javascript">				btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>);  </span></span><br><span class="line"><span class="javascript">				btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span></span><br><span class="line"><span class="javascript">					<span class="built_in">localStorage</span>.text = ta.value;  </span></span><br><span class="line">				&#125;  </span><br><span class="line">			&#125;  </span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span> <span class="attr">id</span>=<span class="string">&quot;ta&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>save<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p><code>sessionStorage</code>方法针对一个会话进行数据存储，当用户关闭当前浏览器窗口，数据就会被删除。以下代码展示了一个简单的累加器。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>web存储<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span>  </span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> num = <span class="number">0</span>;  </span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> txt;  </span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> btn;  </span></span><br><span class="line"><span class="javascript">			<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span></span><br><span class="line"><span class="javascript">				txt = <span class="built_in">document</span>.getElementById(<span class="string">&quot;txt&quot;</span>);  </span></span><br><span class="line"><span class="javascript">				btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;addbtn&quot;</span>);  </span></span><br><span class="line">				if (sessionStorage.num) &#123;  </span><br><span class="line">					num = sessionStorage.num;  </span><br><span class="line">					showNum();  </span><br><span class="line">				&#125;  </span><br><span class="line"><span class="javascript">				<span class="keyword">else</span> &#123;  </span></span><br><span class="line">					num = 0;  </span><br><span class="line">				&#125;  </span><br><span class="line">				  </span><br><span class="line"><span class="javascript">				btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span></span><br><span class="line">					num++;  </span><br><span class="line">					sessionStorage.num = num;  </span><br><span class="line">					showNum();  </span><br><span class="line">				&#125;  </span><br><span class="line">			&#125;  </span><br><span class="line"><span class="javascript">			<span class="function"><span class="keyword">function</span> <span class="title">showNum</span>(<span class="params"></span>) </span>&#123;  </span></span><br><span class="line">				txt.innerHTML = num;  </span><br><span class="line">			&#125;  </span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;txt&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span>  </span><br><span class="line">		<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;addbtn&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端开发那些事</category>
      </categories>
  </entry>
  <entry>
    <title>基础数据结构归档</title>
    <url>/2019/12/15/data-structure/</url>
    <content><![CDATA[<p>这里是一些基础数据结构知识点的整理，有基本概念，线性表，链表，树，图，哈希表等。该部分内容是曾在2018年和2019年发布的。</p>
<p>当前博客显示的发布时间非真实时间，而是这些内容在当时发布时的最后发布时间。</p>
<p><img src="https://i.loli.net/2018/08/10/5b6d26f3edb0e.png"></p>
<a id="more"></a>

<h2 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h2><p>利用计算机进行数据处理是计算机应用的一个重要领域。在进行数据处理时，实际需要处理的元素一般会有很多，而这些大量的数据都要存放在计算机中。因此，大量的数据元素在计算机中如何组织，提高数据处理的效率，并且尽量节省存储空间，是进行数据处理的关键问题。</p>
<p>数据结构主要研究和讨论以下三个方面的问题，目的是提高数据据处理的效率。所谓提高效率主要体现在两个方面：一是提高数据处理的速度，二是尽量节省数据处理过程中所站的计算机存储空间。</p>
<p>1.数据的逻辑结构</p>
<p>2.数据的存储结构</p>
<p>3.对各种数据结构的运算</p>
<p>简单来说，数据结构是指相互有关联的数据元素的集合。数据元素具有广泛的含义，一般来说，现实世界中客观存在的一切个体都可以作为数据元素。</p>
<h3 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h3><p>对于一个给定的数据结构，它应该包含表示数据元素的信息，以及表示各个数据间的前后关系。这里数据间的前后关系是指的它们的逻辑关系，而与它们在计算机中存储的物理位置无关。所以，数据的逻辑结构一般有两个要素，一是数据元素的集合，二是它们之间的逻辑关系。</p>
<p>举个例子，对于图这种数据结构，通常我们用G来表示一个图，一张图通常由两个集合构成，一个是点集V，另一个是边集E。则这个图就可以表示成：</p>
<p><em>G = {V,E}</em></p>
<p>要注意，对于一些复杂的数据结构，它的数据元素也可以是一种数据结构。</p>
<h3 id="数据的存储结构"><a href="#数据的存储结构" class="headerlink" title="数据的存储结构"></a>数据的存储结构</h3><p>前面说到，一个数据结构中的各个数据元素在计算机存储空间中的位置关系与逻辑关系是极有可能不相同的。实际上，数据的逻辑结构在计算机存储空间中的存放形式称为数据的存储结构。在数据的存储结构中，不仅要存放各种数据元素的信息，还需要存放各种数据元素间的前后关系。</p>
<h3 id="线性结构和非线性结构"><a href="#线性结构和非线性结构" class="headerlink" title="线性结构和非线性结构"></a>线性结构和非线性结构</h3><p>通常的，我们根据数据结构中各个元素之间的前后关系的复杂程度，一般将数据结构分成两大类型：线性结构和非线性结构。</p>
<p>如果一个非空的数据结构满足有且只有一个根节点，并且每一个节点最多只有一个前驱或者后继，那么这样的数据结构我们称之为线性结构，有的资料或文献中也称作“线性表”。在线性结构中各个数据元素之间的前后关系都是比较简单的。需要特别说明的是，在一个线性结构中插入或删除任何一个节点后应该还是线性结构，不满足该特性的数据结构也不是线性结构。比如下图所展示的数据结构，就不是一个线性数据结构。</p>
<p><img src="https://i.loli.net/2018/08/09/5b6bfe11a8e9f.png"></p>
<p>不满足线性数据结构定义或特性的，统称为非线性数据结构。</p>
<p>非线性数据结构要比线性数据结构复杂得多，因为它通常会包含更多的前后关系。线性结构与非线性结构都可以是空的数据结构。</p>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>一种最简单并且最常用的数据结构。它由一组数据元素构成。数据元素既可以是简单的，又可以是复杂的。比如矩阵，我们可以把矩阵理解为一个线性表，其中每一行/每一列的数据就可以作为一个数据元素。在这种复杂的线性表中，由若干数据项组成的数据元素称之为记录。总的来说，线性表是一个具有n个元素的一个有限序列。它满足线性数据结构的性质，也就是对于任何一个结点，只会有最多一个前驱和一个后继。</p>
<p>数据元素在线性表中的位置只取决于它们自己的序号，而 <strong>不一定</strong> 取决于它们的物理位置。此外，一个非空的线性表有如下的结构特征：</p>
<p>1.有且只有一个根结点，它没有前驱。</p>
<p>2.有且只有一个尾结点，它没有后继。</p>
<p>3.中间的结点有且只有一个前驱和后继。</p>
<p>在线性表中，结点的个数n代表线性表的长度。当n = 0时，称为空表。</p>
<h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h3><p>这是最简单的存放线性表的方法。它也被称为顺序分配。</p>
<p>线性表的顺序存储结构具有以下两个基本特点：</p>
<p>1.所占存储空间是连续的。</p>
<p>2.各数据元素在存储空间中是按照逻辑顺序依次存放的。</p>
<p>如果采用了线性表的顺序存储结构，那么对于某个元素，它的前驱和后继在存储空间（物理位置）中是紧邻的。对于顺序存储结构，如果各个数据元素所占的存储空间相等，那么查找元素是比较方便的。（其实大多数情况下这个条件是满足的）</p>
<p>对，其实就是一维数组……</p>
<p>在顺序存储结构中，线性表中每一个数据元素在计算机存储空间中的存储地址由该元素在线性表中的位置序号唯一确定。这句话怎么解释呢？我们可以想一想，一维数组在硬件里是怎么存储的？</p>
<p><img src="https://i.loli.net/2018/08/10/5b6cff66cf293.png"></p>
<p>借助这张图来了解是比较直观的。</p>
<p>实际上，头结点所对应的地址称作为首地址，后续的结点地址是连续的，那么自然就会产生一个相对于首地址的位置差值，这个差值我一般称之为“偏移量”。也就是说，在这样的线性表中，每个数据元素都可以用“首地址+偏移量”来表示。</p>
<p>但是要注意的是，上图中的每一个值都只占一个字节，所以地址会按照1,2,3，……这样的顺序来变化。实际上，如果每一个数据元素占k个字节的话，偏移量也是按照k的倍数来变化的。</p>
<p>对于一个线性表，它的操作一般有如下几种：</p>
<pre><code>1. 在指定位置插入新元素
2. 删除指定位置的元素
3. 查找某个元素
4. 排序
5. 分解线性表
6. 合并线性表
7. 复制线性表
8. 逆转线性表</code></pre>
<p>计算机二级考察插入和删除操作。</p>
<h3 id="线性表的插入操作"><a href="#线性表的插入操作" class="headerlink" title="线性表的插入操作"></a>线性表的插入操作</h3><p>刚才说到，顺序存储结构的线性表可以用一维数组来表示，那么这个问题其实就是如何在一个一维数组中插入一个元素的问题。</p>
<p>通常的，在定义一维数组时，数组的长度要比实际用到的长度要长一些。如果长度太短，会导致存储空间不够而无法进行操作，但是长度太长的话又会造成浪费。具体要开多大，自己掂量着来。</p>
<p>插入操作大致的分三步。</p>
<pre><code>1. 找到要插的位置
2. 让后面的元素全部后挪一位，腾出空来
3. 插♂ 进去</code></pre>
<p>特殊的，如果要在线性表的末尾插入元素，那么直接第三步就好。</p>
<p>不难看出，在大多数情况下，进行插入操作都要进行元素的移动。一般的，如果要在i位置插入一个元素，那么第i个元素（包括他本身）以及之后的元素都要做对应的移动。在平均情况下，要在线性表中插入一个元素，需要移动大约一半的元素。这个效率其实是很低的，尤其是在线性表比较大的时候。</p>
<p>此外要注意，当存储空间已满，整个数组的所有位置都存放了数据时，插入操作无法进行。该操作一定要在编写代码时体现出来。</p>
<p>移动操作是倒着来的。即先从尾结点开始，向后移动一个偏移量，之后尾结点之前的每一个元素都要向后移动一个偏移量，一直到插入位置为止。</p>
<p>最后，在腾出来的空位上插入新元素，线性表长度+1。</p>
<h3 id="线性表的删除操作"><a href="#线性表的删除操作" class="headerlink" title="线性表的删除操作"></a>线性表的删除操作</h3><p>删除操作也是三步。</p>
<pre><code>1. 找到要删除的位置
2. 该位置之后的元素全部前移一位（本质上是一种复制后的覆盖）
3. 多余的尾结点清空</code></pre>
<p>特殊的，如果要在线性表的末尾删除元素，那么直接清空尾结点就好。</p>
<p>该操作的效率也比较低，道理同上。</p>
<p>此外，当线性表为空表时，不能进行删除操作，如果试图删除一个不存在的结点，也是不可以的。</p>
<p>一定注意不要忘了第三步，清空尾结点。清空的同时线性表长度-1。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于顺序存储结构的线性表，其优点在于定义方便，易于操作，但是缺点也是很明显的，插入和删除操作的效率很低。</p>
<p>那么它适用于什么情况呢？</p>
<p>对于数据量小的问题，或者是元素不经常变动的问题来说，使用顺序存储结构的线性表是比较简单的。如果数据量大，并且元素还要经常变动，那么可以考虑使用链式存储结构的线性表（链表）。</p>
<p>之前介绍的线性表的顺序存储结构具有一定的不足之处。比如插入或删除元素的效率较低，同时，它的大小是固定的，在操作时需要注意空间的限制。今天要介绍的链表就能很好的解决这些问题。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表这种数据结构其实也是一种线性表，但它并不是顺序存储结构，而是一种链式存储结构。</p>
<p>链式存储结构的基本单元称为结点。每一个存储单元都可以存放若干数据。</p>
<p>在链式存储结构中，通常要求每个结点包括两个信息。一是数据域，记录该结点的数据， 二是指针域，用来存放指向下一个结点或者前一个结点的指针。</p>
<p>之前我们说到，顺序存储结构要求地址必须是连续的，但是链式存储结构不需要。它们之间由指针域连接在一起，所以存储空间可以不连续（也就是说可以是连续的，这点一定注意）。</p>
<p>链式存储结构既可以用来表示线性结构，也可以用来表示非线性结构。在使用链式存储结构存储比较复杂的数据结构时，它的指针域的个数要稍微多一些。</p>
<h3 id="线性链表"><a href="#线性链表" class="headerlink" title="线性链表"></a>线性链表</h3><p>顾名思义，这就是线性表的链式存储结构。其实我们通常说“链表”，指的就是这个。</p>
<p>线性链表与链表在特性上是相似的。在存储链表时，计算机会将一个结点分成两部分：一部分用来存储数据元素的值，另一部分存储指向下一个结点的指针，或者，下一个数据元素的存储序号。</p>
<p>画一下示意图：</p>
<p><img src="https://i.loli.net/2018/08/12/5b6ff1dcc3767.png"></p>
<p>在线性链表中，使用一个专门的指针HEAD指向链表中第一个数据元素的结点（注意并不是指向数据域）。</p>
<p>尾指针不指向任何位置，可以设为NULL或者0。</p>
<p>对于线性链表，可以从头指针开始，沿着各个结点的指针扫描到链表中的所有结点。</p>
<p>其实完全可以给出一个思路。使用for循环来遍历整个链表，循环的初值是头结点，边界是还存在下一个结点，每循环一层，就沿着指针域跑到下一个结点。循环体输出当前结点数据域的信息即可。</p>
<p>这种链表也叫做单向链表，它只能找到后继而不能找到前驱（或者只能找到前驱而不能找到后继），如果想要找到它的前驱，必须再次从头结点进行寻找。</p>
<p>所以为了弥补这个缺点，人们开发出了双向链表。</p>
<p>双向链表的每一个结点具有两个指针域，一个指向前驱一个指向后继。</p>
<p><img src="https://i.loli.net/2018/08/12/5b6ff8302110d.png"></p>
<p>图中L指的是左指针域 R指的是右指针域，D指的是数据域。</p>
<h3 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h3><p>其实就是把顺序存储的栈变成链式存储的栈。</p>
<p><img src="https://i.loli.net/2018/08/12/5b6ffab421e0d.png"></p>
<p>对栈的操作都在头结点上进行。在实际的应用中，带链的栈可以收集计算机存储空间中所有空闲的存储结点。这种链式栈称为可利用栈。由于可利用栈连接了计算机存储空间中所有的空闲结点，因此，当计算机系统或者用户程序需要存储结点时，就可以从中取出栈顶结点。同样，释放一个结点时将返回栈顶。随着其他线性链表的插入与删除，可利用栈处于动态变化之中。即可利用栈经常要进行退栈与入栈操作。</p>
<p>对于一个链式栈，它的基本操作和普通栈是差不多的。</p>
<p>1.初始化。建立一个空栈。</p>
<p>2.入栈。在栈顶插入一个新结点。它分为两步。</p>
<p>第一步，将新节点的指针域指向原头结点。</p>
<p><img src="https://i.loli.net/2018/08/12/5b7020a9b8b28.png"></p>
<p>第二步，头指针上移至新结点。栈长度+1。</p>
<p><img src="https://i.loli.net/2018/08/12/5b702144b88f1.png"></p>
<p>3.出栈。也是分两步。</p>
<p>第一步，头指针指向第二个结点。</p>
<p><img src="https://i.loli.net/2018/08/12/5b7025a28235a.png"></p>
<p>第二步，第一个结点的指针域指向空。</p>
<p><img src="https://i.loli.net/2018/08/12/5b702615e3ceb.png"></p>
<p>4.读栈顶元素</p>
<p>很简单，因为头指针就直接指向栈顶，所以只需要访问头指针所指的结点即可。</p>
<h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><p>和链式栈类似。队首是头结点，队尾是尾结点。</p>
<p>图我就不画了，和链式栈是一样的，只不过头结点指针变成了队首指针，尾结点加一个队尾指针即可。</p>
<p>链式队列的操作也和通常队列几乎一样。</p>
<p>1.初始化队列。</p>
<p>2.入队。在队尾添加一个新结点就好。</p>
<p>第一步，原尾结点的空指针改为指向新结点。</p>
<p>第二步，新节点的指针域指向空。（如果原来就是空的那就不需要这一步）</p>
<p>3.出队。与出栈相同。</p>
<h3 id="线性链表的基本运算"><a href="#线性链表的基本运算" class="headerlink" title="线性链表的基本运算"></a>线性链表的基本运算</h3><p>线性链表的基本运算有很多，比如插入、删除、合并、分解、逆转、复制、排序、查找等。这里主要说一下查找，插入和删除。</p>
<p>1.查找元素</p>
<p>这是删除和插入的基础。因为在链表中，要想在中间插入或删除中间的某个元素，必须要先通过遍历找到它们的位置。</p>
<p>遍历整个列表，在每个结点看值是多少，有就返回已找到，已经到头都找不着就返回没找到。</p>
<p>2.删除元素</p>
<p>思路和上文所述是一致的，遍历一遍整个链表，每次遍历到某个结点，就通过它的指针域看一下下一个结点的数据域是啥，如果是我要删除的元素，那么，我就把当前结点的指针域指向当前指针域指向的结点的指针域指向的下一个结点，然后把要删除的结点的指针域设为空即可。</p>
<p>（有点晕是吧……慢慢捋一下</p>
<p>当前结点是我要删除的结点的前驱结点。我要删除我的后继，我就要把我的后继“孤立”起来。那么我分两步去做这件事。第一步，我要把我的指针域连到跳过这个要删除的结点的位置，也就是我后继的后继。可是我是无法访问我的后继的后继的，我只能通过我的后继去访问我的后继。我有一个通向我后继的指针，当我到达我的后继时，我会再通过我的后继的指针域找到我后继的后继，这个指向我后继的后继的指针域我就找到了，我就可以把我的指针域连在上面。那么我后继的指针怎么处理呢？孤立啊，指向空位置就好。</p>
<p>3.插入元素</p>
<p>我们默认是插入到某结点之后。这个就比较简单了。首先遍历找到这个结点，然后让新结点的指针域指向它的后继，最后让这个结点的指针域指向新结点。</p>
<p>为什么不能先让这个结点的指针域指向新结点呢？</p>
<p>先指过去你的后继不就全没了吗……你还怎么连后边的结点啊……</p>
<p>总结一下，对于链式结构的插入和删除，只需要改变指针域，而不需要移动数据元素。这一点就比线性结构优秀很多。另外，对于删除后被孤立的结点，我们不应让它浪费掉，应该把它送回可利用栈。</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>其实刚才所说的链表还存在一个问题。对于空结点和头结点的插入和删除操作，没法通过循环实现，必须加特判。而且，线性单链表的访问不是自由的，必须从头结点开始，如果想要从中间的结点开始遍历整个链表，可能比较麻烦。这时候，循环链表就可以解决这个问题。</p>
<p>实现很简单。尾结点原本是指空的，只需要指向头结点就可以。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>（PS：栈与队列可以配合<a href="https://www.cnblogs.com/OIerShawnZhou/p/7277322.html">https://www.cnblogs.com/OIerShawnZhou/p/7277322.html</a>食用）</p>
<p>栈也是线性表的一种。它是一种特殊的线性表。它限定在一段插入或删除。你可以把栈形象地理解为一个任何有底无盖的容器，我们每次对栈进行操作都是在顶部进行。对于这个“容器”，它的顶部我们称之为栈顶，它的底部我们称之为栈底。不难得出一个性质，对于栈顶元素，它总是最后一个被插入，总是最先被删除。我们一般把栈的插入操作叫做入栈，相应的，删除操作叫做出栈(有的也叫退栈)。</p>
<p>栈是按照先进后出（FILO）的原则组织数据的，因此，栈也被称作“先进后出”表或者“后进先出”表。</p>
<p>通常的，我们用一个指针top来表示栈顶的位置。</p>
<p><img src="https://i.loli.net/2018/08/11/5b6e33543ab87.png"></p>
<h3 id="栈在系统中的用途"><a href="#栈在系统中的用途" class="headerlink" title="栈在系统中的用途"></a>栈在系统中的用途</h3><p>举一个简化后的例子好了。比如说一个嵌套调用的程序，计算机怎么处理呢？</p>
<p>先看一下（伪）代码示意：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> main&#123;  </span><br><span class="line">	<span class="comment">//do something.  </span></span><br><span class="line">	f1();  </span><br><span class="line">	<span class="comment">//f1返回后会到达这里，记录返回点地址为A   </span></span><br><span class="line">	<span class="comment">//do something.  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;  </span><br><span class="line">	<span class="comment">//do something.  </span></span><br><span class="line">	f2();  </span><br><span class="line">	<span class="comment">//f2返回后会到达这里，记录返回点地址为B  </span></span><br><span class="line">	<span class="comment">//do something.  </span></span><br><span class="line">	<span class="keyword">return</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;  </span><br><span class="line">	<span class="comment">//do something.  </span></span><br><span class="line">	f3();  </span><br><span class="line">	<span class="comment">//f3返回后会到达这里，记录返回点地址为C  </span></span><br><span class="line">	<span class="comment">//do something.  </span></span><br><span class="line">	<span class="keyword">return</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123;  </span><br><span class="line">	<span class="comment">//do something.  </span></span><br><span class="line">	f4();  </span><br><span class="line">	<span class="comment">//f4返回后会到达这里，记录返回点地址为D  </span></span><br><span class="line">	<span class="comment">//do something.  </span></span><br><span class="line">	<span class="keyword">return</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span></span>&#123;  </span><br><span class="line">	<span class="comment">//do something.  </span></span><br><span class="line">	<span class="keyword">return</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>计算机在执行这样的程序的时候，要一层一层地调用函数。而且还要做到进得去，出的来。这就需要一个辅助性的工具来帮助计算机记住进去了哪个函数，从这个函数出来要去哪。</p>
<p>此时，计算机就会使用线性表。它会这样做：</p>
<pre><code>1. 开始执行程序前，计算机申请了一个空表。
2. 当发生函数调用时，计算机会找到它的返回点地址，并且塞到那个线性表的最后面。
3. 当程序从某个子程序返回时，计算机会从线性表中把最后插进去的返回点地址取出，并使用该地址。</code></pre>
<p>模拟一下线性表的工作过程：</p>
<pre><code>1. 一开始是空表[]
2. 进入main函数，遇到了f1，表变成了[A]
3. 进入f1，遇到了f2，表变成了[B]
4. 进入f2，遇到了f3，表变成了[ABC]
5. 进入f3，遇到了f4，表变成了[ABCD]
6. f4执行完毕，要退回f3，f3在哪啊？线性表告诉他，从f4出去要去D位置，于是线性表把D取出来给程序使用，表变成了[ABC]
7. 和上一步一样，从f3出去要到C位置，于是线性表把C取出来。表变成了[AB]
8. 同理，表变成了[A]
9. 程序执行完毕，表又空了[]</code></pre>
<p>这便是一个最简单的栈。</p>
<h3 id="栈的运算"><a href="#栈的运算" class="headerlink" title="栈的运算"></a>栈的运算</h3><p>和线性表一样，在程序设计中，我们也是要使用一维数组设定一个栈，同时要设定一个指针来表示栈顶。</p>
<p>其实有些时候，这里所谓的“指针”，可以不使用真正的指针而是使用一个变量代替，该变量所代表的值即为数组下标，该下标所标注的位置就是栈顶。</p>
<p>1.入栈</p>
<p>之前有说到，入栈运算是指的在栈顶位置插入一个新元素。</p>
<p>首先判断栈满，即判断线性表最后一个位置的指针和栈顶指针是否重合。如果重合，那么说明栈的存储空间已满，是无法进行入栈操作的。</p>
<p>如果栈不满，则栈顶指针上移，入栈。</p>
<p>2.出栈</p>
<p>首先判断栈空，如果栈顶指针与数组头指针重合（或者说，为0），此时是空栈，出栈操作没有意义。</p>
<p>然后（该操作可选）读栈顶元素，并用来做一些其他的事情。</p>
<p>最后栈顶指针-1。</p>
<p>3.访问栈顶元素</p>
<p>仍然需要先判断栈空。如果非空，则返回栈顶元素。这个操作不会删除栈顶元素。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>和排队处理任务时那样，大家都在一条线上等待，早来的早处理。在计算机系统中，如果计算机只能同时做一件事，那么当有多件事需要处理时，其他待做的事情就要“排队等候”。操作系统也会使用一种特殊的线性表来处理这样的排队事件。</p>
<p>这种特殊的线性表就是队列。它允许在一段进行插入，但是删除是在另一端。允许插入的一端称作队尾。（不是队头，一想就明白）允许删除的一端<br>称作队头。显然，在队列中，最先进来的元素一定是最先出去的，所以它是一种先进先出（FIFO）的线性表。</p>
<p><img src="https://i.loli.net/2018/08/11/5b6e490c0f82c.png"></p>
<h3 id="队列的运算"><a href="#队列的运算" class="headerlink" title="队列的运算"></a>队列的运算</h3><p>和栈差不多，入队，出队，读队首。我们假设数组是从左往右走的。</p>
<p>1.入队</p>
<p>首先判断队列有没有满。这里说“队列满”是比较特殊的，它是指队尾指针到达数组尽头。如果不满，则队尾指针+1，入队。</p>
<p>2.出队  </p>
<p>队首指针+1即可，读队首操作也是可选的。</p>
<p>3.访问队首元素</p>
<p>先判断队空，再访问即可。</p>
<p>这里为什么说队列满是特殊的呢？实际上，这里的满是指队尾已到达数组尽头，但是队首可能并不在数组的开始位置，也就是说，这个数组可能是有一部分的空闲的，但此时仍然不能进行入队操作，这是通常队列的一个缺点。</p>
<p>所以，为了解决这个缺点，人们开发出了循环队列。</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>与通常队列很相似，这也是实际应用比较广泛的一种队列，它的空间使用效率较高。</p>
<p>对于循环队列，当队尾已经到达数组尽头而又接收到入队指令时，它会判断队首之前是不是还有空位置，如果有，那么队尾就会跑到数组的前面，形成一个逻辑上的圈。</p>
<p>在循环队列中，队尾指针指向队列中的队尾元素，队首指针指向队首元素的前一个位置。</p>
<p>每进行一次入队运算，队尾指针+1，如果队尾指针=数组长度+1时，让队尾变成0。出队运算也是这样的。</p>
<p>不难得出，循环队列满的时候会有队首指针=队尾指针，但是队空时也满足这个性质。为了区别时队满还是队空，我们有时候会设置一个标记flag，它为0时表示队空，1表示非空。</p>
<p>不难得出，队空满足条件flag = 0。</p>
<p>队满满足条件flag = 1并且队首指针 = 队尾指针</p>
<p>入队运算分三步。  </p>
<p>1.首先判断队列是否为满。当flag = 1并且队尾指针 = 队首指针时，说明队列满，不可以入队。若不满，进入第2步。</p>
<p>2.队尾指针+1，并判断是不是需要变换队尾指针。</p>
<p>3.新元素入队，flag变成1。</p>
<p>出队运算也分三步。如果同时需要取队首元素则是4步。</p>
<p>1.判断队空。如果flag = 0则队空，出队操作无意义。</p>
<p>2.队首指针+1，并判断是不是需要变换队首指针。</p>
<p>3.（可选）返回队首指针所指的元素，可以用来做其他事情。</p>
<p>4.判断出队后队列是否变为空。如果此时队首指针=队尾指针，则说明队列已空，把flag设成0。</p>
<h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><p>在介绍二叉树之前，先介绍一下树是什么。</p>
<p>它是一种一对多的数据结构，对于每一个结点，它只可能有一个前驱或者没有前驱，但是后继可以有一个也可以有多个，当然也可以没有后继。画出来比较像一棵倒长的树。</p>
<p>（图片来自网络）</p>
<p><img src="https://i.loli.net/2018/08/13/5b70fce515831.jpg"></p>
<p>可以看出，它具有很明显的层次关系。在描述各个结点之间的关系时，我们常用一些血缘关系中的术语。</p>
<p>对于一个结点，我们称它的前驱结点为它的父结点。对于最上面的那个没有父结点的结点，我们称之为树的根结点。对于一个结点，它的所有后继都是它的儿子，也就是子结点。</p>
<p>在一棵树中，一个结点所拥有的后继的个数称为该结点的度。这棵树中所有结点的最大的度称为这棵树的度。换句话说，如果一个结点的度数为n，那么就表示这个结点具有n个子结点。在树中，除根结点外，每一个结点都有一个唯一的分支指向它。由此不难得出，树中的结点数等于所有结点的度数+1。</p>
<p>树是按照一定的原则进行分层的。根结点在第一层，同一层上所有结点的子结点都在下一层。其中最底部的结点（叶节点）的层数是最深的。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>一种非常常用也非常有名的数据结构。树结构的术语完全适用于二叉树。</p>
<p>对于一棵二叉树，有且只有一个根节点，并且每一个结点最多有两棵子树，分别称为左子树和右子树。所以，二叉树中每一个结点的最大的度为2。当一个结点没有任何后继时，它是叶结点。</p>
<p>（图片来自网络）</p>
<p><img src="https://i.loli.net/2018/08/13/5b7110c34abfb.jpg"></p>
<h3 id="二叉树的基本性质"><a href="#二叉树的基本性质" class="headerlink" title="二叉树的基本性质"></a>二叉树的基本性质</h3><pre><code>1. 在二叉树的第k层上，最多有2k-1(k≥1)个结点。
2. 深度为m的二叉树最多有2m-1个结点。
3. 在任意一棵二叉树中，度为0的结点总是比度为2的结点多1个。
4. 具有n个结点的二叉树，它的深度至少是[log2n]+1。其中[log2n]是指的是log2n的整数部分。</code></pre>
<h3 id="完全二叉树与满二叉树"><a href="#完全二叉树与满二叉树" class="headerlink" title="完全二叉树与满二叉树"></a>完全二叉树与满二叉树</h3><p>这是两种特殊形式的二叉树。</p>
<p>对于满二叉树，每一层上的结点都会达到它的最大值。也就是说，在第k层，一定有2k-1个结点。深度为m的满二叉树具有2m-1个结点。</p>
<p>完全二叉树只有一点不同。完全二叉树可以在最后一层的最右边缺少一些结点。对于完全二叉树来说，叶结点只有可能在层次最深的两层出现。</p>
<p>所以，满二叉树也算是一种特殊的完全二叉树。但是完全二叉树不一定是满二叉树。</p>
<p>完全二叉树还具有的性质：</p>
<p>具有n个结点的完全二叉树的深度为[log2n]+1。</p>
<p>如果设一个完全二叉树具有n个结点，从根节点开始，按层序用自然数进行编号，那么对于这些编号还具有以下结论：</p>
<pre><code>1. 如果k=1，则这个结点是根节点。如果k&gt;1，那么它的父节点编号是[k/2]。
2. 如果2k≤n，则编号为k的结点的左儿子的编号是2k，否则就没有左子结点。（由于完全二叉树的定义，当一个结点没有左子结点时，一定没有右子结点）
3. 如果2k+1≤n，则编号为k的子结点的右子结点的编号为2k+1，否则该子结点没有右子结点。</code></pre>
<p>根据这些性质，如果按照从上到下，从左到右的顺序给一个完全二叉树进行编号，那么就很容易确定各个结点之间的编号关系。</p>
<h3 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h3><p>和线性链表很类似。对于每个结点要设立两个指针域，一个指向左儿子，一个指向右儿子，如果它没有对应的儿子结点就指空。</p>
<p>要设立头指针指向二叉树的根节点。</p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>所谓二叉树的遍历，即是指不重复地访问二叉树中的所有结点。</p>
<p>由于二叉树是一种非线性结构，因此，对二叉树的遍历要比遍历线性表复杂得多。在遍历到二叉树的某个结点后，要面临两个选择：向左走和向右走。也就是说，遍历二叉树的方法实际上是确定访问各个结点的顺序，以便于不重不漏的访问到所有结点。</p>
<p>通常我们使用三种遍历方法。它们分别是前序遍历，中序遍历和后序遍历。</p>
<pre><code>1. 前序遍历</code></pre>
<p>所谓前序遍历，其实就是先访问根节点，再访问左子树，最后访问右子树。这是一个递归的过程，在每一个子树也要重复这样的过程。</p>
<p>比如还是用这张图来说一下：</p>
<p><img src="https://i.loli.net/2018/08/13/5b7110c34abfb.jpg"></p>
<p>如果二叉树为空则返回，否则先根，再左，最后右。</p>
<p>首先遍历根结点是A，然后是左子树BDEH，然后是右子树CFG。对于左子树再执行一样的操作，遍历出根节点是B，左子树D，右子树EH。对于左子树再执行一样的操作，遍历出左子树是空，右子树是空。对于左子树再执行一样的操作。发现是空，返回。对于右子树再执行一样的操作，发现是空，返回。此时返回到D，对于右子树再执行一样的操作，遍历出根节点是E，左子树是H，右子树是空。对于左子树再执行一样的操作，根节点是H，左右为空，然后去H的左子树，发现是空的，返回，右也是空的，返回。这样以A为根整个的左子树访问完毕，再考虑右子树。右子树根节点是C，左子树是F，右子树是G，F和G没有后继。</p>
<p>这样遍历出一个序列，该序列是ABDEHCFG，它叫做二叉树的前序序列。</p>
<pre><code>2. 中序遍历</code></pre>
<p>中序遍历是指的先访问左子树，再访问根节点，再访问右子树。它也是一个递归的过程。</p>
<p>从A出发，A是根节点，BDEH是左子树。CFG是右子树。去左子树，B是根节点，D是左子树，EH是右子树。去左子树，根节点是D，左右子树为空，去左子树，空，返回，去根节点，是D，去右子树，空，返回。访问完左子树到达根节点B，访问右子树EH。根节点是E，左子树是H，右子树空。访问左子树H，左子树为空，根节点是H，右子树空。访问完左子树，访问根节点E，右子树空。访问根节点A，访问右子树CFG，左子树是F，根节点是C，右子树是G。先访问F，F的左子树为空，右子树为空，再访问根节点C，最后是右子树G，左右子树为空。</p>
<p>这样遍历出一个序列，该序列是DBHEAFCG，它叫做二叉树的中序序列。</p>
<pre><code>3. 后序遍历</code></pre>
<p>后序遍历先访问左子树，再访问右子树，最后是根节点。</p>
<p>从A出发，左子树BDEH，右子树CFG。先遍历左子树，左子树是D，右子树是EH，根节点是B，遍历到D，左右子树为空，回到右子树，左子树是H，右子树空，根节点是E，访问H，再访问E。最后是根节点B。然后是右子树CFG，左子树是F，右子树是G，根节点是C，左子树根节点是F，没有左右子树，右子树根节点是G，没有左右子树。最后是根节点C。然后右子树遍历完毕，最后就是总的根节点A。</p>
<p>这样遍历出一个序列，该序列是DHEBFGCA，它叫做二叉树的后序序列。</p>
<p>直接给出结论，如果知道某二叉树的前序序列和中序序列，那么可以唯一地恢复该二叉树。同样，只要知道后序序列和中序序列也可以唯一地恢复该二叉树，但是只知道前序序列和后序序列是不可以唯一地恢复该二叉树的。</p>
<p>比较绕，要多消化一下。</p>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>为什么要学习这个*东西呢？先来想想二叉树的那三个遍历方法吧。</p>
<p>二叉树的遍历是很多人比较熟悉的，实际上，二叉树的遍历操作就是一个把非线性结构变成线性结构的过程。在线性序列中，每个结点有一个唯一的前驱和唯一的后继（头和尾这种就是有一个没有的）。在这个过程中，我们通过降维打击把树变成了线性表，这破坏了树的结构。有没有一种方法可以做到不进行降维打击也能存储前驱和后继的信息？</p>
<p>其实前驱和后继的信息只需要遍历就能得到的，还是那句话，查询次数多了总有你T的时候。所以还得想个靠谱的办法。</p>
<p>这看起来也许很简单，我在每个结点都保存一个前驱和后继的信息不就可以了？</p>
<p><del>嗯这确实可以，本题结束。</del></p>
<p>此时恰巧一位强迫症的路人经过，他会发现这个结构存储密度特别低，然后感觉非常不适。这是因为什么呢？有结论表明，有n个结点的二叉链表必然存在n+1个空链域。那么问题来了，这n+1个空链域能不能利用起来呢？</p>
<p><del>啊当然这么问的话肯定是能利用的起来是吧</del></p>
<p>实际上，考虑利用这些空链域来存放遍历后结点的前驱和后继信息，这就是线索二叉树构成的思想。采用既可以指示其前驱又可以指示后继的双向链接结构的二叉树被称为线索二叉树。</p>
<p>等等，双向链接结构？二叉链表一般是单向的，这意味着只能通过祖先访问子孙。既然要能够查找前驱，这肯定是不足够的。既然链表可以双向，那二叉链表为什么不可以？这是完全没问题的嘛。</p>
<p>假如这样规定：若结点有左子树，则其lchild表示左孩子，否则令其指示其前驱，若结点有右子树，则其rchild表示右孩子，否则令其指示其后继。同时为了避免混淆（lchild，rchild虽然指示了区域，但是并不知道到底指示的是什么），还需要增加ltag和rtag这两个字段，其中值为0时表示指示孩子，值为1时表示指示前驱或后继。</p>
<pre><code>typedef struct BiThrNode &#123;  
    TElemType data; // TElemType是抽象数据类型啦，它是什么都可以的  
    BiThrNode *lchild, *rchild;  
    int ltag, rtag;  
&#125;BiThrNode, *BiThrTree;  </code></pre>
<p>以这种结点结构构成的二叉链表作为二叉树的存储结构，称为线索链表。其中指向结点前驱和后继的指针称为线索。使用此结点构筑的二叉链表（二叉树）就叫做线索二叉树。对二叉树以某种次序使其变为线索二叉树的过程叫做二叉树的线索化。</p>
<p><img src="https://s2.ax1x.com/2019/11/15/MacExP.png"></p>
<p><img src="https://s2.ax1x.com/2019/11/15/MacOoQ.png" alt="MacOoQ.png"></p>
<p><img src="https://s2.ax1x.com/2019/11/15/Macjij.png" alt="Macjij.png"></p>
<p><img src="https://s2.ax1x.com/2019/11/15/MacvJs.png" alt="MacvJs.png"></p>
<p><img src="https://s2.ax1x.com/2019/11/15/MagFwF.png"></p>
<h3 id="线索二叉树的构造"><a href="#线索二叉树的构造" class="headerlink" title="线索二叉树的构造"></a>线索二叉树的构造</h3><p>由于线索二叉树构造的实质是将二叉链表中的空指针改为指向前驱或后继的线索，而前驱或后继的信息只有在遍历时才能得到，因此线索化的过程即为在遍历的过程中修改空指针的过程。显然，对二叉树按照不同的遍历次序进行线索化得到的线索二叉树是不同的。</p>
<p>为了记下遍历过程中访问结点的先后关系，附设一个指针pre始终指向刚刚访问过的结点，指针p指向当前访问的结点，由此记录下遍历过程中的访问先后关系。</p>
<h4 id="以结点p为根的子树中序线索化"><a href="#以结点p为根的子树中序线索化" class="headerlink" title="以结点p为根的子树中序线索化"></a>以结点p为根的子树中序线索化</h4><pre><code>1. 如果p非空，左子树递归线索化。
2. 如果p的lchild为空，则给p加上左线索，ltag置为1，p的左孩子指针指向pre（前驱），否则将p的ltag置为0.
3. 如果pre的rchild为空，则给pre加上右线索，rtag置为1，pre的右孩子指针指向p（后继），否则将pre的rtag置为0.
4. 将pre指向刚访问过的结点p，即`pre = p;`

void InThreading(BiThrTree p) &#123;  
    if (p) &#123;  
        InThreading(p-&gt;lchild);  
        if (!p-&gt;lchild) &#123;  
            p-&gt;ltag = 1;  
            p-&gt;lchild = pre;  
        &#125;  
    &#125;  
    else &#123;  
        p-&gt;ltag = 0;  
    &#125;  
    if (!pre-&gt;rchild) &#123;  
        pre-&gt;rtag = 1;  
        pre-&gt;rchild = p;  
    &#125;  
    else &#123;  
        p-&gt;rtag = 0;  
    &#125;  
    pre = p;  
    InThreading(p-&gt;rchild);  
&#125;  
/*  
pre是全局变量，初始化时其右孩子指针为空，便于在树的最左点开始建立线索  
*/  </code></pre>
<h4 id="带头结点的二叉树中序线索化"><a href="#带头结点的二叉树中序线索化" class="headerlink" title="带头结点的二叉树中序线索化"></a>带头结点的二叉树中序线索化</h4><pre><code>void InOrderThreading(BiThrTree &amp;thrt, BiThrTree T) &#123;  
    thrt = new BiThrNode;  
    thrt-&gt;ltag = 0;  
    thrt-&gt;rtag = 1;  
    thrt-&gt;rchild = thrt;  
    if (!T)  
        thrt-&gt;lchild = thrt;  
    else &#123;  
        thrt-&gt;lchild = T;  
        pre = thrt;  
        InThreading(T);  
        pre-&gt;rchild=Thrt;  
        pre-&gt;rtag = 1;  
        thrt-&gt;rchild=pre;  
    &#125;  
&#125;  
/*  
pre仍然是全局变量。首先建立头结点，头结点有左孩子，若树非空，则其左孩子为树根，头结点的右孩子指针为右线索。初始化时右指针指向自己，若树为空，则左指针也指向自己。  
头结点的左孩子指向根，pre初值指向头结点。然后调用中序线索化的算法，算法结束后，pre为最右结点，pre的右线索指向头结点。  
*/  </code></pre>
<h3 id="线索二叉树的遍历"><a href="#线索二叉树的遍历" class="headerlink" title="线索二叉树的遍历"></a>线索二叉树的遍历</h3><p>现在我们已经构造好了线索二叉树。好了，现在好像是可以不通过降维打击也能方便查到某个结点的前驱和后继了。</p>
<h4 id="在中序线索二叉树中查找"><a href="#在中序线索二叉树中查找" class="headerlink" title="在中序线索二叉树中查找"></a>在中序线索二叉树中查找</h4><pre><code>1. 查找前驱的方法：

* 若`p-&gt;ltag == 1`，则p的左链指示其前驱
* 若`p-&gt;ltag == 0`，则说明p有左子树，结点的前驱是遍历左子树时最后访问的一个结点（左子树中最右下的结点）。

2. 查找后继的方法：

* 若`p-&gt;rtag == 1`，则p的右链指示其后继
* 若`p-&gt;rtag == 0`，则说明p有右子树。根据中序遍历的规律可知，结点的后继应该是遍历其右子树时访问的第一个结点，即右子树中最左下的结点。</code></pre>
<h4 id="遍历中序线索二叉树"><a href="#遍历中序线索二叉树" class="headerlink" title="遍历中序线索二叉树"></a>遍历中序线索二叉树</h4><p>首先指针p指向根结点，p为非空树或遍历未结束时，循环执行下面的操作：沿左孩子向下，到达最左下结点<code>*p</code>，它是中序的第一个结点；访问<code>*p</code>；沿右线索反复查找当前结点*p的后继结点并访问后继结点，直至右线索为0或者遍历结束；转向p的右子树。</p>
<pre><code>void InOrderTraverse_Thr(BiThrTree T) &#123;  
    p = T-&gt;rchild;  
    while (p != T) &#123;  
        while (p-&gt;ltag == 0)  
            p = p-&gt;lchild;  
        cout &lt;&lt; p-&gt;data;  
        while (p-&gt;rtag == 1 &amp;&amp; p-&gt;rchild != T) &#123;  
            p = p-&gt;rchild;  
            cout &lt;&lt; p-&gt;data;  
        &#125;  
        p = p-&gt;rchild;  
    &#125;  
&#125;  </code></pre>
<p>遍历线索二叉树的时间复杂度为O(n)，空间复杂度为O(1)，这是因为线索二叉树的遍历不需要使用栈来递归操作。</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><p>数据结构课程设计用，简单学一下，不过好像有点难。。？</p>
<p>我想我需要纠正一下这个数据结构的名称，此前我一直称它为B树，但有些教程把它叫做B-树或者B_树，其实它们都是一样的。</p>
<h3 id="B-树的基本概念"><a href="#B-树的基本概念" class="headerlink" title="B-树的基本概念"></a>B-树的基本概念</h3><p>B-树中所有结点中孩子结点个数的最大值成为B-树的阶，通常用m表示，从查找效率考虑，一般要求m&gt;=3。一棵m阶B-树，或者是一棵空树，需要满足下面的特性：</p>
<ul>
<li>树中每个结点至多有 m 棵子树，每个结点最多有m个分支（子树），而最少分支数要看是否为根节点。</li>
<li>除根之外的所有非终端结点至少有两棵子树；根非叶节点至少有ceil(m/2)个分支。（ceil代表向上取整）</li>
<li>所有的非终端结点中包含下列信息数据：（n，A0，K1，A1，K2，A2，…，Kn，An）；</li>
</ul>
<p>其中n为该结点中关键字的个数；ki为该结点的关键字且满足ki &lt; ki+1；Ai为该结点的孩子结点指针，且满足Ai所指结点上的关键字 &gt; Ki 且 &lt;<br>Ki+1，A0所指结点上的关键字小于K1，An所指结点上的关键字 &gt; Kn</p>
<ul>
<li>结点内各关键字互不相等且按从小到大排列，如果一个结点有n-1个关键组，那么该结点有n个分支。</li>
<li>叶子结点处于同一层；可以用空指针表示，是查找失败到达的位置。</li>
</ul>
<p>简单来说，B树的阶是人为定义的，假如有一个4阶的B树，则除了叶结点都是NULL外，其他的结点最多保存3个信息和4个连接域，而且这是互相关联的。如果要保存2个信息则必须是3个连接域，保存1个信息则必须是2个连接域。B树本身也就是一种二叉排序树，所以也适用二叉排序树的一些性质。</p>
<p>下图展示了一个4阶的B树。解释一下每个结点，最左边的数字代表的是这个结点的元素个数，4阶的话元素个数最多是3。对于只有1个元素的结点，应该有2个连接域，对于只有2个元素的结点应该有3个连接域，3个元素的结点应该有4个连接域，多个元素存在的情况下应该保持有序。</p>
<p><img src="http://data.biancheng.net/uploads/allimg/171024/2-1G024101S02K.png"></p>
<p>由于B-树具有分支多层数少的特点，使得它更多应用在数据库系统中。将大型数据库文件存储在硬盘上，为了减少访问次数，就可以使用B-树。它的检索效率很不错。</p>
<p>B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;</p>
<h3 id="B-树的查找操作"><a href="#B-树的查找操作" class="headerlink" title="B-树的查找操作"></a>B-树的查找操作</h3><p>以上图为例，演示一下查找的过程。B树的查找是二叉排序树的扩展，区别在于二叉排序树是二路查找，而B树是多路查找。</p>
<p>又因为B树某结点内部元素是有序的，在结点内查找时可以二分查找来提升速度（确信</p>
<p>假如我们要查找53和20，在查找53的时候，先从根结点开始，比较大小，如果比根大则去右子树，否则去左子树。（二叉排序树性质）</p>
<p>重点来了，现在到了43和78的结点，查找的53要比43大，所以是不会到达39的结点的。然后对比78，如果比78大的话则肯定去了99所在的结点，不过我们查找的53在43和78之间，所以会进47<br>53 64的结点，此时再从左到右进行查找，就可以找到53。</p>
<p>如果要查找20，首先从根节点往左子树出发，发现18，然后往右子树出发，右子树发现27，往左子树出发，发现NULL，表示查找失败，这个B树里没有20。</p>
<blockquote>
<p>叶子结点不保存任何信息，如果某次查找跑到了叶子结点，则表示查找失败。</p>
</blockquote>
<p>B树的标准的查找规则如下，假设查找key：</p>
<pre><code>1. 先让key与根结点中的关键字比较，如果key等于K[i]（K[]为结点内的关键字数组），则查找成功
2. 若key &lt; K[1]，则到A[0]所指示的子树中进行继续查找（A[]为结点内的指针数组），这里要注意B-树中每个结点的内部结构。
3. 若key &gt; K[n]，则到A[n]所指示的子树中继续查找。
4. 若K[i] &lt; key &lt; K[i+1]，则沿着指针A[I]所指示的子树继续查找。
5. 如果最后遇到空指针，则证明查找不成功。</code></pre>
<h3 id="B-树的插入与构筑操作"><a href="#B-树的插入与构筑操作" class="headerlink" title="B-树的插入与构筑操作"></a>B-树的插入与构筑操作</h3><p>B-树也是从空树开始，不断插入新的数据元素构筑的。但是B-<br>树构建的过程与前面的二叉排序树和AVL树不同，B-树在插入新的数据元素时并不是每次都向树中插入新的结点。因为对于m阶的B-<br>树来说，在定义中规定所有的非终端结点（终端结点即叶结点，关键字个数为0）包含关键字个数范围是<code>[ceil(m / 2) - 1, m - 1]</code>，所以在插入新的数据元素时，首先向最底层的某个非终端结点中添加，如果该结点中的关键字个数没有超过m-1，则直接插入成功，否则还需要继续对该结点进行处理。</p>
<p>对于关键字的插入，需要找到插入为位置。在B-<br>树的查找过程中，当遇到空指针时，则证明查找不成功，同时也找到了插入位置，即根据空指针可以确定在最底层非叶节点中的插入位置。由此可见，B树的结点插入总是在终端结点上。但是，在插入过程中有可能会破坏B-<br>树的特征，比如一个4阶的B-树出现了一个结点保存4个数据+5个连接域的情况，这种情况就需要一个“裂开”操作，即拆分结点。</p>
<p>假设有关键字序列<code>&#123;1,2,6,7,11,4,8,13,10,5,17,9,16,20,3,12,14,18,19,15&#125;</code>，以此构筑一棵5阶B-树，过程如下。</p>
<h4 id="确定结点中关键字个数的范围"><a href="#确定结点中关键字个数的范围" class="headerlink" title="确定结点中关键字个数的范围"></a>确定结点中关键字个数的范围</h4><p>由于要求5阶，则关键字个数的范围为2-4。</p>
<p>2是怎么算出来的？因为根非叶节点至少有ceil(m/2)个分支，所以5阶的话最少要有3个分支，3个分支则必定有2条关键字。</p>
<p>4是怎么算出来的？因为是5阶，所以每个结点最多有5个连接域，所以最多有4个关键字。</p>
<h4 id="确定根节点"><a href="#确定根节点" class="headerlink" title="确定根节点"></a>确定根节点</h4><p>由于根节点可以最多容纳4个信息，则根节点应该是下图这样：</p>
<p><img src="https://s2.ax1x.com/2019/12/15/QfCiKf.png"></p>
<h4 id="插入后续节点-拆分操作"><a href="#插入后续节点-拆分操作" class="headerlink" title="插入后续节点 拆分操作"></a>插入后续节点 拆分操作</h4><p>当准备插入11时，11是不可以再插入到根节点了，因为这样关键字的个数变成了5，超出了范围，此时需要进行拆分操作。</p>
<p>拆分时需要取关键字数组的中间位置，这里由于11的加入，关键字的个数会变成5，取中间位置应该是3而不是2。我们让k[3] =<br>6作为一个新的根节点，6左右的关键字分别做成两个结点，作为新结点的两个分支。此时变成了这样。</p>
<p><img src="https://s2.ax1x.com/2019/12/15/QfPiWR.png"></p>
<p>新关键字总是插在叶子结点上。当插入4 8 13后，树变成了：</p>
<p><img src="https://s2.ax1x.com/2019/12/15/QfiFAg.png"></p>
<p>插入关键字10需要插在8和11之间，此时又会出现需要拆分的情况，拆分时需要把10放入根节点，并把10左右的关键字拆成两个新结点连在根节点上。</p>
<p>（图我不画了，太麻烦了QAQ）</p>
<p>按照上述步骤，插入过程中不超范围就直接插，超出范围就让它裂开，最后它会变成这样：</p>
<p>（手画了个，将就着看吧x）</p>
<p><img src="https://s2.ax1x.com/2019/12/15/Qfk861.jpg"></p>
<p>需要注意一个事，插入最后一个关键字15,15应该插入在14之后，此时会出现关键字个数超出范围的情况，则需要拆分，13并入根节点，13并入根节点后，根节点超出范围，需要再次拆分，10作为新的根节点，并将10左右的关键字做成两个新节点连接到新的根节点。这种插入一个关键字后出现多次拆分的情况称为连锁反应。</p>
<h3 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B-树的删除"></a>B-树的删除</h3><p>对于删除，我们需要先找到待删除的关键字，但是直接的删除是不可以的，因为这有可能会破坏B-<br>树的特性。比如旧关键字删除之后结点的个数不再满足定义，此时需要做出一些调整。可能需要向其兄弟结点借一些关键字或者和其孩子结点进行关键字的交换，也可能需要进行结点的合并，其中，和当前结点的孩子进行关键字交换的操作可以保证删除操作总是发生在终端结点上。</p>
<p>删除关键字8和16，关键字8在终端结点上，并且删除后所在结点关键字个数不会超出限制，所以可以直接删除。关键字16不在终端结点上，但是可以用17覆盖16，然后把原来的17删除掉。这里便是与孩子结点进行关键字交换的操作。这里不能用15和16进行关键字交换，因为这样会导致15所在结点中关键字的个数小于2。</p>
<p><img src="https://s2.ax1x.com/2019/12/15/QfEKz9.jpg"></p>
<p>删除关键字15，15虽然也在终端结点上，但是不能直接删除，因为删除后当前结点中关键字的个数小于2，这样不满足5阶B树的定义。此时需要向其兄弟结点借关键字，显然应该向其右兄弟来借关键字，因为左兄弟的关键字个数已经是下限2。借关键字不能直接将18移到15所在的结点上，因为这样会使得15所在的结点上出现比17大的关键字，所以正确的借法应该是先用17覆盖15，再用18覆盖原来的17，最后删除原来的18。<br><img src="https://s2.ax1x.com/2019/12/15/QfEtiD.jpg"></p>
<p>删除关键字4，4在终端结点上，但是此时4所在的结点的关键字个数已经到下限，需要借关键字。不过可以看到其左右兄弟结点已经没有多余的关键字可借。所以就需要进行关键字的合并。可以先将关键字4删除，然后将关键字5、6、7、9进行合并作为一个结点链接在关键字3右边的指针上，也可以将关键字1、2、3、5合并作为一个结点链接在关键字6左边的指针上。但是这样单纯的合并后仍然不可以，因为会出现非根的双分支结点（我就不画图了这个），这样需要继续进行合并。</p>
<p><img src="https://s2.ax1x.com/2019/12/15/QfEToT.jpg"></p>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Index</span> &#123;</span>  </span><br><span class="line">	<span class="built_in">string</span> id;  </span><br><span class="line">	<span class="keyword">int</span> loc;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//B-Tree 结点  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTreeNode</span> &#123;</span>  </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">	<span class="comment">//string *keys;//存储关键字的数据  </span></span><br><span class="line">	Index* keys;  </span><br><span class="line">	<span class="keyword">int</span> t; <span class="comment">//最小度 (决定了key的数量范围)  </span></span><br><span class="line">	BTreeNode** C; <span class="comment">//存储孩子结点的数组  </span></span><br><span class="line">	<span class="keyword">int</span> n; <span class="comment">//现在key的个数  </span></span><br><span class="line">	<span class="keyword">bool</span> leaf; <span class="comment">//如果这个结点是一个叶子 则为TRUE , 否则 为FALSE  </span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">	BTreeNode(<span class="keyword">int</span> <span class="keyword">_t</span>, <span class="keyword">bool</span> _leaf);  </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">()</span></span>; <span class="comment">//遍历以该结点为根的子树中所有结点  </span></span><br><span class="line">	<span class="function">BTreeNode* <span class="title">search</span><span class="params">(Index k)</span></span>;<span class="comment">//在以该节点为根的子树中查找键为k的结点  </span></span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insertNonFull</span><span class="params">(Index k)</span></span>;  </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">splitChild</span><span class="params">(<span class="keyword">int</span> i, BTreeNode* y)</span></span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BTree</span>;</span>  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTree</span> &#123;</span>  </span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line">	BTreeNode* root; <span class="comment">//根节点的指针  </span></span><br><span class="line">	<span class="keyword">int</span> t; <span class="comment">//最小度  </span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">	BTree(<span class="keyword">int</span> <span class="keyword">_t</span>) &#123;  </span><br><span class="line">		root = <span class="literal">NULL</span>; t = <span class="keyword">_t</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">		<span class="keyword">if</span> (root != <span class="literal">NULL</span>) root-&gt;traverse();  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="function">BTreeNode* <span class="title">search</span><span class="params">(Index k)</span> </span>&#123;  </span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> root-&gt;search(k);  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Index _k)</span></span>;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">BTreeNode::BTreeNode(<span class="keyword">int</span> <span class="keyword">_t</span>, <span class="keyword">bool</span> _leaf) &#123;  </span><br><span class="line">	t = <span class="keyword">_t</span>;  </span><br><span class="line">	leaf = _leaf;  </span><br><span class="line">	keys = <span class="keyword">new</span> Index[<span class="number">2</span> * t - <span class="number">1</span>]; <span class="comment">//一个结点key最多有2*t-1个  </span></span><br><span class="line">	C = <span class="keyword">new</span> BTreeNode * [<span class="number">2</span> * t]; <span class="comment">//一个结点孩子最多有2*t个  </span></span><br><span class="line">	n = <span class="number">0</span>; <span class="comment">//新建结点当前key的数量为0  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BTreeNode::traverse</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="comment">// 有n个key和n+1个子key，遍历n个key  </span></span><br><span class="line">	<span class="comment">// 还有前n个子key  </span></span><br><span class="line">	<span class="keyword">int</span> i;  </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;  </span><br><span class="line">		<span class="comment">// 如果这不是叶节点，在打印key[i]之前先遍历以C[i]为根的子树  </span></span><br><span class="line">		<span class="keyword">if</span> (leaf == <span class="literal">false</span>)  </span><br><span class="line">			C[i]-&gt;traverse();  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; keys[i].id;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">// 打印最后一个子树的根  </span></span><br><span class="line">	<span class="keyword">if</span> (leaf == <span class="literal">false</span>)  </span><br><span class="line">		C[i]-&gt;traverse();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function">BTreeNode* <span class="title">BTreeNode::search</span><span class="params">(Index k)</span> </span>&#123;  </span><br><span class="line">	<span class="comment">// 找到第一个大于等于k的key  </span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">while</span> (i &lt; n &amp;&amp; k.id &gt; keys[i].id)  </span><br><span class="line">		i++;  </span><br><span class="line">	<span class="comment">//如果找到的key值等于k，则返回此结点  </span></span><br><span class="line">	<span class="keyword">if</span> (keys[i].id == k.id)  </span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;  </span><br><span class="line">	<span class="comment">// 如果这里没有找到key而这里是一个叶节点  </span></span><br><span class="line">	<span class="keyword">if</span> (leaf == <span class="literal">true</span>)  </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">	<span class="comment">// 去找一个适当的子树继续查询  </span></span><br><span class="line">	<span class="keyword">return</span> C[i]-&gt;search(k);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BTree::insert</span><span class="params">(Index k)</span> </span>&#123;  </span><br><span class="line">	<span class="comment">//如果树为空  </span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">		root = <span class="keyword">new</span> BTreeNode(t, <span class="literal">true</span>);  </span><br><span class="line">		root-&gt;keys[<span class="number">0</span>] = k; <span class="comment">//插入 key  </span></span><br><span class="line">		root-&gt;n = <span class="number">1</span>; <span class="comment">//更新当前root结点的key的个数为1  </span></span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">else</span> &#123;<span class="comment">//树不为空  </span></span><br><span class="line">		<span class="comment">// 如果树的根结点已满，则树的高度会增加  </span></span><br><span class="line">		<span class="keyword">if</span> (root-&gt;n == <span class="number">2</span> * t - <span class="number">1</span>) &#123;  </span><br><span class="line">			BTreeNode* s = <span class="keyword">new</span> BTreeNode(t, <span class="literal">false</span>);  </span><br><span class="line">			<span class="comment">// 旧的根结点成为新的根节点的孩子  </span></span><br><span class="line">			s-&gt;C[<span class="number">0</span>] = root;  </span><br><span class="line">			<span class="comment">// 拆分旧根结点并将一个key移动到新根结点上  </span></span><br><span class="line">			s-&gt;splitChild(<span class="number">0</span>, root);  </span><br><span class="line">			<span class="comment">// 新的根节点现在有了两个子结点。现在决定两个子结点中的哪一个会有新的key  </span></span><br><span class="line">			<span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">			<span class="keyword">if</span> (s-&gt;keys[<span class="number">0</span>].id &lt; k.id)  </span><br><span class="line">				++i;  </span><br><span class="line">			s-&gt;C[i]-&gt;insertNonFull(k);  </span><br><span class="line">			<span class="comment">//改变根节点  </span></span><br><span class="line">			root = s;  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">else</span>  </span><br><span class="line">			root-&gt;insertNonFull(k);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 在此结点中插入新key  </span></span><br><span class="line"><span class="comment">// 假设在调用这个函数时，结点必须是非满的  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BTreeNode::insertNonFull</span><span class="params">(Index k)</span> </span>&#123;  </span><br><span class="line">	<span class="comment">//将index初始化为最右边元素的索引  </span></span><br><span class="line">	<span class="keyword">int</span> i = n - <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 如果这是一个叶节点  </span></span><br><span class="line">	<span class="keyword">if</span> (leaf == <span class="literal">true</span>) &#123;  </span><br><span class="line">		<span class="comment">// 下面的循环做两件事  </span></span><br><span class="line">		<span class="comment">// a) 查找要插入新key的未知  </span></span><br><span class="line">		<span class="comment">// b) 将所有较大的key移动到前方一个位置  </span></span><br><span class="line">		<span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; keys[i].id &gt; k.id) &#123;  </span><br><span class="line">			keys[i + <span class="number">1</span>] = keys[i];  </span><br><span class="line">			i--;  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="comment">// 在找到的位置插入新的key  </span></span><br><span class="line">		keys[i + <span class="number">1</span>] = k;  </span><br><span class="line">		n = n + <span class="number">1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">// 如果这个结点不是叶节点  </span></span><br><span class="line">		<span class="comment">// 找到将拥有新key的子结点  </span></span><br><span class="line">		<span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; keys[i].id &gt; k.id)  </span><br><span class="line">			i--;  </span><br><span class="line">  </span><br><span class="line">		<span class="comment">// 查看找到的子元素是否已满  </span></span><br><span class="line">		<span class="keyword">if</span> (C[i + <span class="number">1</span>]-&gt;n == <span class="number">2</span> * t - <span class="number">1</span>) &#123;  </span><br><span class="line">			<span class="comment">// 如果某个子结点已满，则需要对子结点进行拆分  </span></span><br><span class="line">			<span class="comment">// 机翻：如果孩子吃饱了，就把它切开（草 我裂开了  </span></span><br><span class="line">			splitChild(i + <span class="number">1</span>, C[i + <span class="number">1</span>]);  </span><br><span class="line">  </span><br><span class="line">			<span class="comment">// 执行拆分操作后，C[i]中间的key会上升一级，并且C[i]会一分为二  </span></span><br><span class="line">			<span class="comment">// 看看哪一个会得到新key  </span></span><br><span class="line">			<span class="keyword">if</span> (keys[i + <span class="number">1</span>].id &lt; k.id)  </span><br><span class="line">				i++;  </span><br><span class="line">		&#125;  </span><br><span class="line">		C[i + <span class="number">1</span>]-&gt;insertNonFull(k);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 分割此结点的子结点y  </span></span><br><span class="line"><span class="comment">// 注意，当调用这个函数时，y必须是满的  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BTreeNode::splitChild</span><span class="params">(<span class="keyword">int</span> i, BTreeNode* y)</span> </span>&#123;  </span><br><span class="line">	<span class="comment">// 创建一个将要存储y结点的t-1个key的新结点  </span></span><br><span class="line">	BTreeNode* z = <span class="keyword">new</span> BTreeNode(y-&gt;t, y-&gt;leaf);  </span><br><span class="line">	z-&gt;n = t - <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 复制y中最后t-1个key到z  </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t - <span class="number">1</span>; j++)  </span><br><span class="line">		z-&gt;keys[j] = y-&gt;keys[j + t];  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 复制y中最后t的子结点到z  </span></span><br><span class="line">	<span class="keyword">if</span> (y-&gt;leaf == <span class="literal">false</span>) &#123;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t; ++j)  </span><br><span class="line">			z-&gt;C[j] = y-&gt;C[j + t];  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 减少y中的key数量  </span></span><br><span class="line">	y-&gt;n = t - <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 因为这个结点将有一个新的子结点，所以要给新的子结点开辟空间  </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= i + <span class="number">1</span>; --j)  </span><br><span class="line">		C[j + <span class="number">1</span>] = C[j];  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 将新的子结点链接到此结点  </span></span><br><span class="line">	C[i + <span class="number">1</span>] = z;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 一个y的key将会移动到这个结点，找到新key的位置并将所有较大的key移动一个位置。  </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= i; --j)  </span><br><span class="line">		keys[j + <span class="number">1</span>] = keys[j];  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 将y中间的key复制到这个结点  </span></span><br><span class="line">	keys[i] = y-&gt;keys[t - <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 此结点中的键数量增加1  </span></span><br><span class="line">	n++;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="function">BTree <span class="title">t</span><span class="params">(<span class="number">3</span>)</span></span>;  </span><br><span class="line">	t.insert(&#123; <span class="string">&quot;10&quot;</span>,<span class="number">1</span> &#125;);  </span><br><span class="line">	t.insert(&#123; <span class="string">&quot;20&quot;</span>,<span class="number">2</span> &#125;);  </span><br><span class="line">	t.insert(&#123; <span class="string">&quot;5&quot;</span>,<span class="number">3</span> &#125;);  </span><br><span class="line">	t.insert(&#123; <span class="string">&quot;6&quot;</span>,<span class="number">4</span> &#125;);  </span><br><span class="line">	t.insert(&#123; <span class="string">&quot;12&quot;</span>,<span class="number">5</span> &#125;);  </span><br><span class="line">	t.insert(&#123; <span class="string">&quot;30&quot;</span>,<span class="number">6</span> &#125;);  </span><br><span class="line">	t.insert(&#123; <span class="string">&quot;7&quot;</span>,<span class="number">7</span> &#125;);  </span><br><span class="line">	t.insert(&#123; <span class="string">&quot;17&quot;</span>,<span class="number">8</span> &#125;);  </span><br><span class="line">  </span><br><span class="line">	t.traverse();  </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">	Index k = &#123; <span class="string">&quot;20&quot;</span>,<span class="number">2</span> &#125;;  </span><br><span class="line">	<span class="keyword">if</span> (t.search(k) != <span class="literal">NULL</span>)  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;exist&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">	<span class="keyword">else</span>  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not exist&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>B-树及其基本操作（插入和删除）详解 <a href="http://data.biancheng.net/view/60.html">http://data.biancheng.net/view/60.html</a></p>
<p>B-树（B树）详解 <a href="https://www.jianshu.com/p/7dedb7ebe033">https://www.jianshu.com/p/7dedb7ebe033</a></p>
<p>平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了 <a href="https://zhuanlan.zhihu.com/p/27700617">https://zhuanlan.zhihu.com/p/27700617</a></p>
<p>代码是我同学给的，我把里面的注释给翻译了一下</p>
<h2 id="哈希与哈希表"><a href="#哈希与哈希表" class="headerlink" title="哈希与哈希表"></a>哈希与哈希表</h2><p>曾经也是学过的东西，现在重新学一遍。其实就是通过一个人为制造的函数H，把一些比较大的数字或者字符串转化成能直接通过变量或者数组下标表示的东西，这个函数就是哈希函数。通过哈希函数转化得到的数值一般称之为哈希值。通过哈希值可以快速查找和匹配。</p>
<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><p>用来解决子串类问题。一个比较常见的问题是寻找长度为n的主串上出现了多少次长度为m的子串，这类问题可以使用kmp解决，也可以使用字符串哈希解决。但是如果是这种问题：从主串中每次选取两个子串，问是否匹配（可能相当大），此时便只能使用字符串哈希。</p>
<p>具体操作？哈希函数并不是一个具体的函数，它是可以进行人为定义的，任何一种可以离散化的方法都可以作为一个哈希函数使用。一个比较简单直观的方法是取余法，令hash(k)<br>= k % m，m代表哈希表的大小，取决于你的空间。m越小哈希冲突概率越大， m越大空间开销越大，所以m的值要合理分配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> seed = (随便一个数);  </span><br><span class="line">    <span class="keyword">int</span> m = HASH_SIZE;  </span><br><span class="line">    <span class="keyword">int</span> Hash = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> len = s.length();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;  </span><br><span class="line">        Hash = (Hash * seed + x[i] - <span class="string">&#x27;0&#x27;</span>) % m;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> Hash;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这样可以在O(n)的复杂度内完成哈希操作。但是这样做缺点是明显的，极有可能哈希冲突，也就是不同的串得到了相同的哈希值，这样可能会导致错误。解决哈希冲突的方法有多种，这里介绍双哈希。其实就是把哈希函数再写一遍，这次换一个不同的种子，只有两个哈希值都相等才能断定两个字符串相等。实际证明这个方法实用性不错。</p>
<p>下面介绍一下滚动哈希的优化技巧。选取两个合适的互质常数b和h(b &lt; h)，假设有字符串C = c1c2…cm，那么定义哈希函数Hash(C) =<br>(c1bm-1+c2bm-2+…+cmb0) % h</p>
<p>正常的数字是十进制的，这里相当于把字符串C看成一个b进制的“数”，用b做基数。这一过程是递推计算的，设Hash(C,k)为前k个字符构成的字符串的哈希值，则有H(C,k+1)<br>= H(C,k) × b + ck+1 （暂不考虑取模）</p>
<p>通常，题目要求的是判断主串的一段字符与另一个字符串是否匹配，即判断字符串C = c1c2…cm从k+1位置的长度n的子串C’ =<br>ck+1ck+2…ck+n的哈希值与另一匹配字符串S = s1s2…sn的哈希值是否相等，于是有Hash(C’) = Hash(C,k+n) -<br>Hash(C,k) × bn</p>
<p>（代码有问题，debug中）</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表是一种高效的数据结构，它的优点同字符串哈希一样，查找的算法时间效率几乎就是常数，同时也很容易实现，多产生的代价仅仅是消耗较多内存。</p>
<p>假设现在有一个线性表A(1,75,324,1353,43,91,40)，用n代表元素个数，存储它很简单，只需要一个一维数组。但是这样的数据结构为查找带来了麻烦。如果是顺序存放还好说，我们可以使用二分查找，但是大部分情况下序列是无序的，我们只能使用线性复杂度的算法进行查找。但当n非常大时，速度依然会变得很慢。</p>
<p>我们考虑使用“桶”，开一个特殊的数组，其下标最大值为序列A中的最大值，也就是有一个数组b[1354]（C/C++中数组从0开始，长度为n的话最大值到n-1，这里应该是1354而不是1353）,然后我们令A中的所有元素都在这个b数组里“对号入座”，将数值作为下标，值只有0和1两种（其实不拘泥于这两个数，只是比较常用，只要能区分“有”和“没有”就可以），这样根据这个“桶”来进行查找，时间复杂度变成了常数。但这样仍然会存在一个问题，数组下标并不能很大，这样对于大数据来说仍然是不太合适的。并且这样会造成很大的空间浪费。不过我们可以采用哈希技术，为每个数设置一个哈希值。人为构造哈希函数Hash(x)<br>= x % 123，这样所有的数都变成了0到122之间的数，空间变小了很多。</p>
<p>实际上，这样做仍然存在问题。单纯的进行取模操作会导致大量的数据经过哈希操作后有重复，这就是哈希冲突。那么在查询时就有概率出现错误。哈希表与字符串哈希有所不同，有时题目的测试数据足够大，导致无论如何选择哈希函数都无法避免冲突，而且为了避免冲突去刻意构造一个复杂的哈希函数也得不偿失。这里我们的做法是使用链表。当发生冲突时把这个值挂在链表的下一个结点上，这样虽然查找时的复杂度不是严格的O(1)，但是期望仍然是O(1)，实际复杂度取决于链表长度，也就是冲突的程度。</p>
<p>假设以6为模数，哈希表应该是类似于下面这样：</p>
<p><img src="https://i.loli.net/2019/01/25/5c4b0e213f608.png"></p>
<p>（实际上，实际使用的模数一般要比6大得多，而且一般都是质数，这里仅是举例）</p>
<p>显然，如何构造哈希函数是决定哈希表查找效率的关键。因为只要哈希值的分布足够平均，链表查找的复杂度就会变小。下面是三种比较常用的哈希函数构造方法，</p>
<p>1.取余法</p>
<p>选择一个适当的正整数m，用原数据对m取模的结果作为哈希值，也就是Hash(x) = x %<br>m，这个方法应用是比较广泛的，使用率也比较高。这个方法的关键在于如何选取合适的m，一般是选择一个比较大的质数，这里给出一个从网上找的常用取模质数表，可供参考：</p>
<blockquote>
<p>61, 83, 113, 151, 211, 281, 379, 509, 683, 911 / 一千以下</p>
</blockquote>
<blockquote>
<p>1217, 1627, 2179, 2909, 3881, 6907, 9209, /一万以下</p>
</blockquote>
<blockquote>
<p>12281, 16381, 21841, 29123, 38833, 51787, 69061, 92083, /十万以下</p>
</blockquote>
<blockquote>
<p>122777, 163729, 218357, 291143, 388211, 517619, 690163, 999983, /百万以下</p>
</blockquote>
<blockquote>
<p>1226959, 1635947, 2181271, 2908361, 3877817, 5170427, 6893911, 9191891,<br>/千万以下</p>
</blockquote>
<blockquote>
<p>12255871, 16341163, 21788233, 29050993, 38734667, 51646229,68861641,<br>91815541,/一亿以下</p>
</blockquote>
<blockquote>
<p>1e9+7 和 1e9+9 //十亿左右</p>
</blockquote>
<blockquote>
<p>122420729,163227661,217636919,290182597,386910137,515880193,687840301,917120411,/十亿以下</p>
</blockquote>
<blockquote>
<p>1222827239,1610612741, 3221225473ul, 4294967291ul /十亿以上</p>
</blockquote>
<p>一般来说，如果m的约数越多，造成冲突的概率就会越大，所以尽量选择质数。</p>
<p>2.乘积取整法</p>
<p>用值乘以一个在(0,1)中的实数A（最好是无理数，(√5 -<br>1)/2是一个实际效果很不错的数），这样能得到一个(0,k)之间的实数，取其小数部分再乘以哈希表的大小M，再向下取整，然后得到在哈希表中的位置。</p>
<p>这个听起来就挺麻烦的（摊）</p>
<p>3.基数转换法</p>
<p>类似于字符串哈希使用的方法：将值看成是另一种进制的数，然后把它转化成十进制数，然后用取余法。一般取大于10的数作为转换基数，并且最好和原来进制的10互质。比如将一个十进制数强行看作是13进制，然后按照进制转换规则转成10进制，就得到一个值。</p>
<p>听起来也好麻烦。。。</p>
<p>事实上，哈希函数的构造方法有很多，并没有硬性规定，能避免冲突就可以。</p>
<p>取余法代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500000  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m 999983  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> tot, adj[maxn], nxt[maxn], num[maxn];  </span><br><span class="line"><span class="keyword">int</span> top, stk[maxn];  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="comment">//初始化哈希表，在多组数据时用来清空哈希表  </span></span><br><span class="line">	<span class="comment">//用一个栈存储出现过的哈希值，每次只要把出现过的哈希值的链表清零就可以，节省时间  </span></span><br><span class="line">	tot = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">while</span> (top) &#123;  </span><br><span class="line">		adj[stk[top--]] = <span class="number">0</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;  </span><br><span class="line">	<span class="comment">//使用取余法进行插入  </span></span><br><span class="line">	<span class="keyword">int</span> h = key % m;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> e = adj[h]; e; e = nxt[e]) &#123;  </span><br><span class="line">		<span class="keyword">if</span> (num[e] == key)  </span><br><span class="line">			<span class="keyword">return</span>;   <span class="comment">//遍历链表如果已经出现过这个值就没必要再存一遍  </span></span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">if</span> (!adj[h])   <span class="comment">// 如果能走到这里说明这个值没存过，要进行存储，把第一次出现的哈希值入栈  </span></span><br><span class="line">		stk[++top] = h;  </span><br><span class="line">	nxt[++tot] = adj[h];  </span><br><span class="line">	adj[h] = tot;  </span><br><span class="line">	num[tot] = key; <span class="comment">//用类似于建立邻接表的方式建立链表，存储下所有哈希值等于h的数字  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;  </span><br><span class="line">	<span class="comment">//查询操作  </span></span><br><span class="line">	<span class="comment">//先求哈希值再遍历链表，查找到则表示存在  </span></span><br><span class="line">	<span class="keyword">int</span> h = key % h;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> e = adj[h]; e; e = nxt[e]) &#123;  </span><br><span class="line">		<span class="keyword">if</span> (num[e] == key)  </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="comment">//此处请自由发挥  </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>一种时间复杂度为log级别的数据结构，支持单点维护和求区间和。树状数组可以在大数据下快速计算区间和以及维护最大值最小值。</p>
<p>lowbit操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m&amp;(-m);<span class="comment">//位运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求前缀区间和：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumele</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        sum += c[n];</span><br><span class="line">        n -= lowbit(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单点更新：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=n)&#123;</span><br><span class="line">        c[i] += val;</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它只是一种维护的手段，实质上还是求区间和。</p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>本能反应是想到一个菊花型的结构。</p>
<p><img src="https://i.loli.net/2018/11/19/5bf2ad9da9236.png"></p>
<p>这其实是用路径压缩形成的一种很特殊的树形结构，每棵树的根节点都是一个代表元素。</p>
<p>并查集初始化时，集合的每个元素都是自己是自己的代表元素，所以</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    father[i] = i;</span><br></pre></td></tr></table></figure>

<p>用它就可以初始化一个并查集。</p>
<p>合并集合很简单，把一棵树上的根节点变成另一棵树上的子结点就好。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x = find(x);</span><br><span class="line">    y = find(y);</span><br><span class="line">    father[y] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并查集的路径压缩的查找祖先方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (father[x] == x)</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">    father[x] = find(father[x]);<span class="comment">//如果当前节点的father并不是代表元素，那就递归地更新老祖宗</span></span><br><span class="line">    <span class="keyword">return</span> father[x];<span class="comment">//返回老祖宗</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断两个元素是否在同一集合：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x = find(x);</span><br><span class="line">    y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (x==y)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><p>图是一种多对多的数据结构，通俗的来讲，有一些点，点和点之间由各种边相连，就是一个图。精准的定义：图是一种这样的数据结构，假如把图记作G，则有G =<br>(V,E)，V是图上的点构成的集合，E是点与点之间的关系构成的集合，即边集合。可以看出，图其实是由两个集合构成的数据结构。</p>
<p>简单来区分的话，图分为有向图和无向图。有向图的边是有方向的，如果有A→B，则并不一定有B→A。但如果是无向图，则当A和B之间存在边时，一定是A↔B，即当A能走到B时，B也能走到A。</p>
<p>方便起见，引入一些基本术语：</p>
<blockquote>
<p>结点的度：无向图中与结点相连的边的数目，称为结点的度。</p>
<p>结点的入度：在有向图中，以这个结点为终点的有向边的数目。</p>
<p>结点的出度：在有向图中，以这个结点为起点的有向边的数目。</p>
<p>权值：边的“费用”，可以形象地理解为边的长度。</p>
<p>连通：如果图中结点U，V之间存在一条从U通过若干条边、点到达V的通路，则称U、V 是连通的。</p>
<p>回路：起点和终点相同的路径，称为回路，或“环”。</p>
<p>完全图：一个n 阶的完全无向图含有n×(n-1)/2 条边；一个n 阶的完&gt; &gt; 全有向图含有n×(n-1)条边；</p>
<p>稠密图：一个边数接近完全图的图。</p>
<p>稀疏图：一个边数远远少于完全图的图。</p>
</blockquote>
<p>需要注意，只有有向图才存在入度和出度的概念，在无向图中只有度而没有入度和出度。</p>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><p>一般有两种实现方式，一种是邻接矩阵，另一种是邻接表。邻接邻接，相邻连接，连者为邻，互利互通。这个名字还是不难理解的。</p>
<p>邻接矩阵比较适合理解图的结构，具有直观，好写的优点。</p>
<p>定义二维数组G[][]，对任意的G[i][j]，代表从点i到点j的边的权值。如果该图的边无权，则只需要定义成0-1型就好。对于无向图，满足G[i][j] =<br>G[j][i]。如果i与j之间不存在边，则定义为INF或者-1。（INF：infinity，即无穷，无限大，一般为2147483647，即int范围的最大值）</p>
<p>举例：</p>
<p><img src="https://i.loli.net/2019/01/28/5c4ef5d2caf29.png"></p>
<p>它们所对应的邻接矩阵如下：</p>
<p><img src="https://i.loli.net/2019/01/28/5c4ef77d58535.png"></p>
<p>建立邻接矩阵的代码模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2333  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> g[maxn][maxn];  </span><br><span class="line"><span class="keyword">int</span> n, m;  </span><br><span class="line"><span class="keyword">int</span> edgeNum;  </span><br><span class="line"><span class="keyword">int</span> from, to, dis;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; edgeNum;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;  </span><br><span class="line">			g[i][j] = INF;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">//初始化邻接矩阵，初始全部为INF表示全都不连通  </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= edgeNum; i++) &#123;  </span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; from &gt;&gt; to &gt;&gt; dis;  </span><br><span class="line">		g[from][to] = dis;  </span><br><span class="line">		g[to][from] = dis; <span class="comment">// 如果是有向图，这个语句就不能有  </span></span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">//此处请自由发挥  </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>快速初始化的方法：使用ctsdlib里面的memset函数对数组进行初始化，使用memset(g, 0x7f,<br>sizeof(g))可以把数组全都初始化成一个很大的数，memset(g, 0, sizeof(g))全部初始化为0，memset(g, 0xaf,<br>sizeof(g))初始化为一个很小的数。</p>
<p>然而，实际应用中邻接表使用的并不是很广泛，反而是邻接表使用较为广泛。</p>
<p>前置知识：链表的使用</p>
<p>邻接表存储法又叫图的链式存储法，它的原理是根据图上的每一个结点建立一个链表，在图上这个点每连接一个其他点，就把这个点的编号塞到链表后面，这样一个点与其连接的所有点就连成了一条链，将一张图上所有点的这个链弄出来排在一起，成为一个表状结构，就是邻接表。</p>
<p>举例：</p>
<p><img src="https://i.loli.net/2019/01/28/5c4ef5d2caf29.png"></p>
<p>这里只说下图A吧，B和C类似。对于V1，它连接V2,V3,V4，那么以V1为首的链表后面连接的结点就是V2,V3,V4（顺序不一定非得是这个，顺序只能表明先连的哪个点后连的哪个点。）对于V2，连接V1和V4和V3，对于V3，连接V2和V1，对于V4，连接V1和V2。画出图来大概是这样：</p>
<p><img src="https://i.loli.net/2019/01/28/5c4efe5ca4f90.png"></p>
<p>建立邻接表需要使用到结构体，它记录边的信息，一般是记录起止点和权值。然后开一个该结构体类型的数组代表的就是边集。你问点集怎么表示？点集不用表示。（想一想，为什么）</p>
<p>然后我们需要一个head数组，对于任意的head[i]，代表的是以i点开头的链表的“位置”，这个位置是虚拟的，也正是这个数组模拟链表的关键所在。初学者在这里比较难以理解，简单来讲这可以用来代替链表的“指针域”进行存储。进行加边操作的时候需要对边数进行计数，from对应的是head[from]，因为一个点为首的只有一条链表，这一步是找到这个链表的头，然后是to对to，dis对dis，最后更新一下head[from]为当前边数即可。严格来讲这个理解可能并不是很严谨，如果想深入理解可以查阅其他资料，或者选择基于实用主义，不求甚解。</p>
<p>建立邻接表的代码模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2333  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span>  </span><br><span class="line">	<span class="keyword">int</span> from, to, dis;  </span><br><span class="line">&#125;;  </span><br><span class="line">Edge edge[maxn];  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> head[maxn], from, to, dis;  </span><br><span class="line"><span class="keyword">int</span> totEdge = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">int</span> n, m;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dis)</span> </span>&#123;  </span><br><span class="line">	edge[++totEdge].from = head[from];  </span><br><span class="line">	edge[totEdge].to = to;  </span><br><span class="line">	edge[totEdge].dis = dis;  </span><br><span class="line">	head[from] = totEdge;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;  </span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; from &gt;&gt; to &gt;&gt; dis;  </span><br><span class="line">		addEdge(from, to, dis);  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">//此处请自由发挥  </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><p>引入带权图和无权图的概念。对于边有权值的图我们叫做带权图，否则叫做无权图。边的权值可以理解为两点之间的距离，或者移动的代价，花费等等。一张图中可能会有很多带有权值的路径把点连接起来，对于图的最短路，分为单源最短路和多源最短路。单源最短路指的是从一点出发到达图中某点的最短路径，多源最短路指的是任意两点之间的最短路。解决最短路径的算法有很多，但是每种算法都有一定的适用范围。</p>
<h4 id="多源最短路：Floyed算法"><a href="#多源最短路：Floyed算法" class="headerlink" title="多源最短路：Floyed算法"></a>多源最短路：Floyed算法</h4><p>多适用于邻接矩阵，时间复杂度O(n³)，适用负边权</p>
<p>令dis[u][v]表示从u到v的最短路径长度，w[u][v]表示连接u，v边的长度。</p>
<p>首先初始化所有的dis，如果对于任意u,v有边相连则dis[u][v] = w[u][v]，如果没有则dis[u][v] = INF。</p>
<p>算法过程：</p>
<pre><code>for (int k = 1; k &lt;= n; k++) &#123; //这层循环必须放在最外面  
    for (int i = 1; i &lt;= n; i++) &#123;  
        for (int j = 1; j &lt;= n; j++) &#123;  
            if (dis[i][j] &gt; dis[i][k] + dis[k][j])  
                dis[i][j] = dis[i][k] + dis[k][j];  
        &#125;  
    &#125;  
&#125;  </code></pre>
<p>嗯，浑身上下散发着动态规划的味道。这的确是个动态规划，三层循环，第一层循环中间点k，第二第三层循环起点终点i、j，算法的思想很容易理解：如果点i到点k的距离加上点k到点j的距离小于原先点i到点j的距离，那么就用这个更短的路径长度来更新原先点i到点j的距离。</p>
<p>假设现在有一无向图。有一条从点1到点2的带权边为6，有一条从点1到点3的带权边为2，有一条从点3到点2的带权边为1，可以知道dis[1][2] =<br>6,dis[1][3] = 2,dis[2][3] =<br>1，这是初状态。因为dis[1][3]+dis[3][2]&lt;dis[1][2]，所以就用dis[1][3]+dis[3][2]来更新原先1到2的距离。如果两者之间有最短路径的话，就会更新成最短路径的长度。</p>
<p>变形：</p>
<pre><code>for (int k = 1; k &lt;= n; k++) &#123; //这层循环必须放在最外面  
    for (int i = 1; i &lt;= n; i++) &#123;  
        for (int j = 1; j &lt;= n; j++) &#123;  
             dis[i][j] = dis[i][j] || (dis[i][k] &amp;&amp; dis[k][j]);  
        &#125;  
    &#125;  
&#125;  </code></pre>
<p>如果是一个没有边权的图，把相连的两点间的距离设为dis[i][j]=true，不相连的两点设为dis[i][j]=false,用这个办法可以判断一张图中的两点是否相连。</p>
<h4 id="单源最短路：Dijkstra算法"><a href="#单源最短路：Dijkstra算法" class="headerlink" title="单源最短路：Dijkstra算法"></a>单源最短路：Dijkstra算法</h4><p>多适用于邻接表，时间复杂度O(n2)（未经优化），O((n+m)logm)（加入堆优化），不适用负边权</p>
<p>也就是所谓的迪杰斯特拉算法。它是基于一个贪心的思想。从起点V0开始，每次新扩展一个距离最短的点，然后再以这个点为中间点去更新起点到其他所有点的距离。它无法处理边权有负的情况。由于所有的边权都是正，所以不会存在一个距离更短的没有扩展过的点。也就是说每次扩展都要保证路径是当前最短，所以当前这个点到起点的距离永远不会再被改变一次，从而保证算法的正确性。</p>
<p>设起点为s，dis[v]表示从s到v的最短路径，pre[v]为v的前驱节点，用来输出路径。首先初始化：dis[v]=∞(v≠s); dis[s]=0;<br>pre[s]=0;</p>
<p>然后是伪代码：</p>
<pre><code>for (i = 1 to n) &#123;
    在没有被访问过的点中找一个顶点u使得dis[u]是最小的
    u标记为已确定最短路径
    for 与u相连的每个未确定最短路径的顶点v
        if (dis[u]+w[u][v] &lt; dis[v]) &#123;
            dis[v] = dis[u] + w[u][v];
            pre[v] = u;
        &#125;
&#125;</code></pre>
<p>算法结束后，dis[v]为s到v的最短距离；pre[v]为v的前驱节点，用来输出路径。如果不需要pre数组的话可以不加。</p>
<p>这里为什么只给出了伪代码？因为实际使用的Dijkstra大多是优化之后的算法。</p>
<p>（以下文字摘自信息学奥赛一本通课件）</p>
<p>算法思想：从起点到一个点的最短路径一定会经过至少一个“中转点”（例如下图1到5的最短路径，中转点是2。特殊地，我们认为起点1也是一个“中转点”）。显而易见，如果我们想求出起点到一个点的最短路径，那我们必然要先求出中转点的最短路径（例如我们必须先求出点2<br>的最短路径后，才能求出从起点到5的最短路径）。换句话说，如果起点1到某一点V0的最短路径要经过中转点Vi，那么中转点Vi一定是先于V0被确定了最短路径的点。</p>
<p><img src="https://i.loli.net/2019/01/28/5c4f10843d6e9.png"></p>
<p>我们把点分为两类，一类是已确定最短路径的点，称为“白点”，另一类是未确定最短路径的点，称为“蓝点”。如果我们要求出一个点的最短路径，就是把这个点由蓝点变为白点。从起点到蓝点的最短路径上的中转点在这个时刻只能是白点。</p>
<p>Dijkstra的算法思想，就是一开始将起点到起点的距离标记为0，而后进行n次循环，每次找出一个到起点距离dis[u]最短的点u，将它从蓝点变为白点。随后枚举所有的蓝点vi，如果以此白点为中转到达蓝点vi的路径dis[u]+w[u][vi]更短的话，这将它作为vi的“更短路径”dis[vi]（此时还不确定是不是vi的最短路径）。</p>
<p>就这样，我们每找到一个白点，就尝试着用它修改其他所有的蓝点。中转点先于终点变成白点，故每一个终点一定能够被它的最后一个中转点所修改，而求得最短路径。</p>
<p>模拟这个过程，算法开始时，作为起点的dis[1] = 0，其他的点dis[i] = INF。</p>
<p>第一轮循环找到dis[1]最小，将1变成白点。对所有的蓝点做出修改，使得dis[2]=2,dis[3]=4,dis[4]=7。</p>
<p>第二轮循环找到dis[2]最小，将2变成白点。对所有的蓝点做出修改，使得dis[3]=3,dis[5]=4。这时dis[2]，dis[3]，dis[4]被它的最后一个中转点1修改为了最短路径。</p>
<p>第三轮循环找到dis[3]最小，将3变成白点。对所有的蓝点做出修改，使得dis[4]=4。发现以3为中转不能修改5，说明3不是5的最后一个中转点。这时dis[3]，dis[5]被它们的最后一个中转点2修改为了最短路径。</p>
<p>接下来的两轮循环将4、5也变成白点。N轮循环结束后，所有的点的最短路径即能求出。这时dis[4]也被它的最后一个中转点3修改为了最短路径。</p>
<p>Dijkstra无法处理边权为负的情况。 比如下图这样的图：</p>
<p><img src="https://i.loli.net/2019/01/28/5c4f12447246e.png"></p>
<p>2到3的边权值为-4，显然从起点1到3的最短路径是-2（1→2→3），但是dijskstra在第二轮循环开始时会找到当前dis[i]最小的点3，并标记它为白点。这时的dis[3]=1，然而1却不是从起点到点3的最短路径。因为3已被标记为白点，最短路径值dis[3]不会再被修改了，所以我们在边权存在负数的情况下得到了错误的答案。</p>
<p>堆优化：使用堆来优化查找操作。</p>
<p>堆优化之后的Dijkstra:（陈年老代码了，代码风格与现在略有不同）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">int</span> n,m,s,head[<span class="number">50010</span>],cnt;  </span><br><span class="line">ll dis[<span class="number">10010</span>];   </span><br><span class="line"><span class="keyword">bool</span> used[<span class="number">10010</span>];  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> to,from,dis;  </span><br><span class="line">&#125;edge[<span class="number">500010</span>];  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> dis)</span></span>&#123;  </span><br><span class="line">    edge[cnt].to=v;  </span><br><span class="line">    edge[cnt].from=head[u];  </span><br><span class="line">    edge[cnt].dis=dis;  </span><br><span class="line">    head[u]=cnt++;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;  </span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt; q;  </span><br><span class="line">    fill(dis,dis+n+<span class="number">1</span>,INF);  </span><br><span class="line">    fill(used,used+n+<span class="number">1</span>,<span class="literal">false</span>);  </span><br><span class="line">    dis[s]=<span class="number">0</span>;  </span><br><span class="line">    q.push(P(<span class="number">0</span>,s));  </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;  </span><br><span class="line">        P p=q.top();q.pop();  </span><br><span class="line">        <span class="keyword">int</span> u=p.second;  </span><br><span class="line">        <span class="keyword">if</span>(used[u]) <span class="keyword">continue</span>;  </span><br><span class="line">        used[u]=<span class="literal">true</span>;  </span><br><span class="line">        <span class="keyword">int</span> pp=head[u];  </span><br><span class="line">        <span class="keyword">while</span>(pp!=<span class="number">-1</span>)&#123;  </span><br><span class="line">            <span class="keyword">int</span> v=edge[pp].to;  </span><br><span class="line">            <span class="keyword">if</span>(!used[v]&amp;&amp;dis[v]&gt;dis[u]+edge[pp].dis)&#123;  </span><br><span class="line">                dis[v]=dis[u]+edge[pp].dis;  </span><br><span class="line">                q.push(P(dis[v],v));  </span><br><span class="line">            &#125;  </span><br><span class="line">            pp=edge[pp].from;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));  </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;  </span><br><span class="line">        <span class="keyword">int</span> u,v,d;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;d);  </span><br><span class="line">        add_edge(u,v,d);  </span><br><span class="line">    &#125;  </span><br><span class="line">    dijkstra(s);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,dis[i]);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<h4 id="单源最短路：Bellman-Ford算法"><a href="#单源最短路：Bellman-Ford算法" class="headerlink" title="单源最短路：Bellman-Ford算法"></a>单源最短路：Bellman-Ford算法</h4><p>（经过队列优化后的中国叫法是SPFA），多适用于邻接表，时间复杂度O(NE)（未经优化，N为点数，E为边数），O(kE)（k是常数，加入队列优化），适用负边权</p>
<p>同样是用来计算从一个点到其他所有点的最短路径的算法，也是一种单源最短路径算法。能够处理存在负边权的情况，但无法处理存在负权回路的情况。经过改造后的SPFA算法是笔者最喜欢也是最常用，同时也是最容易被卡的最短路算法。</p>
<p>（以下文字摘自信息学奥赛一本通课件）</p>
<p>设s为起点，dis[v]即为s到v的最短距离，pre[v]为v前驱。w[j]是边j的长度，且j连接u、v。初始化：dis[s]=0,dis[v]=∞（v≠s），pre[s]=0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= E; j++)    <span class="comment">//注意要枚举所有边，不能枚举点。</span></span><br><span class="line">       <span class="keyword">if</span> (dis[u]+w[j]&lt;dis[v]) &#123;  <span class="comment">//u、v分别是这条边连接的两个点。</span></span><br><span class="line">           dis[v] =dis[u] + w[j];</span><br><span class="line">           pre[v] = u;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>Bellman-Ford算法的思想很简单。一开始认为起点是白点(dis[1]=0)，每一次都枚举所有的边，必然会有一些边，连接着白点和蓝点。因此每次都能用所有的白点去修改所有的蓝点，每次循环也必然会有至少一个蓝点变成白点。在下面这个简单的模拟中能看到白点的“蔓延”情况。</p>
<p><img src="https://i.loli.net/2019/01/28/5c4f16f7d2a95.png"></p>
<p>虽然Bellman-<br>Ford算法可以求出存在负边权情况下的最短路径，却无法解决存在负权回路的情况。负权回路指一个环，这个环上所有的权值都为负，也可以理解成是指边权之和为负数的一条回路。如果图中出现负环会发生什么？</p>
<p><img src="https://i.loli.net/2019/01/28/5c4f17620d151.png"></p>
<p>负权回路是指边权之和为负数的一条回路，上图中②-④-⑤-③-<br>②这条回路的边权之和为-3。在有负权回路的情况下，从1到6的最短路径是多少？答案是无穷小，因为我们可以绕这条负权回路走无数圈，每走一圈路径值就减去3，最终达到无穷小。<br>所以说存在负权回路的图无法求出最短路径，Bellman-Ford算法可以在有负权回路的情况下输出错误提示。<br>如果在Bellman-Ford算法的两重循环完成后，还是存在某条边使得：dis[u]+w&lt;dis[v]，则存在负权回路：</p>
<pre><code>for 每条边(u,v) 
    if (dis[u]+w&lt;dis[v])  
        return false</code></pre>
<p>优化：SPFA算法</p>
<p>SPFA算法在国际上通称为“经过队列优化的Bellman-Ford算法”，仅在中国流行SPFA这种名字。</p>
<p>设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路估计值对u点所指向的结点v进行松弛操作。如果v点的最短路估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断地从队列中取出结点来进行松弛操作，直到队列为空。这个算法保证只要最短路存在，SPFA算法必定能求出最小值。SPFA算法同样可以判断负环。额外设立一个inq数组，某个点入队的次数超过n次时，可以判断负环存在并且提前退出。</p>
<p>这个算法，简单的说就是队列优化的bellman-ford，利用了每个点不会更新次数太多的特点发明的此算法。</p>
<p>SPFA<br>在形式上和广度优先搜索非常类似，不同的是广度优先搜索中一个点出了队列就不可能重新进入队列，但是SPFA中一个点可能在出队列之后再次被放入队列，也就是说一个点修改过其它的点之后，过了一段时间可能会获得更短的路径，于是再次用来修改其它的点，这样反复进行下去。<br>算法时间复杂度：O(kE)，E是边数。K是常数，平均值为2。</p>
<p>SPFA代码模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 5000015  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(x) memset(x,0,sizeof(x));  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> from,to,dis;  </span><br><span class="line">&#125;;  </span><br><span class="line">Edge edge[maxn];  </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n,m,s,u,v,d;  </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> head[maxn];  </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> dis[maxn];  </span><br><span class="line"><span class="keyword">bool</span> inq[maxn];  </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> from,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> to,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> dis)</span></span>&#123;  </span><br><span class="line">    edge[++cnt].from = head[from];  </span><br><span class="line">    edge[cnt].to = to;  </span><br><span class="line">    edge[cnt].dis = dis;  </span><br><span class="line">    head[from] = cnt;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt; q;  </span><br><span class="line">    q.push(s);  </span><br><span class="line">    ms(inq);  </span><br><span class="line">    inq[s] = <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)  </span><br><span class="line">        dis[i] = INF;  </span><br><span class="line">    dis[s] = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;  </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> u = q.front();  </span><br><span class="line">        q.pop();  </span><br><span class="line">        inq[s] = <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=head[u];i!=<span class="number">0</span>;i=edge[i].from)&#123;  </span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> v = edge[i].to;  </span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> w = edge[i].dis;  </span><br><span class="line">            <span class="keyword">if</span> (dis[u]+w &lt; dis[v])&#123;  </span><br><span class="line">                dis[v] = w+ dis[u];  </span><br><span class="line">                <span class="keyword">if</span> (!inq[v])&#123;  </span><br><span class="line">                    q.push(v);  </span><br><span class="line">                    inq[v] = <span class="literal">true</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;  </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; d;  </span><br><span class="line">        add_edge(u,v,d);  </span><br><span class="line">    &#125;  </span><br><span class="line">    spfa();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>该算法的速度非常之快，但当该算法运行在稠密图或者人为构造的网格图上，该算法的复杂度极有可能退化成O(NE)。</p>
<h3 id="最小生成树-MST"><a href="#最小生成树-MST" class="headerlink" title="最小生成树(MST)"></a>最小生成树(MST)</h3><p>生成树的定义：在一个有n个点的无向图中，取其中n-1条边，连接所有的顶点，得到一个子图，这个子图便是原图的一个生成树。</p>
<p>为什么说子图是树？实际上，树是图的一种特殊形态。这里便扩充了一下图的定义：</p>
<p>图G是树当且仅当下面的任意一个条件成立：</p>
<p>1.G有n-1条边，不存在环</p>
<p>2.G有n-1条边，连通</p>
<p>3.G的任意两点之间只有唯一的简单路径。</p>
<p>4.G连通，但任意删除一条边后就不再连通。</p>
<p>引入最小生成树的概念：在一个带权的无向连通图中，各边权和最小的一棵生成树即为原图的最小生成树。</p>
<p>最小边原则：图中权值最小的边（如果唯一）一定在最小生成树上。</p>
<p>图的最小生成树的唯一性定理：对于一个图G，如果图中的边权值互不相同，则图中的最小生成树一定是唯一的，反之则不然。</p>
<p>最小生成树用来解决类似于使用最小代价用n-1条边连接n个点的问题。比如架设快速道路或者架设网线要求花费最少。</p>
<h3 id="Prim算法-时间复杂度O-n²"><a href="#Prim算法-时间复杂度O-n²" class="headerlink" title="Prim算法 时间复杂度O(n²)"></a>Prim算法 时间复杂度O(n²)</h3><p>（以下文字摘自信息学奥赛一本通课件）</p>
<p>Prim算法采用与Dijkstra、Bellman-Ford算法一样的“蓝白点”思想：白点代表已经进入最小生成树的点，蓝点代表未进入最小生成树的点。</p>
<p>算法描述：</p>
<p>以1为起点生成最小生成树，min[v]表示蓝点v与白点相连的最小边权。</p>
<p>MST表示最小生成树的权值之和。</p>
<pre><code>a）初始化：min[v]= ∞(v≠1); min[1]=0;MST=0;
b）for (i = 1; i&lt;= n; i++)
1.寻找min[u]最小的蓝点u。
2.将u标记为白点
3.MST+=min[u]
4.for 与白点u相连的所有蓝点v  
    if (w[u][v]&lt;min[v]) 
        min[v]=w[u][v];
c）算法结束： MST即为最小生成树的权值之和</code></pre>
<p>算法分析&amp;思想讲解：</p>
<p>Prim算法每次循环都将一个蓝点u变为白点，并且此蓝点u与白点相连的最小边权min[u]还是当前所有蓝点中最小的。这样相当于向生成树中添加了n-1次最小的边，最后得到的一定是最小生成树。</p>
<p>算法证明：</p>
<p>①当只取了一个点K时（边集为空），一定存在一个MST，包含当前的点集和边集。</p>
<p>②假设存在一个MST包含当前的点集和边集。当前点集为S，剩下的点集为S’。设跨越S-S’的最小代价的边为(u,v)。</p>
<p>反证法：假设取的是跨越S-S’的某边(u’,v’)，删除(u’,v’)加入(u,v)，S和S’分别连通，且S-S’通过(u,v)也能连通，这样会得到一个更小权值的MST，所以新加入的边一定是代价最小的边(u,v)。</p>
<p>Q.E.D</p>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>时间复杂度O(ElogE)（E为边数）</p>
<p>前置知识：并查集</p>
<p>Kruskal（克鲁斯卡尔）算法是一种巧妙利用并查集来求最小生成树的算法。我们把无向图中相互连通的一些点称为处于同一个连通块中。Kruskal算法将一个连通块当做一个集合。Kruskal首先将所有的边按从小到大顺序排序（一般使用快排），并认为每一个点都是孤立的，分属于n个独立的集合。然后按顺序枚举每一条边。如果这条边连接着两个不同的集合，那么就把这条边加入最小生成树，这两个不同的集合就合并成了一个集合；如果这条边连接的两个点属于同一集合，就跳过。直到选取了n-1条边为止。</p>
<p>算法描述:</p>
<pre><code>初始化并查集。father[x]=x。
tot=0
将所有边用快排从小到大排序。
计数器 k=0;
for (i=1; i&lt;=M; i++)      //循环所有已从小到大排序的边
  if  这是一条u,v不属于同一集合的边(u,v)&#123; (因为已经排序，所以必为最小)，
    　①合并u,v所在的集合，相当于把边(u,v)加入最小生成树。
　    ②tot=tot+W(u,v)
      ③k++
      ④如果k=n-1,说明最小生成树已经生成，则break; 
  &#125;
结束，tot即为最小生成树的总权值之和。</code></pre>
<p>Kruskal在初始时认为所有的点都是孤立的。然后它枚举所有边（已按边权排好序），枚举到某边的时候会判断这条边连接的两点是否在同一集合里，如果不是则说明这条边一定在最小生成树里，则加入这一条边。一张n个点的图总共选取n-1次边。因为每次我们选的都是最小的边，所以最后的生成树一定是最小生成树。每次我们选的边都能够合并两个集合，最后n个点一定会合并成一个集合。通过这样的策略，Kruskal算法就能得到一棵有n-1条边，连接着n个点的最小生成树。</p>
<p>Kruskal模板：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
#include &lt;algorithm&gt;  
#define maxn 5005  
#define maxm 200005  
using namespace std;  
struct Edge&#123;  
    int from,to,dis;  
    bool operator &lt;(const Edge &amp;rhs)const&#123;  
        return dis &lt; rhs.dis;  
    &#125;  
&#125;;  
Edge edge[maxm];  
int father[maxm];  
int n,m;  
int totedge = 0;  
int k = 0;  
int ans = 0;  
inline int read()&#123;  
    int num = 0;  
    char c;  
    bool flag = false;  
    while ((c = getchar()) == &#39; &#39; || c == &#39;\n&#39; || c == &#39;\r&#39;);  
    if (c == &#39;-&#39;)  
        flag = true;  
    else  
        num = c - &#39;0&#39;;  
    while (isdigit(c = getchar()))  
        num = num * 10 + c - &#39;0&#39;;  
    return (flag ? -1 : 1) * num;  
&#125;      
void init()&#123;  
    for (register int i=1;i&lt;=m;i++)  
        father[i] = i;  
&#125;  
int find(int x)&#123;  
    if (father[x] == x)  
        return father[x];  
    father[x] = find(father[x]);  
    return father[x];  
&#125;  

void merge(int x,int y)&#123;  
    father[find(x)]  = find(y);  
&#125;  

int main()&#123;  
    n = read();m = read();  
    for (register int i=1;i&lt;=m;i++)&#123;  
        edge[i].from = read();  
        edge[i].to = read();  
        edge[i].dis = read();  
    &#125;  
    sort(edge+1,edge+m+1);  
    init();  
    while (totedge &lt; n-1)&#123;  
        if (find(edge[++k].from) != find(edge[k].to))&#123;  
            ans += edge[k].dis;  
            merge(edge[k].from,edge[k].to);  
            totedge++;  
        &#125;  
    &#125;  
    printf(&quot;%d\n&quot;,ans);  
    return 0;  
&#125;  </code></pre>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>啥叫拓扑？百度百科这样说：</p>
<blockquote>
<p>拓扑是研究几何图形或空间在连续改变形状后还能保持不变的一些性质的一个学科。它只考虑物体间的位置关系而不考虑它们的形状和大小。拓扑英文名是Topology，直译是地志学，最早指研究地形、地貌相类似的有关学科。几何拓扑学是十九世纪形成的一门数学分支，它属于几何学的范畴。有关拓扑学的一些内容早在十八世纪就出现了。那时候发现的一些孤立的问题，在后来的拓扑学的形成中占着重要的地位。</p>
</blockquote>
<p>简单来讲，拓扑研究的是图形的位置关系。而拓扑排序也就是指对一张有向无环图的所有点的次序进行排序，最后得到一个序列，而这个排序的规则便就是按照相连的先后顺序进行排序，这个排序就叫做拓扑排序。更简单的说，拓扑排序是把一个图变成一个序列。做成的这个序列就叫做拓扑序列。</p>
<p>引入新概念。</p>
<blockquote>
<p>有向无环图（DAG）：在图论中，如果一个有向图无法从某个顶点出发经过若干条边回到该点，则这个图是一个有向无环图（DAG图）。</p>
</blockquote>
<p>对拓扑排序的讨论均是建立在有向无环图上的。所以本栏目里面所说的图，如果不加特殊注明，均指有向无环图。构造拓扑序列可以帮助我们合理安排一个工程的进度，由DAG构造拓扑序列具有很高的实际应用价值。</p>
<p>举个最简单的例子，游戏的技能树就是一个很简单的有向无环图（之前说到，树也是图的一种）。假设有这么一个设定：所有的后续技能学习都需要一些前置技能的要求，也就是说如果你要学习一个新技能，必须要满足之前的某些技能是掌握的。那么对这个技能树进行拓扑排序，得到的就是一个拓扑序列，它代表着你先学了什么后学了什么。</p>
<p>而构造拓扑排序算法很简单。假如使用邻接表，需要稍稍改动一下加边函数，在里面统计一下某个点的入度，比如from a to<br>b的一条边，一旦成立，b的入度就会+1。这样建图后我们可以得到一个数组，里面保存着各个点的入度信息。</p>
<p>然后我们扫描一下这个数组，寻找入度为0的点（如果保证原图是DAG，则这样的点一定存在）。把所有入度为0的点压入一个队列（不要只找到一个就结束这个操作，因为在DAG里可能存在多个入度为0的点）。</p>
<p>然后我们用一个while(!q.empty())控制循环。每次从队首取出一个结点（并且将这个结点弹出），这是当前遍历到的结点，将它输出（这里的输出并不是说非得要输出，因为题和题不一样，这里也有可能是其他操作，或者说是保存起来方便下一步操作），然后遍历所有与这个点连接的点（直接邻接表遍历操作就可以），把扫描到的点都入度-1，如果-1后入度变成了0，说明这应该是下一步要进行遍历的结点，就把这个结点入队。重复操作，直到队空为止，最后生成的序列就是拓扑序列。</p>
<p><img src="https://i.loli.net/2019/01/30/5c5191b87f551.png"></p>
<p>比如说这个图，首先找到入度为0的点是只有A，把A入队。取队头是A，输出，弹出，然后遍历队头A的连接点，先找到B，入度-1后是0，入队，找到C，入度-1后是0，入队，D也是这样。一遍找完了，再回到开头取找队头，取队头是B，输出，弹出，然后遍历队头B的连接点，找到E，入度-1后变成2，不入队。找完B了找下一个队头是C，遍历C的连接点，找到E，入度-1后变成1。然后是D，这里再进行一步减入度的操作E的入度就变成了0，这里E就可以入队了。最后就是E。这样它的拓扑序列就是ABCDE。</p>
<p>Tips:使用队列那里并不强求，其实使用栈也是可以的。这也就意味着，一个DAG的拓扑序列可能不是唯一的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 23333  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span>  </span><br><span class="line">	<span class="keyword">int</span> from, to, dis;  </span><br><span class="line">&#125;;  </span><br><span class="line">Edge edge[maxn];  </span><br><span class="line"><span class="keyword">int</span> n, m, s, u, v, d;  </span><br><span class="line"><span class="keyword">int</span> inDegree[maxn];  </span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">int</span> head[maxn];  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dis)</span> </span>&#123;  </span><br><span class="line">	edge[++tot].from = head[from];  </span><br><span class="line">	edge[tot].to = to;  </span><br><span class="line">	edge[tot].dis = dis;  </span><br><span class="line">	head[from] = tot;  </span><br><span class="line">	inDegree[to]++;  <span class="comment">// update in-degree  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;  </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  </span><br><span class="line">		<span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>)  </span><br><span class="line">			q.push(i);  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;  </span><br><span class="line">		<span class="keyword">int</span> u = q.front();  </span><br><span class="line">		q.pop();  </span><br><span class="line">		output(u);  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = edge[i].from) &#123;  </span><br><span class="line">			<span class="keyword">int</span> v = edge[i].to;  </span><br><span class="line">			inDegree[v]--;  </span><br><span class="line">			<span class="keyword">if</span> (inDegree[v] == <span class="number">0</span>)  </span><br><span class="line">				q.push(v);  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;  </span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; d;  </span><br><span class="line">		addEdge(u, v, d);  </span><br><span class="line">	&#125;  </span><br><span class="line">	topoSort();  </span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>线性表</tag>
        <tag>链表</tag>
        <tag>栈</tag>
        <tag>队列</tag>
        <tag>树</tag>
        <tag>图</tag>
        <tag>树状数组</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV相关图形操作整合</title>
    <url>/2019/09/02/opencv-collection/</url>
    <content><![CDATA[<p>这里是关于OpenCV图像处理相关内容的学习笔记，该部分内容是曾经在2019年发布的。</p>
<p>当前博客显示的发布时间非真实时间，而是这些内容在当时发布时的最后发布时间。</p>
<p><img src="https://s2.ax1x.com/2019/07/14/ZIwo7D.jpg"></p>
<a id="more"></a>

<p>机械臂项目组中一个比较关键的地方就是视觉处理，通过摄像头获取点位信息传给机械臂。这之中的视觉核心要通过OpenCV完成。这里把简单的流程记录一下。</p>
<h2 id="前期的准备"><a href="#前期的准备" class="headerlink" title="前期的准备"></a>前期的准备</h2><blockquote>
<p>OpenCV 3.1.0（最新版本已经更新到了4.x，但是官网下载速度奇慢无比，无奈用了学长给的旧版本）</p>
<p>Visual Studio 2015及更高版本</p>
</blockquote>
<p>OpenCV下载好后打开会发现其实是一个自动解压的压缩包，它会把所需文件释放在一个目录里。这里我选择D盘的openCV文件夹。</p>
<p><img src="https://s2.ax1x.com/2019/07/14/ZI3G8O.png"></p>
<p>等待它解压完毕就可以了。</p>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>首先找到配置环境变量的位置（如果你不知道在哪里，可以看我之前写的<a href="https://shawnzhou.xyz/2019/01/11/19-01-11-01/">配置Java环境变量的文章</a>，也可以自行百度），找到系统变量下面的Path，点击编辑。</p>
<p><img src="https://s2.ax1x.com/2019/07/14/ZIJiVA.png"></p>
<p>这里找到之前释放文件的位置，依次找到<code>opencv\build\x64\vc14\bin</code>，比如我解压到了<code>D:\openCV</code>文件夹，我就找到<code>D:\openCV\opencv\build\x64\vc14\bin</code>目录下，把这个目录添加到环境变量里。</p>
<h2 id="配置Visual-Studio"><a href="#配置Visual-Studio" class="headerlink" title="配置Visual Studio"></a>配置Visual Studio</h2><p>打开Visual Studio，新建一个空项目，然后点击上方菜单栏视图→属性管理器。</p>
<p><img src="https://s2.ax1x.com/2019/07/14/ZIJBI1.png"></p>
<p>依次找到<code>Debug|x64</code>→<code>Microsoft.Cpp.x64.user</code>，右键属性。<br><img src="https://s2.ax1x.com/2019/07/14/ZIJyRK.png"></p>
<p>在这个界面里面我们需要修改的有三处，分别是VC++目录下的<code>包含目录</code>，<code>库目录</code>，还有链接器目录下的<code>输入目录</code>。</p>
<p><img src="https://s2.ax1x.com/2019/07/14/ZIYDmQ.png"></p>
<p>点击包含目录，会出现编辑按钮，点击入编辑界面。</p>
<p><img src="https://s2.ax1x.com/2019/07/14/ZIYcYq.png"></p>
<p><img src="https://s2.ax1x.com/2019/07/14/ZIYI0J.png"></p>
<p>在包含目录里点击上方对话框右上角的“新建”图标（黄色的那个），依次选择<code>文件目录\opencv\build\include\opencv2</code>，<code>文件目录\opencv\build\include\opencv</code>，<code>文件目录\opencv\build\include</code>添加到里面，保存退出。</p>
<p>下面的库目录也是一样的做法。但是库目录的目录变成了<code>文件目录\opencv\build\x64\vc14\lib</code>。</p>
<p>然后在链接器目录下，展开目录，选择<code>输入</code>，在<code>附加依赖项</code>里面的最后加入<code>;opencv_world310d.lib</code>（一定注意最前面的分号不要忘）</p>
<p><img src="https://s2.ax1x.com/2019/07/14/ZIdYxx.png"></p>
<p>这样，Visual Studio也配置好了。在这个工程下就可以用OpenCV编写程序了。</p>
<h2 id="简单的示例"><a href="#简单的示例" class="headerlink" title="简单的示例"></a>简单的示例</h2><p>新建一个源文件，键入以下代码做测试：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	Mat src = imread(<span class="string">&quot;D:/QQ_files3/MobileFile/kksk.png&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (src.empty()) &#123;  </span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	namedWindow(<span class="string">&quot;test opencv setup&quot;</span>, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	imshow(<span class="string">&quot;test opencv setup&quot;</span>, src);  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这里用imread加载一个图像并显示，路径是我电脑上的路径。</p>
<p>运行出来是这样的：</p>
<p><img src="https://s2.ax1x.com/2019/07/14/ZIdbQ0.png"></p>
<h2 id="Mat对象"><a href="#Mat对象" class="headerlink" title="Mat对象"></a>Mat对象</h2><p>保存图像使用的类型为自定义的Mat类型。计算机中把图像储存为一个二维数组。系统为Mat对象自动分配内存，不存在内存泄漏问题，它是一个面向对象的数据结构。Mat对象分为两部分：<br><strong>头部分和数据部分</strong> 。</p>
<p>在引进Mat对象之前，人们使用<code>IplImage</code>对象来管理图片。这是一个C风格的数据结构，在内存管理上有诸多不便，容易引起一些内存泄漏问题，它自2001年openCV发布后就一直存在，一直到openCV2.0后引进Mat对象，人们就开始把关注点更多的转向使用更方便的Mat。</p>
<p>常用的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mat()  </span><br><span class="line">  </span><br><span class="line">Mat(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> type)  </span><br><span class="line">  </span><br><span class="line">Mat(Size size, <span class="keyword">int</span> type)  </span><br><span class="line">  </span><br><span class="line">Mat(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> type, <span class="keyword">const</span> Scalar &amp;s)  </span><br><span class="line">  </span><br><span class="line">Mat(Size size, <span class="keyword">int</span> type, <span class="keyword">const</span> Scalar &amp;s)  </span><br><span class="line">  </span><br><span class="line">Mat(<span class="keyword">int</span> ndims, <span class="keyword">const</span> <span class="keyword">int</span> *sizes, <span class="keyword">int</span> type)  </span><br><span class="line">  </span><br><span class="line">Mat(<span class="keyword">int</span> ndims, <span class="keyword">const</span> <span class="keyword">int</span> *sizes, <span class="keyword">const</span> Scalar &amp;s)  </span><br></pre></td></tr></table></figure>

<p>简单举一个构造函数的例子：</p>
<p><code>Mat M(2, 2, CV_8UC3, Scalar(0, 0, 255))</code>，前两个参数分别表示行（row）和列（column），第三个参数常数CV_8UC3表示的含义可以这样解读：8表示每个通道占8位，U表示无符号，C表示char类型，3表示通道数目是3，第四个参数是一个向量，表示初始化每个像素值是多少，向量长度对应通道数目一致。</p>
<p>常用方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyTo</span><span class="params">(Mat mat)</span> <span class="comment">// 复制图片  </span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertTo</span><span class="params">(Mat dst, <span class="keyword">int</span> type)</span> <span class="comment">// 负责转换数据类型不同的Mat，保证其他函数的兼容性  </span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">Mat <span class="title">clone</span><span class="params">()</span> <span class="comment">// 也是复制图片  </span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">channels</span><span class="params">()</span> <span class="comment">//获取图像的通道数  </span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">()</span> <span class="comment">// 获取图片的深度  </span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="comment">// 判断是否为空  </span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">uchar* <span class="title">ptr</span><span class="params">(i = <span class="number">0</span>)</span> <span class="comment">//  获取按行的图像指针  </span></span></span><br></pre></td></tr></table></figure>

<p>此外，还有一些其他的方法。像是<code>Scalar()</code>用来颜色赋值，<code>cvtColor()</code>转换颜色空间。</p>
<p>关于部分复制与完全复制。一般情况下只会复制Mat对象的头和指针部分，不会复制数据部分。像是下面这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mat A = imread(imgFilePath);  </span><br><span class="line"><span class="function">Mat <span class="title">B</span><span class="params">(A)</span></span>; <span class="comment">// 这就只复制头和指针  </span></span><br></pre></td></tr></table></figure>

<p>如果想把Mat对象的头和数据部分一起复制，可以这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mat F = A.clone();  </span><br><span class="line">Mat G;  </span><br><span class="line">A.copyTo(G);  </span><br></pre></td></tr></table></figure>

<p>使用Mat对象的四个要点：</p>
<ul>
<li>输出图像的内存是自动分配的</li>
<li>使用openCV的C++接口，不需要考虑内存分配问题</li>
<li>赋值操作和拷贝函数只会复制头部分</li>
<li>使用clone与copyTo两个函数实现数据完全复制</li>
</ul>
<h2 id="矩阵掩膜操作"><a href="#矩阵掩膜操作" class="headerlink" title="矩阵掩膜操作"></a>矩阵掩膜操作</h2><p>掩膜（mask，又称为kernel）一般用于提高图片的对比度。做出来的效果类似下图：</p>
<p><img src="https://s2.ax1x.com/2019/07/23/eACTTf.png"></p>
<p>这个操作可以自己实现，但是openCV已经为我们封装好了。掩膜操作十分简单，用它可以重新计算每个像素的像素值。这个操作可以通过一个公式表示，下面给出，但这个公式其实并不需要记忆。</p>
<p>I(i,j) = 5*I(i,j)-[I(i-1,j) + I(i+1,j) + I(i,j-1) + I(i,j+1)]<br>自己实现的话也就是用代码把这个公式跑一遍，用图像指针遍历整张图片做一遍操作就可以了。</p>
<p>在openCV里面这个操作被封装成了filter2D这个函数，只需要按要求传入几个参数就可以了。不过之前需要建立一个掩膜。这样写就好：<code>Mat kernel = (Mat_&lt;char&gt;(3, 3) &lt;&lt; 0, -1, 0, -1, 5, -1, 0, -1, 0);</code></p>
<p>最后还有一个小知识点，使用<code>getTickCount()</code>计算运行时间。代码里写的比较明白。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	Mat src = imread(<span class="string">&quot;D:/QQ_files3/MobileFile/kksk.png&quot;</span>);  </span><br><span class="line">	Mat dst;  </span><br><span class="line">	<span class="keyword">if</span> (src.empty()) &#123;  </span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	namedWindow(<span class="string">&quot;src image&quot;</span>, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	imshow(<span class="string">&quot;src image&quot;</span>, src);  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">int</span> offsetx = src.channels();  </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; offsetx &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">	<span class="comment">// src.channels()获取原图片的通道数。  </span></span><br><span class="line">	<span class="comment">// 灰度图片的通道为1，RGB图片用三种颜色描述所以通道是3  </span></span><br><span class="line">	<span class="comment">// 还有4通道为RGBA，A为透明度，2通道（实通道，虚通道）不常见  </span></span><br><span class="line">	<span class="comment">//dst = Mat::zeros(src.size(), src.type());  </span></span><br><span class="line">	<span class="comment">//namedWindow(&quot;test init&quot;, CV_WINDOW_AUTOSIZE);  </span></span><br><span class="line">	<span class="comment">//imshow(&quot;test init&quot;, dst);  </span></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">	// 掩膜操作实现图像对比度调整。  </span></span><br><span class="line"><span class="comment">	int cols = (src.cols - 1) * src.channels();  </span></span><br><span class="line"><span class="comment">	int offsetx = src.channels();  </span></span><br><span class="line"><span class="comment">	int rows = src.rows;  </span></span><br><span class="line"><span class="comment">	dst = Mat::zeros(src.size(), src.type());  </span></span><br><span class="line"><span class="comment">	// 创建一个黑色的图，每个像素的通道都为0  </span></span><br><span class="line"><span class="comment">	for (int row = 1; row &lt; (rows - 1); row++) &#123;  </span></span><br><span class="line"><span class="comment">		const uchar* previous = src.ptr&lt;uchar&gt;(row - 1);  </span></span><br><span class="line"><span class="comment">		// 获取图像像素矩阵的指针，括号内表示行数  </span></span><br><span class="line"><span class="comment">		const uchar* current = src.ptr&lt;uchar&gt;(row);  </span></span><br><span class="line"><span class="comment">		const uchar* next = src.ptr&lt;uchar&gt;(row + 1);  </span></span><br><span class="line"><span class="comment">		uchar* output = dst.ptr&lt;uchar&gt;(row);  </span></span><br><span class="line"><span class="comment">		for (int col = offsetx; col &lt; cols; col++) &#123;  </span></span><br><span class="line"><span class="comment">			output[col] = saturate_cast&lt;uchar&gt;(5 * current[col] - (current[col - offsetx] + current[col + offsetx] + previous[col] + next[col]));  </span></span><br><span class="line"><span class="comment">		&#125;  </span></span><br><span class="line"><span class="comment">		// saturate_cast&lt;uchar&gt;()函数为像素范围处理函数  </span></span><br><span class="line"><span class="comment">		// 它确保RGB值的范围控制在0到255之间，小于0返回0，大于0返回255  </span></span><br><span class="line"><span class="comment">	&#125;  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">	<span class="keyword">double</span> t = getTickCount();  </span><br><span class="line">	Mat kernel = (Mat_&lt;<span class="keyword">char</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);  </span><br><span class="line">	<span class="comment">// 创建小数组  </span></span><br><span class="line">	filter2D(src, dst, src.depth(), kernel);  </span><br><span class="line">	<span class="comment">/*  </span></span><br><span class="line"><span class="comment">	对图像应用可分离线性滤波器（矩阵掩膜操作）。  </span></span><br><span class="line"><span class="comment">	该函数对图像应用可分离线性滤波器，src的每一行都是用一维内核过滤。  </span></span><br><span class="line"><span class="comment">	然后，用1D对结果的每一列进行过滤内核核心。最终的结果移位后存储在dst中。  </span></span><br><span class="line"><span class="comment">	*/</span>  </span><br><span class="line">	<span class="keyword">double</span> timeconsume = (getTickCount() - t) / getTickFrequency();  </span><br><span class="line">	<span class="comment">/*  </span></span><br><span class="line"><span class="comment">	通过查阅原型解释能知道，getTickCount()返回一个“Tick”值，用来表示时间点  </span></span><br><span class="line"><span class="comment">	getTickFrequency()是一个比较难理解的东西，原文是这样解释：  </span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	该函数返回某些架构(如x86、x64、PowerPC)。在其他平台上，该函数相当于getTickCount。  </span></span><br><span class="line"><span class="comment">	它也可以用来非常精确的时间测量，以及RNG初始化。  </span></span><br><span class="line"><span class="comment">	getTickCount通常是较好的测量解决方案执行时间。  </span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">	总之记住它就好了。。用两个时间点之差可以计算运行时间。  </span></span><br><span class="line"><span class="comment">	*/</span>  </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;time:&quot;</span> &lt;&lt; timeconsume &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">	namedWindow(<span class="string">&quot;output image&quot;</span>, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	imshow(<span class="string">&quot;output image&quot;</span>, dst);  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="图像的逐像素操作"><a href="#图像的逐像素操作" class="headerlink" title="图像的逐像素操作"></a>图像的逐像素操作</h2><p>使用逐像素操作可以整体修改图像的颜色。以取反色为例，核心语句是<code>gray_src.at&lt;uchar&gt;(row, col) = 255 - gray;</code>，这是灰度图的操作，对BGR彩色图的操作后面会提到。首先定义一个<code>gray</code>变量为<code>gray_src.at&lt;uchar&gt;(row, col)</code>，它代表<code>gray_src</code>这张图的<code>(row,col)</code>坐标的像素。然后用255减去这个值得到反色。整个过程通过一个二重循环控制<code>row</code>和<code>col</code>完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mat src, gray_src;  </span><br><span class="line"><span class="keyword">int</span> height = src.rows; <span class="comment">// 获取图片的高度  </span></span><br><span class="line"><span class="keyword">int</span> width = src.cols; <span class="comment">// 获取图片的宽度  </span></span><br><span class="line"><span class="comment">// ps: 外国人所理解的行和列与中国人正好相反，对于他们来说，纵列为行，横列为列。  </span></span><br><span class="line">  </span><br><span class="line">cvtColor(src, gray_src, CV_BGR2GRAY); <span class="comment">// 使用cvtColor函数把原图转化成灰度图  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; height; row++) &#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; width; col++) &#123;  </span><br><span class="line">        <span class="keyword">int</span> gray = gray_src.at&lt;uchar&gt;(row, col);  </span><br><span class="line">        gray_src.at&lt;uchar&gt;(row, col) = <span class="number">255</span> - gray;  </span><br><span class="line">        <span class="comment">// 用255减去原来的灰度值得到灰度反色  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>下面说说彩色图片的反色操作，尽管你可以直接用<code>bitwise_not(src, notsrc);</code>直接完成反色操作，不过这里还是说一下如果要自己写的话应该怎么写。</p>
<p>我们知道，BGR图像的通道是3。在二重循环取像素的时候，每一个像素点里是包含了三个值的颜色，需要对这三个值都进行<code>255 - x</code>的操作才算是可以。其实这里用的类型就从<code>&lt;uchar&gt;</code>变成了<code>&lt;Vec3b&gt;</code>，通过下标<code>[0] [1] [2]</code>进行访问。下面是核心代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mat src, dst_src;  </span><br><span class="line"><span class="keyword">int</span> height = src.rows;  </span><br><span class="line"><span class="keyword">int</span> width = src.cols;  </span><br><span class="line">dst_src = src.clone();  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; height; row++) &#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; width; col++) &#123;  </span><br><span class="line">        <span class="comment">// 三通道做法，设定bgr，对三个通道各自进行取反色。  </span></span><br><span class="line">        <span class="keyword">int</span> b = dst_src.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>];  </span><br><span class="line">        <span class="keyword">int</span> g = dst_src.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>];  </span><br><span class="line">        <span class="keyword">int</span> r = dst_src.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>];  </span><br><span class="line">        dst_src.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = <span class="number">255</span> - b;  </span><br><span class="line">        dst_src.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = <span class="number">255</span> - g;  </span><br><span class="line">        dst_src.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = <span class="number">255</span> - r;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>源代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	Mat src, gray_src, dst_src;  </span><br><span class="line">  </span><br><span class="line">	src = imread(<span class="string">&quot;C:/Users/ssdrt/Pictures/pic.jpg&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (src.empty()) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load this image&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	  </span><br><span class="line">	<span class="keyword">int</span> height = src.rows;  </span><br><span class="line">	<span class="keyword">int</span> width = src.cols;  </span><br><span class="line">	dst_src = src.clone();  </span><br><span class="line">  </span><br><span class="line">	cvtColor(src, gray_src, CV_BGR2GRAY);  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; height; row++) &#123;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; width; col++) &#123;  </span><br><span class="line">			<span class="keyword">int</span> gray = gray_src.at&lt;uchar&gt;(row, col);  </span><br><span class="line">			gray_src.at&lt;uchar&gt;(row, col) = <span class="number">255</span> - gray;  </span><br><span class="line">			<span class="comment">// 用255减去原来的灰度值得到灰度反色  </span></span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; height; row++) &#123;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; width; col++) &#123;  </span><br><span class="line">			<span class="comment">// 三通道做法，设定bgr，对三个通道各自进行取反色。  </span></span><br><span class="line">			<span class="keyword">int</span> b = dst_src.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>];  </span><br><span class="line">			<span class="keyword">int</span> g = dst_src.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>];  </span><br><span class="line">			<span class="keyword">int</span> r = dst_src.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>];  </span><br><span class="line">			dst_src.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = <span class="number">255</span> - b;  </span><br><span class="line">			dst_src.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = <span class="number">255</span> - g;  </span><br><span class="line">			dst_src.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = <span class="number">255</span> - r;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	namedWindow(<span class="string">&quot;test src&quot;</span>, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	imshow(<span class="string">&quot;test src&quot;</span>, src);  </span><br><span class="line">  </span><br><span class="line">	namedWindow(<span class="string">&quot;test gray src&quot;</span>, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	imshow(<span class="string">&quot;test gray src&quot;</span>, gray_src);  </span><br><span class="line">  </span><br><span class="line">	namedWindow(<span class="string">&quot;test reverse src&quot;</span>, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	imshow(<span class="string">&quot;test reverse src&quot;</span>, dst_src);  </span><br><span class="line">  </span><br><span class="line">	Mat notsrc;  </span><br><span class="line">  </span><br><span class="line">	bitwise_not(src, notsrc);  </span><br><span class="line">  </span><br><span class="line">	namedWindow(<span class="string">&quot;test not src&quot;</span>, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	imshow(<span class="string">&quot;test not src&quot;</span>, notsrc);  </span><br><span class="line">  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<h2 id="图像的线性混合操作"><a href="#图像的线性混合操作" class="headerlink" title="图像的线性混合操作"></a>图像的线性混合操作</h2><p>简单来讲，是把 <strong>两张相同尺寸的图片</strong> （这个一定注意，必须是尺寸相同）按照一定的透明比例混合在一起达到一个融合的效果。它可以通过一个公式来表示。</p>
<p><img src="https://s2.ax1x.com/2019/08/02/ewZBQJ.png"></p>
<p>其中，g(x)代表混合之后的图像，f <del>0</del> (x)和f <del>1</del><br>(x)代表两张图片。这里的图片是用函数形式表示的，道理倒是也讲得通：图片可以看成一个二维的矩阵，对于一个给定的x值，总能通过一个对应关系找到对应的y值，就能确定图中一个点的位置。至于那个α，它代表的是混合的时候两张图片的透明度，RGBA格式应该不陌生吧。这里α的取值为<code>(0,1)</code>。</p>
<p>在openCV中，给出了混合操作的API<code>addWeighted</code>，它接收六个参数，分别为图像1，图像1的α值，图像2，图像2的α值，γ值，输出位置。需要知道的是γ值在这里充当一个校验值，当混合之后图像整体较暗，通过调整γ值就可以把图片的亮度调整回正常。同样的，当亮度较高时将γ值取负就能降低亮度。如果有什么不明白的看代码即可。</p>
<p>我写好之后使用闪4的结局插图测试了一下，效果意外的还不错。</p>
<p>用这两张图进行合成：</p>
<p><img src="https://s2.ax1x.com/2019/08/02/ewQfE9.png"><br><img src="https://s2.ax1x.com/2019/08/02/ewQo36.png"></p>
<p>合成之后的效果（α=0.4, γ=-10.0）：</p>
<p><img src="https://s2.ax1x.com/2019/08/02/ewQXEd.png"></p>
<p>合成之后的效果（α=0.5, γ=0.0）：</p>
<p><img src="https://s2.ax1x.com/2019/08/02/ewlFbQ.png"></p>
<p>源代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	Mat src1, src2, dst;  </span><br><span class="line">	src1 = imread(<span class="string">&quot;C:/Users/ssdrt/Pictures/新建文件夹/sen4ed1.png&quot;</span>);  </span><br><span class="line">	src2 = imread(<span class="string">&quot;C:/Users/ssdrt/Pictures/新建文件夹/sen4ed2.png&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src1.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image1!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	  </span><br><span class="line">	<span class="keyword">if</span> (!src2.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image2!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">double</span> alpha = <span class="number">0.4</span>;  </span><br><span class="line">	<span class="keyword">if</span> (src1.rows == src2.rows &amp;&amp; src1.cols == src2.cols &amp;&amp; src1.type() == src2.type()) &#123;  </span><br><span class="line">		addWeighted(src1, alpha, src2, (<span class="number">1.0</span> - alpha), <span class="number">-10.0</span>, dst);  </span><br><span class="line">		namedWindow(<span class="string">&quot;demo&quot;</span>, CV_WINDOW_FULLSCREEN);  </span><br><span class="line">		imshow(<span class="string">&quot;demo&quot;</span>, dst);  </span><br><span class="line">  </span><br><span class="line">		<span class="keyword">char</span> c;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;save or not?(y/n): &quot;</span>;  </span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; c;  </span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">&#x27;y&#x27;</span>) &#123;  </span><br><span class="line">			imwrite(<span class="string">&quot;C:/Users/ssdrt/Pictures/新建文件夹/sen4ed4.png&quot;</span>, dst);  </span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;image saved!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">else</span> &#123;  </span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;image not saved!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		&#125;  </span><br><span class="line">  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">else</span> &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size error!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="调整图像亮度和对比度"><a href="#调整图像亮度和对比度" class="headerlink" title="调整图像亮度和对比度"></a>调整图像亮度和对比度</h2><p>对图像的变换可以看作两种方式。一种是像素变换，对点的操作；另一种是邻域变换，对区域的操作。调整图像的亮度和对比度是基于像素变换的。至于邻域变换，它可以用来做图像的卷积，图像特征的提取，图像梯度的计算，模糊操作，平滑操作等等。。。</p>
<p>这里给出调整亮度和对比度的一般公式。</p>
<p><img src="https://s2.ax1x.com/2019/08/03/eBRPUg.png"></p>
<p>其中β是增益变量，且满足α&gt;0（对于常规图像）。</p>
<p>思考一下，对亮度的提高是怎样体现在公式上呢？不难想到，当图像亮度提高，图像的整体颜色是会发白的，整张图的颜色会越来越向白色靠拢。思考至每个像素点，当图像亮度提高，其RGB值的三个数值也会提高。为什么？因为(255,255,255)是白色，根据之前的讨论，图像向白色靠拢也就意味着每个像素点都像(255,255,255)靠拢。</p>
<p>图像的对比度简单来理解是像素值之间的绝对差距。它的严格定义是这样的：对比度指的是一幅图像中明暗区域最亮的白和最暗的黑之间不同亮度层级的测量。那么，让这个最亮的白和这个最暗的黑之间的差距变大，反映在图中也就是对比度增大了。反映在公式上，我们可以调整α的值改变图像的像素，当像素值成倍增大时，对比度也就增大了。举个不太严谨的例子，假设说原来的最小值和最大值为[2,102]，差值为100，通过调整α把它扩大一倍，就变成了[4,204]，差值变成了200，则对比度也变成了原来的一倍。</p>
<p>复习一下可能会用到的API：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mat new_image = Mat::zeros(image.size(),image.type());  </span><br><span class="line"><span class="comment">// 创建一张和原图大小一致的空白图像，由于使用了Mat::zeros，确保了所有像素都是(0,0,0)  </span></span><br><span class="line">saturate_cast&lt;uchar&gt;(value);  </span><br><span class="line"><span class="comment">// 确保像素值不会低于0或高于255  </span></span><br><span class="line">Mat.at&lt;Vec3b&gt;(y,x)[index] = value;  </span><br><span class="line"><span class="comment">// 给每个像素点通道赋值  </span></span><br></pre></td></tr></table></figure>

<p>做出来的效果是这样的（alpha = 1.2， beta = 30）：</p>
<p><img src="https://s2.ax1x.com/2019/08/03/eBh3GQ.png"></p>
<p>代码思路和之前类似，核心语句<code>dst.at&lt;uchar&gt;(row, col) = saturate_cast&lt;uchar&gt;(v * alpha + beta);</code>，即对每个像素点跑一遍之前的公式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug cout &lt;&lt; <span class="meta-string">&quot;ok&quot;</span> &lt;&lt; endl;  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	Mat src, dst;  </span><br><span class="line">	src = imread(<span class="string">&quot;F:/blog配图/avatar1.jpg&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">char</span> input_title[] = <span class="string">&quot;input image&quot;</span>;  </span><br><span class="line">	namedWindow(input_title, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	imshow(input_title , src);  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">int</span> height = src.rows;  </span><br><span class="line">	<span class="keyword">int</span> width = src.cols;  </span><br><span class="line">	dst = Mat::zeros(src.size(), src.type());  </span><br><span class="line">	<span class="keyword">float</span> alpha = <span class="number">1.2</span>;  </span><br><span class="line">	<span class="keyword">float</span> beta = <span class="number">30</span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; height; row++) &#123;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; width; col++) &#123;  </span><br><span class="line">			<span class="keyword">if</span> (src.channels() == <span class="number">1</span>) &#123;  </span><br><span class="line">				<span class="keyword">float</span> v = src.at&lt;uchar&gt;(row, col);  </span><br><span class="line">				dst.at&lt;uchar&gt;(row, col) = saturate_cast&lt;uchar&gt;(v * alpha + beta);  </span><br><span class="line">			&#125;  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (src.channels() == <span class="number">3</span>) &#123;  </span><br><span class="line">				<span class="keyword">float</span> b = src.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>];  </span><br><span class="line">				<span class="keyword">float</span> g = src.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>];  </span><br><span class="line">				<span class="keyword">float</span> r = src.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>];  </span><br><span class="line">  </span><br><span class="line">				dst.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = saturate_cast&lt;uchar&gt;(b * alpha + beta);  </span><br><span class="line">				dst.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = saturate_cast&lt;uchar&gt;(g * alpha + beta);  </span><br><span class="line">				dst.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = saturate_cast&lt;uchar&gt;(r * alpha + beta);  </span><br><span class="line">  </span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">char</span> output_title[] = <span class="string">&quot;contrast and brightness change demo&quot;</span>;  </span><br><span class="line">	namedWindow(output_title, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	imshow(output_title, dst);  </span><br><span class="line">  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="模糊图像"><a href="#模糊图像" class="headerlink" title="模糊图像"></a>模糊图像</h2><p>Smooth/Blur是图像处理中最简单和常用的操作之一，使用该操作的原因之一就是为了给图像预处理的时候减低噪声。该操作背后是一个卷积计算。通常这些卷积算子计算都是线性操作，所以又叫线性滤波。</p>
<p><img src="https://s2.ax1x.com/2019/08/03/eBhvFS.png"></p>
<p>计算过程可以这样直观的看一下：</p>
<p><img src="https://s2.ax1x.com/2019/08/03/eB5tEV.png"></p>
<p>这是一个6×6网格，计算卷积的算子为一个3×3的区域，该区域从左向右，从上向下移动，计算方式为所有黄色块的像素点值求和取平均赋给中间的红色块。每次移动一个像素格。</p>
<p>这种操作叫做归一化盒子滤波，也叫均值滤波。公式如下。</p>
<p><img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/827ef921aef26b9b84542f020a3b55c8b1976fc4.png"></p>
<p>此外还有一种比较有用的滤波器叫高斯滤波。 高斯滤波是将输入数组的每一个像素点与高斯内核卷积，将卷积和当作输出像素值。一维的高斯函数像下图这样：</p>
<p><img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/Smoothing_Tutorial_theory_gaussian_0.jpg"></p>
<p>给出二维高斯函数的表达式。</p>
<p><img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/5b09b2a4f4ddd1d97cbb00a3f32b218afdb84117.png"></p>
<p>其中 μ为均值 (峰值对应位置)，σ代表标准差 (变量x和变量y各有一个均值，也各有一个标准差)，A是归一化系数。</p>
<p>可能会用到的API：</p>
<p>​    </p>
<pre><code>blur(Mat src, Mat dst, Size(xraius, yradius), Point(-1, -1));   
// 均值模糊，Point(-1, -1)为默认中心位置，一般不用改  
GaussianBlur(Mat src, Mat dst, Size(11, 11), sigmax, sigmay);  
// 高斯模糊，其中Size(x, y)中的x和y必须是正奇数  </code></pre>
<p>使用均值模糊之后的效果：</p>
<p><img src="https://s2.ax1x.com/2019/08/03/eBoq1g.png"></p>
<p>其实很简单。源代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug cout &lt;&lt; <span class="meta-string">&quot;ok&quot;</span> &lt;&lt; endl;  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	Mat src, dst;  </span><br><span class="line">	src = imread(<span class="string">&quot;F:/blog配图/avatar1.jpg&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">char</span> input_title[] = <span class="string">&quot;input image&quot;</span>;  </span><br><span class="line">	<span class="keyword">char</span> output_title[] = <span class="string">&quot;blur image&quot;</span>;  </span><br><span class="line">	namedWindow(input_title, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	namedWindow(output_title, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	imshow(input_title, src);  </span><br><span class="line">  </span><br><span class="line">	blur(src, dst, Size(<span class="number">5</span>, <span class="number">5</span>), Point(<span class="number">-1</span>, <span class="number">-1</span>));  </span><br><span class="line">	imshow(output_title, dst);  </span><br><span class="line">  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>稍微修改一下代码得到高斯模糊：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GaussianBlur(src, dst, Size(<span class="number">111</span>, <span class="number">111</span>), <span class="number">1919</span>, <span class="number">810</span>);  </span><br><span class="line">imshow(output_title, dst);  </span><br></pre></td></tr></table></figure>

<p>不过这两种模糊都有一些缺陷。均值模糊无法克服边缘像素信息丢失缺陷，原因是均值滤波是基于平均权重的。高斯模糊部分克服了这种缺陷，但是无法完全避免，因为没有考虑到像素值的不同。</p>
<p><img src="https://s2.ax1x.com/2019/08/03/eBqBiq.png"></p>
<hr>
<p>此外还有中值滤波和双边滤波。中值滤波是一种统计排序滤波器，中值对椒盐噪声有很好的抑制作用。双边滤波是边缘保留的滤波方法，避免了边缘信息丢失，保留了图像轮廓不变。</p>
<p>相关API：</p>
<pre><code>medianBlur(Mat src, Mat dest, size); // 中值模糊  
// 中值模糊的size大小必须是正奇数  
bilateralFilter(src, dest, d = 15, 150, 3); // 双边模糊  
/*  
15为计算的半径，半径之内的像素都会被纳入计算，如果提供-1则会根据sigma space参数取值  
150为sigma color，它决定多少差值之内的像素会被计算  
3为sigma space，如果d&gt;0则声明无效，否则根据它来计算d值  
*/  </code></pre>
<p><img src="https://s2.ax1x.com/2019/08/03/eDAGAx.png"></p>
<p>（这张插图其实不太能很好的体现中值滤波的作用，我这里找不到椒盐噪点比较多的图片）</p>
<p>一行代码即可：<code>medianBlur(src, dst, 3);</code></p>
<p>其实用它来提升肤质细节也是不错的。还有双边滤波也是。比如使用<code>bilateralFilter(src, dst, 15, 45, 3);</code>可以达到一个类似于美颜的效果（大雾）。</p>
<p><img src="https://s2.ax1x.com/2019/08/03/eDQ1zt.png"></p>
<p>那么，再加一个掩膜让图片锐化一下会怎样呢（滑稽</p>
<p>也许就能达到一个假装ps过的效果了（</p>
<p><img src="https://s2.ax1x.com/2019/08/03/eDc3pn.png"></p>
<h2 id="膨胀操作与腐蚀操作"><a href="#膨胀操作与腐蚀操作" class="headerlink" title="膨胀操作与腐蚀操作"></a>膨胀操作与腐蚀操作</h2><p>它是图像处理中最常用的形态学操作手段。</p>
<p>膨胀：<br>与卷积操作类似，假设有图像A和结构元素B，结构元素B在A上面移动，其中B定义其中心为锚点，计算B覆盖下A的最大像素值用来替换锚点的像素，其中B作为结构体可以是任意形状。</p>
<p>腐蚀操作与膨胀操作类似，只是把最大像素值换成了最小像素值。它的定义为：<br>与卷积操作类似，假设有图像A和结构元素B，结构元素B在A上面移动，其中B定义其中心为锚点，计算B覆盖下A的 <strong>最小</strong><br>像素值用来替换锚点的像素，其中B作为结构体可以是任意形状。</p>
<p>相关API：</p>
<p>​    </p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  </code></pre>
<p>​<br>​    </p>
<pre><code>getStructuringElement(int shape, Size ksize, Point anchor);  
// 第一个参数表示形状  
// (比如 MORPH_RECT 矩形\ MORPH_CROSS 十字形\ MORPH_ELLIPSE 曲线形，有时是圆)  
// 第二个参数表示大小  
// 第三个参数表示锚点，默认是Point(-1, -1)，也就是中心像素  
// 这个操作还是很有用的，用它获取结构元素，使图像在它的基础上进行各种操作  

dilate(src, dst, kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue);  
// 膨胀操作，kernel由上面的getStructuringElement得到  

erode(src, dst, kernel, Point anchor, int iterations, int borderType, const Scalar&amp; borderValue);  
// 腐蚀操作，kernel也由上面的getStructuringElement得到  </code></pre>
<p>此外，还可以在图中增加一个滑块用于控制，动态调整结构元素大小。这个操作是通用的，每当用户拖动滑块时都会调用callback函数，以后就可以使用这个操作对图像进行动态编辑了233333</p>
<p>（有一点美中不足的是，trackbar的UI做的相当丑，而且目前我还不知道怎么去改。。不过还好，毕竟这是个图像处理为主的库，应该并不会直接拿来给用户使用）</p>
<p>​    </p>
<pre><code>1  
2  </code></pre>
<p>​<br>​    </p>
<pre><code>createTrackbar(const String &amp;trackbarname, const String winName, int *value, int count, Trackbarcallback func, void *userdata = 0);  
// 其中最主要的是callback函数的功能，如果设置为NULL就是说只有update，但是不会调用callback函数。  </code></pre>
<p>当操作为膨胀时，效果是这样的：</p>
<p><img src="https://s2.ax1x.com/2019/08/04/ey1vHP.png"></p>
<p>当操作为腐蚀时，效果是这样的：</p>
<p><img src="https://s2.ax1x.com/2019/08/04/ey1jBt.png"></p>
<p>源代码：</p>
<p>​    </p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
25  
26  
27  
28  
29  
30  
31  
32  
33  
34  
35  
36  
37  
38  
39  
40  </code></pre>
<p>​<br>​    </p>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;  
#include &lt;iostream&gt;  
#define debug cout &lt;&lt; &quot;ok&quot; &lt;&lt; endl;  

using namespace cv;  
using namespace std;  

Mat src, dst;  
int element_size = 5;  
int max_size = 21;  
char input_title[] = &quot;input image&quot;;  
char output_title[] = &quot;output image&quot;;  

void Callback_Demo(int, void*) &#123;  
    int s = element_size * 2 + 1;  
    Mat structureElement = getStructuringElement(MORPH_RECT, Size(s, s), Point(-1, -1));  
    //dilate(src, dst, structureElement, Point(-1, -1), 1);  
    erode(src, dst, structureElement, Point(-1, -1), 1);  
    imshow(output_title, dst);  
&#125;  </code></pre>
<p>​      </p>
<pre><code>int main() &#123;  
    src = imread(&quot;D:/QQ_files4/1006607327/FileRecv/MobileFile/img1.jpg&quot;);  
    if (!src.data) &#123;  
        cout &lt;&lt; &quot;could not load image...&quot; &lt;&lt; endl;  
        return -1;  
    &#125;  
    char input_title[] = &quot;input image&quot;;  
    char output_title[] = &quot;output image&quot;;  
    namedWindow(input_title, CV_WINDOW_AUTOSIZE);  
    namedWindow(output_title, CV_WINDOW_AUTOSIZE);  
    imshow(input_title, src);  

    createTrackbar(&quot;Element size: &quot;, output_title, &amp;element_size, max_size, Callback_Demo);  
    Callback_Demo(0, 0);  

    waitKey(0);  
    return 0;  
&#125;  </code></pre>
<p>不难看出，膨胀操作和腐蚀操作是什么样的效果呢？</p>
<p>对于膨胀操作，是最大值替换最小值，直观点讲就是白色替换掉黑色，所以膨胀操作之后图上的白色块会越来越大。对于腐蚀操作，是最小值替换最大值，也就是黑色替换掉白色，所以腐蚀操作之后图上的黑色块会越来越大。</p>
<p>那么这个玩意有什么用呢？当你要提取某个图像中的一个大块用于分析时，如果存在同色的小块进行干扰，则你可以使用腐蚀或者膨胀将其消除。</p>
<h2 id="开操作与闭操作"><a href="#开操作与闭操作" class="headerlink" title="开操作与闭操作"></a>开操作与闭操作</h2><p>它其实是上面所说的膨胀操作和腐蚀操作的结合。开操作便是先腐蚀再膨胀。它可以去掉小的对象并且不会对大的对象造成很大影响，假设对象是前景色，背景是黑色。相对的，闭操作就是先膨胀再腐蚀了。</p>
<p>相关API：</p>
<p>​    </p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  </code></pre>
<p>​<br>​    </p>
<pre><code>morphologyEx(src, dest, int OPT, kernel, int Iteration);  
// src和dest是输入图像和输出图像  
// OPT是形态学操作类型，有以下几种：  
// CV_MOP_OPEN \ CV_MOP_CLOSE  
// CV_MOP_GRADIENT \ CV_MOP_TOPHAT  
// CV_MOP \ CV_MOP_BLACKHAT  
// Mat kernel为结构元素  
// int Iteration为迭代次数，默认为1  </code></pre>
<p>这次为了方便测试，我用画图随便画了一张测试用图，图上有一个我想保留的白色大块和不想保留的白色小块，用开操作就能很好的把这个问题解决。</p>
<p>（可以看到，下图的矩形四角部分也被侵蚀掉了一些，这是因为模式选取不准确，这里用MORPH_RECT好一些，但是我用了MORPH_ELLIPSE）</p>
<p><img src="https://s2.ax1x.com/2019/08/04/eyYhF0.png"></p>
<p>源代码：</p>
<p>​    </p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
25  
26  
27  
28  
29  
30  </code></pre>
<p>​<br>​    </p>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;  
#include &lt;iostream&gt;  
#define debug cout &lt;&lt; &quot;ok&quot; &lt;&lt; endl;  

using namespace cv;  
using namespace std;  

Mat src, dst;  
char input_title[] = &quot;input image&quot;;  
char output_title[] = &quot;output image&quot;;  

int main() &#123;  
    src = imread(&quot;D:/imgtest.png&quot;);  
    if (!src.data) &#123;  
        cout &lt;&lt; &quot;could not load image...&quot; &lt;&lt; endl;  
        return -1;  
    &#125;  
    char input_title[] = &quot;input image&quot;;  
    char output_title[] = &quot;output image&quot;;  
    namedWindow(input_title, CV_WINDOW_AUTOSIZE);  
    namedWindow(output_title, CV_WINDOW_AUTOSIZE);  
    imshow(input_title, src);  

    Mat kernel = getStructuringElement(MORPH_ELLIPSE, Size(11, 11), Point(-1, -1));  
    morphologyEx(src, dst, CV_MOP_OPEN, kernel);  
    imshow(output_title, dst);  

    waitKey(0);  
    return 0;  
&#125;  </code></pre>
<p>对于闭操作，它的操作正好相反。如果说开操作的作用是“把多的删掉”，那闭操作就是“把缺的补回来”。</p>
<p>还是假设我们有一个需要提取的白色大块，但是里面有一个黑色的小洞，这时候就可以使用闭操作把小洞补上。</p>
<p>（下图我画的一些小洞比较大，我把Size调到了(17,17)才算可以去掉。。）</p>
<p><img src="https://s2.ax1x.com/2019/08/04/eytaX4.png"></p>
<p>源代码与上面开操作类似。</p>
<p>​    </p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  
9  
10  
11  
12  
13  
14  
15  
16  
17  
18  
19  
20  
21  
22  
23  
24  
25  
26  
27  
28  
29  
30  </code></pre>
<p>​<br>​    </p>
<pre><code>#include &lt;opencv2/opencv.hpp&gt;  
#include &lt;iostream&gt;  
#define debug cout &lt;&lt; &quot;ok&quot; &lt;&lt; endl;  

using namespace cv;  
using namespace std;  

Mat src, dst;  
char input_title[] = &quot;input image&quot;;  
char output_title[] = &quot;output image&quot;;  

int main() &#123;  
    src = imread(&quot;D:/imgtest.png&quot;);  
    if (!src.data) &#123;  
        cout &lt;&lt; &quot;could not load image...&quot; &lt;&lt; endl;  
        return -1;  
    &#125;  
    char input_title[] = &quot;input image&quot;;  
    char output_title[] = &quot;output image&quot;;  
    namedWindow(input_title, CV_WINDOW_AUTOSIZE);  
    namedWindow(output_title, CV_WINDOW_AUTOSIZE);  
    imshow(input_title, src);  

    Mat kernel = getStructuringElement(MORPH_RECT, Size(17, 17), Point(-1, -1));  
    morphologyEx(src, dst, CV_MOP_CLOSE, kernel);  
    imshow(output_title, dst);  

    waitKey(0);  
    return 0;  
&#125;  </code></pre>
<h2 id="形态学梯度操作"><a href="#形态学梯度操作" class="headerlink" title="形态学梯度操作"></a>形态学梯度操作</h2><p>它又称为基本梯度操作（其他的还有内部梯度和方向梯度），操作可以简单理解为膨胀减去腐蚀。</p>
<p>只需要把<code>morphologyEx(src, dst, CV_MOP_CLOSE, kernel);</code>里面的<code>CV_MOP_CLOSE</code>换成<code>CV_MOP_GRADIENT</code>就行了。。。。</p>
<p>做出来效果是这样，感觉好迷。。</p>
<p><img src="https://s2.ax1x.com/2019/08/04/eyaqgK.png"></p>
<p>我加个trackbar调一下试试：</p>
<p><img src="https://s2.ax1x.com/2019/08/04/eydFv8.png"></p>
<p>嗯。。。感觉好多了</p>
<h2 id="顶帽操作与黑帽操作"><a href="#顶帽操作与黑帽操作" class="headerlink" title="顶帽操作与黑帽操作"></a>顶帽操作与黑帽操作</h2><p>顶帽是原图像与开操作之间的差值图像。改一下模式到<code>CV_MOP_TOPHAT</code>就可以。</p>
<p>我们知道，开操作是先腐蚀再膨胀，可以去掉小对象，原图是一个大块加一堆小块，开操作之后图中仅剩一个大块，二者相减后自然是剩下小对象了。如图所示。</p>
<p><img src="https://s2.ax1x.com/2019/08/04/eydlvT.png"></p>
<p>对于黑帽操作，它是闭操作与原图像的差值图像。我们知道，闭操作是“把缺的补回来”，这个图像与原图像做差值的话，剩下的就是通过闭操作补回来的色块。仍然是改一下模式到<code>CV_MOP_BLACKHAT</code>就可以。</p>
<p><img src="https://s2.ax1x.com/2019/08/04/eydoqg.png"></p>
<h2 id="提取水平线与垂直线"><a href="#提取水平线与垂直线" class="headerlink" title="提取水平线与垂直线"></a>提取水平线与垂直线</h2><p>回顾一下，膨胀输出的像素值是结构元素覆盖下输入图像的最大像素值，腐蚀输出的像素值是结构元素覆盖下输入图像的最小像素值。提取水平线与垂直线是形态学操作的一个应用。图像形态学操作的时候，<br>可以通过自定义的结构元素实现结构元素的一种效果，即对输入图像的一些对象敏感、另外一些对象不敏感，这样就会让敏感的对象改变而不敏感的对象保留输出。通过使用两个最基本的形态学操作膨胀与腐蚀，使用不同的结构元素实现对输入图像的操作，得到想要的结果。比如说要提取水平线，发现垂直线对提取有干扰，就通过一些结构元素的操作把垂直线膨胀掉或者腐蚀掉，然后提取水平线就简单了。</p>
<p>这个膨胀与腐蚀过程可以使用任意形状。常见的形状：矩形、圆、直线、磁盘形，钻石形，十字形等等各种自定义形状。</p>
<p>提取步骤简单来说是下面这么做：</p>
<ul>
<li>输入彩色图像imread</li>
<li>转化为灰度图像cvtColor</li>
<li>转换为二值图像adaptiveThreshold</li>
<li>定义结构元素</li>
<li>开操作（腐蚀+膨胀）提取水平线与垂直线</li>
</ul>
<p>其中转换为二值图像adaptiveThreshold这个操作是没有见过的，这里给出原型。</p>
<p>​    </p>
<pre><code>1  
2  
3  
4  
5  
6  
7  
8  </code></pre>
<p>​<br>​    </p>
<pre><code>void adaptiveThreshold( InputArray src, OutputArray dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C );  
// src为输入的灰度图像  
// dst为输出的二值图像  
// maxValue为二值图像的最大值  
// adaptiveMethod为自适应方法，只能是 ADAPTIVE_THRESH_MEAN_C 或 ADAPTIVE_THRESH_GAUSSIAN_C  
// thresholdType为阈值类型  
// blockSize为块大小  
// C是一个常量，可以是正数，0，负数  </code></pre>
<p>这个操作里面有一个小技巧，将输入的src取反（即把<code>src</code>换成<code>~src</code>，让其黑白颠倒，得到的二值图像会比原来更好处理一些）</p>
<p>在没加~的时候是这样的：</p>
<p><img src="https://s2.ax1x.com/2019/08/04/eyrSpR.png"></p>
<p>加了之后是这样的：</p>
<p><img src="https://s2.ax1x.com/2019/08/04/eyrp11.png"></p>
<p>使用对竖线敏感模式擦除竖线之后是这样的：</p>
<p><img src="https://s2.ax1x.com/2019/08/04/eysAK0.png"></p>
<p>使用对横线敏感模式擦除横线之后是这样的：</p>
<p><img src="https://s2.ax1x.com/2019/08/04/eyseVU.png"></p>
<p>源代码（对横线敏感，若要改成对竖线敏感只需要把vline换成hline就可以了）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug cout &lt;&lt; <span class="meta-string">&quot;ok&quot;</span> &lt;&lt; endl;  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line">Mat src, gsrc, binImg, dst;  </span><br><span class="line"><span class="keyword">char</span> input_title[] = <span class="string">&quot;input image&quot;</span>;  </span><br><span class="line"><span class="keyword">char</span> gray_title[] = <span class="string">&quot;gray image&quot;</span>;  </span><br><span class="line"><span class="keyword">char</span> bin_title[] = <span class="string">&quot;bin image&quot;</span>;  </span><br><span class="line"><span class="keyword">char</span> final_title[] = <span class="string">&quot;final image&quot;</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	src = imread(<span class="string">&quot;D:/imgtest2.png&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	namedWindow(input_title, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	namedWindow(gray_title, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	namedWindow(bin_title, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	namedWindow(final_title, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	imshow(input_title, src);  </span><br><span class="line">  </span><br><span class="line">	cvtColor(src, gsrc, CV_BGR2GRAY);  </span><br><span class="line">	imshow(gray_title, gsrc);  </span><br><span class="line">  </span><br><span class="line">	adaptiveThreshold(~gsrc, binImg, <span class="number">255</span>, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, <span class="number">15</span>, <span class="number">-2</span>);  </span><br><span class="line">	imshow(bin_title, binImg);  </span><br><span class="line">  </span><br><span class="line">	Mat hline = getStructuringElement(MORPH_RECT, Size(src.cols / <span class="number">16</span>, <span class="number">1</span>), Point(<span class="number">-1</span>, <span class="number">-1</span>));  </span><br><span class="line">	Mat vline = getStructuringElement(MORPH_RECT, Size(<span class="number">1</span>, src.rows / <span class="number">16</span>), Point(<span class="number">-1</span>, <span class="number">-1</span>));  </span><br><span class="line">  </span><br><span class="line">	Mat temp;  </span><br><span class="line">	erode(binImg, temp, vline);  </span><br><span class="line">	dilate(temp, dst, vline);  </span><br><span class="line">	imshow(final_title, dst);  </span><br><span class="line">  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="拓展：识别简单的验证码"><a href="#拓展：识别简单的验证码" class="headerlink" title="拓展：识别简单的验证码"></a>拓展：识别简单的验证码</h2><p>这里我先自己造一个简单的验证码，并且为其加一些干扰。</p>
<p><img src="https://s2.ax1x.com/2019/08/04/ey6FBV.png"></p>
<p>然后我们采用矩形结构的掩膜，并对其做一次膨胀和腐蚀，然后用bitwise_not取一下反，最后用blur模糊平滑一下，看看效果如何。</p>
<p>嗯。。。可能对于它来说，这个验证码还是有点难。。效果还算可以吧。。不过至少它可以完整的提取出文字信息了。。</p>
<p><img src="https://s2.ax1x.com/2019/08/04/eyci2d.png"></p>
<p>源代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug cout &lt;&lt; <span class="meta-string">&quot;ok&quot;</span> &lt;&lt; endl;  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line">Mat src, gsrc, binImg, dst;  </span><br><span class="line"><span class="keyword">char</span> input_title[] = <span class="string">&quot;input image&quot;</span>;  </span><br><span class="line"><span class="keyword">char</span> gray_title[] = <span class="string">&quot;gray image&quot;</span>;  </span><br><span class="line"><span class="keyword">char</span> bin_title[] = <span class="string">&quot;bin image&quot;</span>;  </span><br><span class="line"><span class="keyword">char</span> final_title[] = <span class="string">&quot;final image&quot;</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	src = imread(<span class="string">&quot;D:/yzm.png&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	namedWindow(input_title, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	namedWindow(gray_title, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	namedWindow(bin_title, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	namedWindow(final_title, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	imshow(input_title, src);  </span><br><span class="line">  </span><br><span class="line">	cvtColor(src, gsrc, CV_BGR2GRAY);  </span><br><span class="line">	imshow(gray_title, gsrc);  </span><br><span class="line">  </span><br><span class="line">	adaptiveThreshold(~gsrc, binImg, <span class="number">255</span>, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, <span class="number">15</span>, <span class="number">-2</span>);  </span><br><span class="line">	imshow(bin_title, binImg);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//	Mat hline = getStructuringElement(MORPH_RECT, Size(src.cols / 16, 1), Point(-1, -1));  </span></span><br><span class="line"><span class="comment">//	Mat vline = getStructuringElement(MORPH_RECT, Size(1, src.rows / 16), Point(-1, -1));  </span></span><br><span class="line">	Mat kernel = getStructuringElement(MORPH_RECT, Size(<span class="number">2</span>, <span class="number">2</span>), Point(<span class="number">-1</span>, <span class="number">-1</span>));  </span><br><span class="line">  </span><br><span class="line">	Mat temp;  </span><br><span class="line">	erode(binImg, temp, kernel);  </span><br><span class="line">	dilate(temp, dst, kernel);  </span><br><span class="line">  </span><br><span class="line">	bitwise_not(dst, dst);  </span><br><span class="line">	blur(dst, dst, Size(<span class="number">1</span>, <span class="number">1</span>), Point(<span class="number">-1</span>, <span class="number">-1</span>));  </span><br><span class="line">  </span><br><span class="line">	imshow(final_title, dst);  </span><br><span class="line">  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h2><blockquote>
<p>图像金字塔是图像多尺度表达的一种，是一种以多分辨率来解释图像的有效但概念简单的结构。一幅图像的金字塔是一系列以金字塔形状排列的分辨率逐步降低，且来源于同一张原始图的图像集合。其通过梯次向下采样获得，直到达到某个终止条件才停止采样。我们将一层一层的图像比喻成金字塔，层级越高，则图像越小，分辨率越低。</p>
<p>——摘自百度百科“图像金字塔”</p>
</blockquote>
<p>这是一个简单的示意图。</p>
<p><img src="https://s2.ax1x.com/2019/08/05/ec7DOK.png"></p>
<p>简单来讲，当图像从顶向下进行采样时，由于包含的色块增多，分辨率就会逐步提高，这便是放大图片的效果，称为上采样。相反的，当图像从底向上进行采样时，分辨率就会逐步降低，这便是缩小图片的效果，称为降采样。</p>
<p>高斯金字塔多用于降采样。它是从底向上，逐层采样得到。降采样之后图像的大小是原图像的四分之一（长宽都变为原来的一半），在实现上是对原图像删除偶数行和偶数列即可。它的生成过程分为两步。首先对整张图片进行高斯模糊，然后删除当前层的偶数行和偶数列，即可得到上一层的图像。</p>
<p>此外，还有拉普拉斯采样。</p>
<p>拓展概念： <strong>高斯不同（Difference of Gaussian，DOG）</strong><br>就是把同一张图像在不同的参数下做高斯模糊之后的结果相减，得到的输出图像，这样的图像称为高斯不同。高斯不同是图像的内在特征，在灰度图像增强，角点检测中经常用到。</p>
<p>相关API：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pyrUp(Mat src, Mat dst, Size(src.cols*<span class="number">2</span>, src.rows*<span class="number">2</span>));  </span><br><span class="line"><span class="comment">// 上采样，生成的图像是原来的四倍大小，长宽各自变为原来的二倍  </span></span><br><span class="line">pyrDown(Mat src, Mat dst, Size(src.cols*<span class="number">2</span>, src.rows*<span class="number">2</span>));  </span><br><span class="line"><span class="comment">// 降采样，生成的图像是原来的四分之一大小，长宽各自变为原来的二分之一  </span></span><br></pre></td></tr></table></figure>

<p>放大图像测试：</p>
<p><img src="https://s2.ax1x.com/2019/08/05/ecLitg.png"></p>
<p>缩小图像测试：</p>
<p><img src="https://s2.ax1x.com/2019/08/05/ecLApj.png"></p>
<p>源代码（缩小）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug cout &lt;&lt; <span class="meta-string">&quot;ok&quot;</span> &lt;&lt; endl;  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line">Mat src, dst;  </span><br><span class="line"><span class="keyword">char</span> input_title[] = <span class="string">&quot;input image&quot;</span>;  </span><br><span class="line"><span class="keyword">char</span> output_title[] = <span class="string">&quot;output image&quot;</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	src = imread(<span class="string">&quot;D:/pics/cover.jpg&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	imshow(input_title, src);  </span><br><span class="line">	pyrDown(src, dst, Size(src.cols / <span class="number">2</span>, src.rows / <span class="number">2</span>));  </span><br><span class="line">	imshow(output_title, dst);  </span><br><span class="line">  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>通过上采样和降采样操作后得到高斯不同（DOG）：</p>
<p><img src="https://s2.ax1x.com/2019/08/05/ecXDOI.png"></p>
<p>在源代码中使用了两个新的API，一个是<code>substract</code>，另一个是<code>normalize</code>，<code>substract</code>顾名思义是进行相减操作，而<code>normalize</code>的作用比较不明确，bing查得其作用为归一化输入数组，使它的范数或者数值范围在一定的范围内。它支持多种归一化类型，其中这里用的是<code>NORM_MINMAX</code>，<br>数组的数值被平移或缩放到一个指定的范围，线性归一化，一般较常用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug cout &lt;&lt; <span class="meta-string">&quot;ok&quot;</span> &lt;&lt; endl;  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line">Mat src, srcUp, srcDown;  </span><br><span class="line"><span class="keyword">char</span> input_title[] = <span class="string">&quot;input image&quot;</span>;  </span><br><span class="line"><span class="keyword">char</span> Up_title[] = <span class="string">&quot;srcUp image&quot;</span>;  </span><br><span class="line"><span class="keyword">char</span> Down_title[] = <span class="string">&quot;srcDown image&quot;</span>;  </span><br><span class="line"><span class="keyword">char</span> DOG_title[] = <span class="string">&quot;DOG image&quot;</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	src = imread(<span class="string">&quot;D:/pics/cover.jpg&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	imshow(input_title, src);  </span><br><span class="line">  </span><br><span class="line">	pyrDown(src, srcDown, Size(src.cols / <span class="number">2</span>, src.rows / <span class="number">2</span>));  </span><br><span class="line">	imshow(Down_title, srcDown);  </span><br><span class="line">  </span><br><span class="line">	pyrUp(src, srcUp, Size(src.cols * <span class="number">2</span>, src.rows * <span class="number">2</span>));  </span><br><span class="line">	imshow(Up_title, srcUp);  </span><br><span class="line">  </span><br><span class="line">	Mat gray_src, g1, g2, dogImg;  </span><br><span class="line">	cvtColor(src, gray_src, CV_BGR2GRAY);  </span><br><span class="line">	GaussianBlur(gray_src, g1, Size(<span class="number">3</span>, <span class="number">3</span>), <span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">	GaussianBlur(g1, g2, Size(<span class="number">3</span>, <span class="number">3</span>), <span class="number">0</span>);  </span><br><span class="line">	subtract(g1, g2, dogImg, Mat());  </span><br><span class="line">	normalize(dogImg, dogImg, <span class="number">255</span>, <span class="number">0</span>, NORM_MINMAX);  </span><br><span class="line">	imshow(DOG_title, dogImg);  </span><br><span class="line">  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>注意到当<code>Size()</code>的取值变大时，高斯不同操作结果后的图像轮廓越清晰。</p>
<h2 id="阈值类型"><a href="#阈值类型" class="headerlink" title="阈值类型"></a>阈值类型</h2><p> <strong>阈值二值化（threshold binary）</strong> ，设定一个标线，超过此标线的按满处理，不足此标线的按0处理。</p>
<p><img src="https://s2.ax1x.com/2019/08/06/eWa19H.png"></p>
<p><strong>阈值反二值化（threshold binary inverted）</strong> ，设定一个标线，超过此标线的按0处理，不足此标线的按满处理。</p>
<p><img src="https://s2.ax1x.com/2019/08/06/eWdAIS.png"></p>
<p><strong>截断（truncate）</strong> ，设定一个标线，超过此标线的取标线值，不足此标线的不动。</p>
<p><img src="https://s2.ax1x.com/2019/08/06/eWdTJg.png"></p>
<p><strong>阈值取零（threshold to zero）</strong> ，设定一个标线，超过此标线的不动，不足此标线的按0处理。</p>
<p><img src="https://s2.ax1x.com/2019/08/06/eWdje0.png"></p>
<p><strong>阈值反取零（threshold to zero inverted）</strong> ，设定一个标线，超过此标线的按0处理，不足此标线的不动。</p>
<p><img src="https://s2.ax1x.com/2019/08/06/eWw06s.png"></p>
<p>那么在OpenCV里，如何去确定使用什么阈值呢？其实已经给了相关的参数。</p>
<p><img src="https://s2.ax1x.com/2019/08/06/eW0mBq.png"></p>
<p>其中有两个比较特殊的<code>THRESH_OTSU</code>和<code>THRESH_TRIANGLE</code>，它们可以调用Otsu算法或Triangle算法对当前图片选择合适的阈值。<br>至于<code>THRESH_MASK</code>，我没查到这东西是干啥的，OpenCV社区中有回帖这么说：</p>
<blockquote>
<p>obsolete constant? in opencv 2.2 (nov-2010) you can find THRESH_MASK<br><a href="https://github.com/opencv/opencv/blob/2.2/modules/imgproc/src/thresh.cpp#L479-L523">https://github.com/opencv/opencv/blob…</a><br>In opencv 4 it is defined but not used.</p>
<p><a href="https://answers.opencv.org/users/8129/lberger/">LBerger</a> (Apr 15 ‘19)</p>
</blockquote>
<p>然后我在GitHub里的源码中也没找到关于<code>THRESH_MASK</code>的有关信息。。。算了，不管他了</p>
<h2 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h2><p>先来测试阈值二值化的效果，看起来127的效果并不是很好，使用trackbar稍微调整了一下，192看起来还可以：</p>
<p>（原图裂了）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug cout &lt;&lt; <span class="meta-string">&quot;ok&quot;</span> &lt;&lt; endl;  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line">Mat src, gsrc, dst;  </span><br><span class="line"><span class="keyword">int</span> thresholdval = <span class="number">127</span>;  </span><br><span class="line"><span class="keyword">int</span> threshold_max = <span class="number">255</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* input_title = <span class="string">&quot;src image&quot;</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* output_title = <span class="string">&quot;binary image&quot;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Threshold_Demo</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span> </span>&#123;  </span><br><span class="line">	cvtColor(src, gsrc, CV_BGR2GRAY);  </span><br><span class="line">	threshold(gsrc, dst, thresholdval, threshold_max, THRESH_BINARY);  </span><br><span class="line">	imshow(output_title, dst);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	src = imread(<span class="string">&quot;D:/pics/lovelive.jpg&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	namedWindow(input_title, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	namedWindow(output_title, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	imshow(input_title, src);  </span><br><span class="line">  </span><br><span class="line">	createTrackbar(<span class="string">&quot;Threshold Value:&quot;</span>, output_title, &amp;thresholdval, threshold_max, Threshold_Demo);  </span><br><span class="line">	Threshold_Demo(<span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<p>再来测试一下阈值反二值化：（原图裂了）</p>
<p>妈耶好恐怖。。。。还是192的时候看起来比较合适。</p>
<p>然后是截断、阈值取零、阈值反取零，来回调整还是有些麻烦，不如再借助一下trackbar让它能同时调整一下模式：（原图裂了）</p>
<p>其实能用trackbar调整模式的原因是什么呢？可以尝试一下直接输出上表中那几个<code>THRESH_</code>打头的参数，你会发现它们其实就是0~4的整数值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug cout &lt;&lt; <span class="meta-string">&quot;ok&quot;</span> &lt;&lt; endl;  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line">Mat src, gsrc, dst;  </span><br><span class="line"><span class="keyword">int</span> thresholdval = <span class="number">127</span>;  </span><br><span class="line"><span class="keyword">int</span> threshold_max = <span class="number">255</span>;  </span><br><span class="line"><span class="keyword">int</span> type_value = <span class="number">2</span>;  </span><br><span class="line"><span class="keyword">int</span> type_max = <span class="number">4</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* input_title = <span class="string">&quot;src image&quot;</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* output_title = <span class="string">&quot;binary image&quot;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Threshold_Demo</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span> </span>&#123;  </span><br><span class="line">	cvtColor(src, gsrc, CV_BGR2GRAY);  </span><br><span class="line">	threshold(gsrc, dst, thresholdval, threshold_max, type_value);  </span><br><span class="line">	imshow(output_title, dst);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	src = imread(<span class="string">&quot;D:/pics/lovelive.jpg&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	namedWindow(input_title, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	namedWindow(output_title, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	imshow(input_title, src);  </span><br><span class="line">  </span><br><span class="line">	createTrackbar(<span class="string">&quot;Threshold Value:&quot;</span>, output_title, &amp;thresholdval, threshold_max, Threshold_Demo);  </span><br><span class="line">	createTrackbar(<span class="string">&quot;Type Value:&quot;</span>, output_title, &amp;type_value, type_max, Threshold_Demo);  </span><br><span class="line">	Threshold_Demo(<span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>刚才说到Otsu算法和Triangle算法，可以通过它进行调试，只需要将<code>threshold(gsrc, dst, thresholdval, threshold_max, type_value);</code>中的<code>type_value</code>换成<code>THRESH_OTSU | type_value</code>或者<code>THRESH_TRIANGLE | type_value</code>就可以。此时它会根据算法计算合适的阈值，这时拖动阈值滑块就无效了。（原图裂了）</p>
<h2 id="复习卷积"><a href="#复习卷积" class="headerlink" title="复习卷积"></a>复习卷积</h2><p> <strong>卷积</strong> 是图像处理中的一个操作，是kernel在图像的每个像素上的操作。kernel本质上是一个固定大小的矩阵数组，其中心点称之为锚点。</p>
<p>卷积如何工作？把kernel放到像素数组之上，求锚点周围覆盖的像素乘积之和（包括锚点）， 用来替换锚点覆盖下像素点值称为卷积处理。</p>
<p>卷积有三个作用。</p>
<ul>
<li>模糊图像</li>
<li>提取边缘</li>
<li>进行图像增强，比如锐化</li>
</ul>
<p>采用卷积进行图像的处理，每一个小块的卷积和称之为 <strong>算子</strong><br>。根据对图像的操作不同，算子也就不同。有一些比较经典的算子比如Robert算子，Sobel算子和Laplance算子。</p>
<h2 id="简单的算子应用"><a href="#简单的算子应用" class="headerlink" title="简单的算子应用"></a>简单的算子应用</h2><p>Robert算子，X方向：</p>
<p><img src="https://s2.ax1x.com/2019/08/16/mZvNqS.png"></p>
<p>Robert算子，Y方向：</p>
<p><img src="https://s2.ax1x.com/2019/08/16/mZvfIJ.png"></p>
<p>两个算子体现了在给定方向梯度上差异的最大体现。实际上，Robert算子是一种梯度算子。</p>
<p>尝试一下将两个算子计算出的结果相加后取反输出，是这样的：</p>
<p><img src="https://s2.ax1x.com/2019/08/16/mepFeK.png"></p>
<p>源代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	Mat src, dst;  </span><br><span class="line">	Mat robertx, roberty;  </span><br><span class="line">	<span class="keyword">int</span> ksize = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">	src = imread(<span class="string">&quot;D:/pics/lovelive.jpg&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">char</span> input_WIN[] = <span class="string">&quot;input image&quot;</span>;  </span><br><span class="line">	<span class="keyword">char</span> output_WIN[] = <span class="string">&quot;output image&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">	imshow(input_WIN, src);  </span><br><span class="line">	<span class="comment">// Robert operator, direction X  </span></span><br><span class="line">	Mat kernelx = (Mat_&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">2</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>);  </span><br><span class="line">	filter2D(src, robertx, <span class="number">-1</span>, kernelx, Point(<span class="number">-1</span>, <span class="number">-1</span>), <span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// Robert operator, direction Y  </span></span><br><span class="line">	Mat kernely = (Mat_&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">2</span>) &lt;&lt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>);  </span><br><span class="line">	filter2D(src, roberty, <span class="number">-1</span>, kernely, Point(<span class="number">-1</span>, <span class="number">-1</span>), <span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">	add(robertx, roberty, dst);  </span><br><span class="line">  </span><br><span class="line">	imshow(output_WIN, ~dst);  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>Sobel算子：</p>
<p>还是相加后取反输出，结果是这样，看起来要比Robert强一些。。。？它体现的差异值要比Robert更大一些，所以看起来效果会更好。</p>
<p><img src="https://s2.ax1x.com/2019/08/17/mum6zt.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	Mat src, dst;  </span><br><span class="line">	Mat sobelx, sobely;  </span><br><span class="line">	<span class="keyword">int</span> ksize = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">	src = imread(<span class="string">&quot;D:/pics/lovelive.jpg&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">char</span> input_WIN[] = <span class="string">&quot;input image&quot;</span>;  </span><br><span class="line">	<span class="keyword">char</span> output_WIN[] = <span class="string">&quot;output image&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">	imshow(input_WIN, src);  </span><br><span class="line">	<span class="comment">// Sobel operator, direction X  </span></span><br><span class="line">	Mat kernelx = (Mat_&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>);  </span><br><span class="line">	filter2D(src, sobelx, <span class="number">-1</span>, kernelx, Point(<span class="number">-1</span>, <span class="number">-1</span>), <span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// Sobel operator, direction Y  </span></span><br><span class="line">	Mat kernely = (Mat_&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);  </span><br><span class="line">	filter2D(src, sobely, <span class="number">-1</span>, kernely, Point(<span class="number">-1</span>, <span class="number">-1</span>), <span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">	add(sobelx, sobely, dst);  </span><br><span class="line">  </span><br><span class="line">	imshow(output_WIN, ~dst);  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>Laplance算子：</p>
<p><img src="https://s2.ax1x.com/2019/08/17/mumzFJ.png"></p>
<p>（仍然是对dst取反后输出）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	Mat src, dst;  </span><br><span class="line">	<span class="keyword">int</span> ksize = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">	src = imread(<span class="string">&quot;D:/pics/lovelive.jpg&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">char</span> input_WIN[] = <span class="string">&quot;input image&quot;</span>;  </span><br><span class="line">	<span class="keyword">char</span> output_WIN[] = <span class="string">&quot;output image&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">	imshow(input_WIN, src);  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// Laplance operator  </span></span><br><span class="line">	Mat kernel = (Mat_&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);  </span><br><span class="line">	filter2D(src, dst, <span class="number">-1</span>, kernel, Point(<span class="number">-1</span>, <span class="number">-1</span>), <span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">	imshow(output_WIN, ~dst);  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="自定义卷积模糊"><a href="#自定义卷积模糊" class="headerlink" title="自定义卷积模糊"></a>自定义卷积模糊</h2><p>核心在flit2D这个方法上面。这里给出原型解释：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">filter2D</span><span class="params">(   </span></span></span><br><span class="line"><span class="function"><span class="params">   	InputArray src, <span class="comment">// 输入图像  </span></span></span></span><br><span class="line"><span class="function"><span class="params">    OutputArray dst,  <span class="comment">// 输出图像  </span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> ddepth, <span class="comment">// 图像深度，一般默认-1，即自动  </span></span></span></span><br><span class="line"><span class="function"><span class="params">    InputArray kernel,  <span class="comment">// 卷积模板，输入一个Mat对象  </span></span></span></span><br><span class="line"><span class="function"><span class="params">    Point anchor = Point(<span class="number">-1</span>,<span class="number">-1</span>), <span class="comment">// 锚点位置，一般默认Point(-1, -1)，即中心点  </span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">double</span> delta = <span class="number">0</span>, <span class="comment">// 计算出来的像素+delta  </span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> borderType = BORDER_DEFAULT <span class="comment">// 不清楚这个是干嘛的。。  </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;  </span><br></pre></td></tr></table></figure>

<p>采用一些方法可以让它动起来，这个是静态的效果图（懒得录gif了）</p>
<p><img src="https://s2.ax1x.com/2019/08/18/mQmSnP.png"></p>
<p>源代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	Mat src, dst;  </span><br><span class="line">	<span class="keyword">int</span> ksize = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">	src = imread(<span class="string">&quot;D:/pics/lovelive.jpg&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">char</span> input_WIN[] = <span class="string">&quot;input image&quot;</span>;  </span><br><span class="line">	<span class="keyword">char</span> output_WIN[] = <span class="string">&quot;output image&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">	imshow(input_WIN, src);  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// Custom operator demo  </span></span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">int</span> dir = <span class="number">1</span>;  </span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">		c = waitKey(<span class="number">1</span>);  </span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">char</span>)c == <span class="number">27</span>) <span class="comment">// 27是esc键  </span></span><br><span class="line">			<span class="keyword">break</span>;  </span><br><span class="line">		<span class="keyword">else</span> &#123;  </span><br><span class="line">			ksize = <span class="number">4</span> + index * <span class="number">2</span> + <span class="number">1</span>;  </span><br><span class="line">			Mat kernel = Mat::ones(Size(ksize, ksize), CV_32F) / (<span class="keyword">float</span>)(ksize * ksize);  </span><br><span class="line">			filter2D(src, dst, <span class="number">-1</span>, kernel, Point(<span class="number">-1</span>, <span class="number">-1</span>));  </span><br><span class="line">			index += dir;  </span><br><span class="line">			<span class="keyword">if</span> (index == <span class="number">8</span> || index == <span class="number">0</span>)  </span><br><span class="line">				dir = -dir;  </span><br><span class="line">			imshow(output_WIN, dst);  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>其中<code>Mat::ones</code>是以前没见过的方法，给出的原解释是：</p>
<blockquote>
<p>The method returns a Matlab-style identity matrix initializer, similarly to<br>Mat::zeros. Similarly to Mat::ones, you can use a scale operation to create<br>a scaled identity matrix efficiently.</p>
<p>翻译：该方法返回一个matlab样式的单位矩阵初始化器，类似于Mat::zeros。与Mat::ones类似，您可以使用缩放操作来高效地创建缩放的单位矩阵。</p>
</blockquote>
<p>应该是一个用来初始化的东西吧……</p>
<h2 id="卷积边界问题"><a href="#卷积边界问题" class="headerlink" title="卷积边界问题"></a>卷积边界问题</h2><p>图像卷积的时候边界像素，不能被卷积操作。原因在于边界像素没有完全跟kernel重叠，所以当3×3滤波的时候会有1个像素的边缘没有被处理，5×5滤波的时候会有2个像素的边缘没有被处理。</p>
<p>（Emmmmm。。具体原因也许我会再探究一下，对卷积的计算原理上感觉消化的不是很透彻）</p>
<h2 id="处理边缘"><a href="#处理边缘" class="headerlink" title="处理边缘"></a>处理边缘</h2><p>在卷积开始之前增加边缘像素，<br>填充的像素值为0或者RGB黑色，比如3×3在四周各填充1个像素的边缘，这样就能确保图像的边缘被处理。在卷积处理之后，再把这些边缘去掉。openCV中有一个默认的处理方法，即<code>BORDER_DEFAULT</code>，此外还有<code>BORDER_CONSTANT</code>可以用指定像素值填充边缘，<code>BORDER_REPLICATE</code>用已知的边缘像素值填充边缘，<code>BORDER_WRAP</code>用另外一边的像素来补偿填充。</p>
<p>相关API：给图像添加边缘</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">copyMakeBorder &#123;  </span><br><span class="line">	Mat src, <span class="comment">// 输入图像  </span></span><br><span class="line">	Mat dst, <span class="comment">// 输出图像  </span></span><br><span class="line">	<span class="keyword">int</span> top, <span class="comment">// 边缘长度，一般来说上下左右都取相同值  </span></span><br><span class="line">	<span class="keyword">int</span> bottom,  </span><br><span class="line">	<span class="keyword">int</span> left,  </span><br><span class="line">	<span class="keyword">int</span> right,  </span><br><span class="line">	<span class="keyword">int</span> borderType, <span class="comment">// 边缘类型  </span></span><br><span class="line">	Scalar value <span class="comment">// 颜色  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><p>这里通过按键来控制使用哪一个边缘类型。不难看出，不同的<code>borderType</code>总会让dst的长和宽增加（边缘），只是增加的形式不同。</p>
<p>这是default:</p>
<p><img src="https://s2.ax1x.com/2019/08/24/m6dyi6.png"></p>
<p>这是wrap：</p>
<p><img src="https://s2.ax1x.com/2019/08/24/m6dTFP.png"></p>
<p>这是constant：</p>
<p>（由于采用了随机颜色，其实这个颜色是在不断变化的）</p>
<p><img src="https://s2.ax1x.com/2019/08/24/m6wwp8.png"></p>
<p>这是replicate：</p>
<p><img src="https://s2.ax1x.com/2019/08/24/m6wy0s.png"></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	Mat src, dst;  </span><br><span class="line">	<span class="keyword">int</span> ksize = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">	src = imread(<span class="string">&quot;D:/pic.png&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">char</span> input_WIN[] = <span class="string">&quot;input image&quot;</span>;  </span><br><span class="line">	<span class="keyword">char</span> output_WIN[] = <span class="string">&quot;output image&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">int</span> top = (<span class="keyword">int</span>)(<span class="number">0.05</span> * src.rows);  </span><br><span class="line">	<span class="keyword">int</span> bottom = (<span class="keyword">int</span>)(<span class="number">0.05</span> * src.rows);  </span><br><span class="line">	<span class="keyword">int</span> left = (<span class="keyword">int</span>)(<span class="number">0.05</span> * src.cols);  </span><br><span class="line">	<span class="keyword">int</span> right = (<span class="keyword">int</span>)(<span class="number">0.05</span> * src.cols);  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 采用随机数以得到随机划线的效果  </span></span><br><span class="line">	<span class="function">RNG <span class="title">rng</span><span class="params">(<span class="number">12345</span>)</span></span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">int</span> borderType = BORDER_DEFAULT;  </span><br><span class="line">	imshow(input_WIN, src);  </span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">		c = waitKey(<span class="number">500</span>);  </span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">char</span>)c == <span class="number">27</span>) <span class="comment">// esc  </span></span><br><span class="line">			<span class="keyword">break</span>;  </span><br><span class="line">		<span class="keyword">else</span> &#123;  </span><br><span class="line">			<span class="keyword">if</span> ((<span class="keyword">char</span>)c == <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">				borderType = BORDER_REPLICATE;  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">char</span>)c == <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">				borderType = BORDER_WRAP;  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">char</span>)c == <span class="string">&#x27;c&#x27;</span>)  </span><br><span class="line">				borderType = BORDER_CONSTANT;  </span><br><span class="line">			<span class="keyword">else</span>  </span><br><span class="line">				borderType = BORDER_DEFAULT;  </span><br><span class="line">			Scalar color = Scalar(rng.uniform(<span class="number">0</span>, <span class="number">255</span>), rng.uniform(<span class="number">0</span>, <span class="number">255</span>), rng.uniform(<span class="number">0</span>, <span class="number">255</span>));  </span><br><span class="line">			copyMakeBorder(src, dst, top, bottom, left, right, borderType, color);  </span><br><span class="line">			imshow(output_WIN, dst);  </span><br><span class="line">  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>用高斯模糊测试一下：</p>
<p><img src="https://s2.ax1x.com/2019/08/24/m6DDXD.png"></p>
<p>源代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	Mat src, dst, dst2, dst3;  </span><br><span class="line">	<span class="keyword">int</span> ksize = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">	src = imread(<span class="string">&quot;D:/pic.png&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">char</span> input_WIN[] = <span class="string">&quot;input image&quot;</span>;  </span><br><span class="line">	<span class="keyword">char</span> output_WIN[] = <span class="string">&quot;output image&quot;</span>;  </span><br><span class="line">	<span class="keyword">char</span> no_border_output_WIN[] = <span class="string">&quot;no border output image&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">int</span> top = (<span class="keyword">int</span>)(<span class="number">0.05</span> * src.rows);  </span><br><span class="line">	<span class="keyword">int</span> bottom = (<span class="keyword">int</span>)(<span class="number">0.05</span> * src.rows);  </span><br><span class="line">	<span class="keyword">int</span> left = (<span class="keyword">int</span>)(<span class="number">0.05</span> * src.cols);  </span><br><span class="line">	<span class="keyword">int</span> right = (<span class="keyword">int</span>)(<span class="number">0.05</span> * src.cols);  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 采用随机数以得到随机划线的效果  </span></span><br><span class="line">	<span class="function">RNG <span class="title">rng</span><span class="params">(<span class="number">12345</span>)</span></span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">int</span> borderType = BORDER_DEFAULT;  </span><br><span class="line">	imshow(input_WIN, src);  </span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">		c = waitKey(<span class="number">500</span>);  </span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">char</span>)c == <span class="number">27</span>) <span class="comment">// esc  </span></span><br><span class="line">			<span class="keyword">break</span>;  </span><br><span class="line">		<span class="keyword">else</span> &#123;  </span><br><span class="line">			<span class="keyword">if</span> ((<span class="keyword">char</span>)c == <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">				borderType = BORDER_REPLICATE;  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">char</span>)c == <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">				borderType = BORDER_WRAP;  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">char</span>)c == <span class="string">&#x27;c&#x27;</span>)  </span><br><span class="line">				borderType = BORDER_CONSTANT;  </span><br><span class="line">			<span class="keyword">else</span>  </span><br><span class="line">				borderType = BORDER_DEFAULT;  </span><br><span class="line">			Scalar color = Scalar(rng.uniform(<span class="number">0</span>, <span class="number">255</span>), rng.uniform(<span class="number">0</span>, <span class="number">255</span>), rng.uniform(<span class="number">0</span>, <span class="number">255</span>));  </span><br><span class="line">			copyMakeBorder(src, dst, top, bottom, left, right, borderType, color);  </span><br><span class="line">			GaussianBlur(dst, dst2, Size(<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">			GaussianBlur(src, dst3, Size(<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">			imshow(no_border_output_WIN, dst3);  </span><br><span class="line">			imshow(output_WIN, dst2);  </span><br><span class="line">  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h2><p>Sobel算子是离散微分算子（discrete differentiation<br>operator），用来计算图像灰度的近似梯度。梯度越大的地方，越可能是图像的边缘。</p>
<p>比如在一幅图的一小块区域当中出现了黑与白之间的渐变，像是人脸轮廓与头发之间的渐变，这种渐变通常看起来是瞬间的，其实它们在中间总会有一个很短的变化过程，或者说，像素发生了跃迁。在头发区域是黑色的，在人脸区域是白色的，而它们之间总会有一段颜色的变化，这个变化是按照慢-<br>快-慢的规律进行的。如果我们把像素渐变的这个过程抽象成函数，也许它看起来像是一个三次函数。</p>
<p><img src="https://s2.ax1x.com/2019/08/25/m28RxJ.jpg"></p>
<p>那么它总能找到一个变化率最高的点，不难理解，只需一次求导就可以得到这个点。Sobel算子便是会判断这里为图像的边缘。</p>
<p><img src="https://s2.ax1x.com/2019/08/25/m2GDQH.jpg"></p>
<p>Sobel算子的功能集合了高斯平滑和微分求导两个方面，所以又称一阶微分算子、求导算子。在水平和垂直两个方向上求导，可以得到图像X方向与Y方向的梯度图像。所以说，只要说到求图像的梯度图像，想到使用Sobel算子就好。</p>
<p>它是怎么实现的呢？简单来说，它会扩大选定方向上的差异，通过给算子两侧赋予一定的值，让被处理的图片的位置上的像素值出现更大的差来扩大差异，达到一个凸显轮廓的效果。</p>
<p>水平梯度上：</p>
<p><img src="https://s2.ax1x.com/2019/08/25/m2JT3D.png"></p>
<p>垂直梯度上：</p>
<p><img src="https://s2.ax1x.com/2019/08/25/m2Jo9O.png"></p>
<p>最终图像梯度（上式为准确定义公式，下式是为了减少计算机的计算量采用的近似公式）：</p>
<p><img src="https://s2.ax1x.com/2019/08/25/m2J7ge.png"></p>
<p>然而在实际应用中，Sobel算子在kernel=3时不是很准确，OpenCV中采用了改进版本的Scharr算子，它的算子如下：</p>
<p><img src="https://s2.ax1x.com/2019/08/25/m2Y1bR.png"></p>
<p>Sobel算子与Scharr算子的相关API：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sobel (  </span><br><span class="line">	InputArray src, <span class="comment">// 输入图像  </span></span><br><span class="line">	OutputArray dst,<span class="comment">// 输出图像，大小与输入图像一致  </span></span><br><span class="line">	<span class="keyword">int</span> depth, <span class="comment">// 输出图像深度 一定要比输出图像的深度大或者深度相等，不可以比他小。当然，遇事不决写-1。-1代表与原来深度相同。  </span></span><br><span class="line">	<span class="keyword">int</span> dx, <span class="comment">// X方向，几阶导数  </span></span><br><span class="line">	<span class="keyword">int</span> dy, <span class="comment">// Y方向，几阶导数.   </span></span><br><span class="line">	<span class="keyword">int</span> ksize, <span class="comment">// SOBEL算子kernel大小，必须是1、3、5、7、9等奇数  </span></span><br><span class="line">	<span class="keyword">double</span> scale  = <span class="number">1</span>,  </span><br><span class="line">	<span class="keyword">double</span> delta = <span class="number">0</span>,  </span><br><span class="line">	<span class="keyword">int</span> borderType = BORDER_DEFAULT  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line">Scharr (  </span><br><span class="line">	InputArray src, <span class="comment">// 输入图像  </span></span><br><span class="line">	OutputArray dst, <span class="comment">// 输出图像，大小与输入图像一致  </span></span><br><span class="line">	<span class="keyword">int</span> depth, <span class="comment">// 输出图像深度.   </span></span><br><span class="line">	<span class="keyword">int</span> dx,  <span class="comment">// X方向，几阶导数  </span></span><br><span class="line">	<span class="keyword">int</span> dy, <span class="comment">// Y方向，几阶导数.   </span></span><br><span class="line">	<span class="keyword">double</span> scale  = <span class="number">1</span>,  </span><br><span class="line">	<span class="keyword">double</span> delta = <span class="number">0</span>,  </span><br><span class="line">	<span class="keyword">int</span> borderType = BORDER_DEFAULT  </span><br><span class="line">)  </span><br></pre></td></tr></table></figure>

<h2 id="对Sobel算子的应用"><a href="#对Sobel算子的应用" class="headerlink" title="对Sobel算子的应用"></a>对Sobel算子的应用</h2><p>一般可以用来做边缘提取（和上一节说的那个边缘不是一个边缘= =）。</p>
<p>边缘是什么？是像素值发生跃迁的地方，是图像的显著特征之一。在图像特征提取、对象检测、模式识别等方面都有重要的作用。</p>
<p>那么如何捕捉/提取边缘呢？只需要对图像求它的一阶导数就可以。</p>
<p>我们知道，<code>Δ = f(x) – f(x-1)</code>，Δ越大，说明像素在x方向变化越大，边缘信号越强。</p>
<p>应用操作分四步，首先做一次高斯模糊，使图片变得平滑，得到一个降噪的效果。然后使用<code>cvtColor()</code>把图片转化成灰度，再对图片求一下x方向和y方向上的梯度。最后混合一下xy方向上的梯度就可以了。一般叫混合之后的图像为振幅图像。信号越强，振幅也就越大。</p>
<p><img src="https://s2.ax1x.com/2019/08/26/mfLqz9.png"></p>
<p>源代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	Mat src, dst, dst2, dst3;  </span><br><span class="line">	<span class="keyword">int</span> ksize = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">	src = imread(<span class="string">&quot;D:/pic2.png&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">char</span> input_WIN[] = <span class="string">&quot;input image&quot;</span>;  </span><br><span class="line">	<span class="keyword">char</span> outputx_WIN[] = <span class="string">&quot;output x image&quot;</span>;  </span><br><span class="line">	<span class="keyword">char</span> outputy_WIN[] = <span class="string">&quot;output y image&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">int</span> borderType = BORDER_DEFAULT;  </span><br><span class="line">	imshow(input_WIN, src);  </span><br><span class="line">	  </span><br><span class="line">	Mat gray_src;  </span><br><span class="line">	GaussianBlur(src, dst, Size(<span class="number">3</span>, <span class="number">3</span>), <span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">	cvtColor(dst, gray_src, CV_BGR2GRAY);  </span><br><span class="line">  </span><br><span class="line">	Mat xgrad, ygrad;  </span><br><span class="line">	Sobel(gray_src, xgrad, CV_16S, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>);  </span><br><span class="line">	Sobel(gray_src, ygrad, CV_16S, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>);  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// Performs a look-up table transform of an array.  </span></span><br><span class="line">	<span class="comment">// 没看懂函数原型解释讲的是什么玩意，不过它可以处理显示不正常。。  </span></span><br><span class="line">	<span class="comment">// 似乎是在灰度图像上进行一个彩色绘制达到显示图像的效果？  </span></span><br><span class="line">	convertScaleAbs(xgrad, xgrad);  </span><br><span class="line">	convertScaleAbs(ygrad, ygrad);  </span><br><span class="line">  </span><br><span class="line">	imshow(outputx_WIN, xgrad);  </span><br><span class="line">	imshow(outputy_WIN, ygrad);  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这样做出来的效果似乎和之前用的Sobel算子效果不太一样，问题出现在哪里呢？</p>
<p>是深度问题。我们把深度设为-1再试试。</p>
<p><img src="https://s2.ax1x.com/2019/08/26/mfjS8e.png"></p>
<p>可以看到似乎颜色的“力道”稍浅了一些。当“力道”较大时，图片处理后的细节就较为明显。</p>
<p>最后让我们用<code>addWeighted</code>把两个方向上的图片拼合到一起。</p>
<p><img src="https://s2.ax1x.com/2019/08/26/mfjOMj.png"></p>
<p>最终的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	Mat src, dst, dst2, dst3;  </span><br><span class="line">	<span class="keyword">int</span> ksize = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">	src = imread(<span class="string">&quot;D:/pic2.png&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">char</span> input_WIN[] = <span class="string">&quot;input image&quot;</span>;  </span><br><span class="line">	<span class="keyword">char</span> outputx_WIN[] = <span class="string">&quot;output x image&quot;</span>;  </span><br><span class="line">	<span class="keyword">char</span> outputy_WIN[] = <span class="string">&quot;output y image&quot;</span>;  </span><br><span class="line">	<span class="keyword">char</span> output_WIN[] = <span class="string">&quot;final image&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">int</span> borderType = BORDER_DEFAULT;  </span><br><span class="line">	imshow(input_WIN, src);  </span><br><span class="line">	  </span><br><span class="line">	Mat gray_src;  </span><br><span class="line">	GaussianBlur(src, dst, Size(<span class="number">3</span>, <span class="number">3</span>), <span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">	cvtColor(dst, gray_src, CV_BGR2GRAY);  </span><br><span class="line">  </span><br><span class="line">	Mat xgrad, ygrad, <span class="keyword">final</span>;  </span><br><span class="line">	Sobel(gray_src, xgrad, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>);  </span><br><span class="line">	Sobel(gray_src, ygrad, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>);  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// Performs a look-up table transform of an array.  </span></span><br><span class="line">	<span class="comment">// 没看懂函数原型解释讲的是什么玩意，不过它可以处理显示不正常。。  </span></span><br><span class="line">	<span class="comment">// 似乎是在灰度图像上进行一个彩色绘制达到显示图像的效果？  </span></span><br><span class="line">	convertScaleAbs(xgrad, xgrad);  </span><br><span class="line">	convertScaleAbs(ygrad, ygrad);  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">//imshow(outputx_WIN, xgrad);  </span></span><br><span class="line">	<span class="comment">//imshow(outputy_WIN, ygrad);  </span></span><br><span class="line">	addWeighted(xgrad, <span class="number">0.5</span>, ygrad, <span class="number">0.5</span>, <span class="number">0</span>, <span class="keyword">final</span>);  </span><br><span class="line">  </span><br><span class="line">	imshow(output_WIN, <span class="keyword">final</span>);  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="Laplace算子"><a href="#Laplace算子" class="headerlink" title="Laplace算子"></a>Laplace算子</h2><p>Laplace算子也是通过卷积求取图像的边缘。只不过它是用一种求二阶导数的方法。</p>
<p><img src="https://s2.ax1x.com/2019/08/31/mvBhYF.jpg"></p>
<p><img src="https://s2.ax1x.com/2019/08/31/mvBfFU.jpg"></p>
<p>在二阶导数的时候，最大变化处的值为零即边缘是零值。通过二阶导数计算，依据此理论我们可以计算图像二阶导数，提取边缘。这便是Laplance算子所依靠的数学依据。</p>
<p>这里给出公式。可以看到它是由在x和y方向上的二阶偏导数组成。</p>
<p><img src="https://s2.ax1x.com/2019/08/31/mvBLTK.png"></p>
<p>Opencv已经提供了相关API <code>cv::Laplancian</code></p>
<p>处理流程</p>
<ul>
<li><p>高斯模糊去噪声（使用<code>GaussianBlur()</code>）</p>
</li>
<li><p>转换为灰度图像（使用<code>cvtColor()</code>）</p>
</li>
<li><p>Laplance算子-二阶导数计算（使用<code>Laplancian</code>）</p>
</li>
<li><p>取绝对值（使用<code>convertScaleAbs()</code>）</p>
</li>
<li><p>显示结果</p>
</li>
</ul>
<p>可以看到与做Sobel操作时的有点类似。</p>
<h2 id="简单测试-1"><a href="#简单测试-1" class="headerlink" title="简单测试"></a>简单测试</h2><p><img src="https://s2.ax1x.com/2019/08/31/mvr9CF.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	Mat src, dst;  </span><br><span class="line">	src = imread(<span class="string">&quot;D:/pic3.png&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">char</span> input_WIN[] = <span class="string">&quot;input image&quot;</span>;  </span><br><span class="line">	<span class="keyword">char</span> output_WIN[] = <span class="string">&quot;output image&quot;</span>;  </span><br><span class="line">	  </span><br><span class="line">	namedWindow(input_WIN, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	imshow(input_WIN, src);  </span><br><span class="line">  </span><br><span class="line">	Mat gsrc, edgeimg;  </span><br><span class="line">	GaussianBlur(src, dst, Size(<span class="number">3</span>, <span class="number">3</span>), <span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">	cvtColor(dst, gsrc, CV_BGR2GRAY);  </span><br><span class="line">  </span><br><span class="line">	Laplacian(src, edgeimg, CV_16S, <span class="number">3</span>); <span class="comment">// 后注 参数1应是gsrc  </span></span><br><span class="line">	convertScaleAbs(edgeimg, edgeimg);  </span><br><span class="line">  </span><br><span class="line">	namedWindow(output_WIN, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	imshow(output_WIN, edgeimg);  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<p>嗯，当我写到这里时才发现，貌似有些不太对劲，因为我没有传入gsrc，而传入了彩色的src，所以导致效果图看起来怪怪的。</p>
<p>稍作修改。</p>
<p><img src="https://s2.ax1x.com/2019/08/31/mvrW24.png"></p>
<h2 id="算子优化"><a href="#算子优化" class="headerlink" title="算子优化"></a>算子优化</h2><p>可以看到，用Laplance算子得出的图片噪点较多，我们着手处理解决一下这个问题。</p>
<p>采用什么方法？即的阈值操作<code>threshold</code>。</p>
<p>在输出前增加一行代码即可：<code>threshold(edgeimg, edgeimg, 0, 255, THRESH_OTSU | THRESH_BINARY);</code></p>
<p><img src="https://s2.ax1x.com/2019/08/31/mv6YUx.png"></p>
<h2 id="Canny边缘检测算法理论知识"><a href="#Canny边缘检测算法理论知识" class="headerlink" title="Canny边缘检测算法理论知识"></a>Canny边缘检测算法理论知识</h2><p>Canny边缘检测算法最早在1986年提出，它是一种很好的边缘检测方法，也是很常用，很实用的边缘检测方法。目前现代的很多边缘检测应用中都采用了Canny算法。</p>
<p>它的使用方法也很简单。</p>
<ul>
<li>高斯模糊 作用是对图像进行降噪，将可能影响算法的点去掉</li>
<li>灰度转换</li>
<li>计算梯度（<code>Sobel</code>或<code>Scharr</code>）</li>
<li>非最大信号抑制 </li>
<li>高低阈值输出二值图像</li>
</ul>
<p>非最大信号抑制是一步新的操作，做这个操作的原因是边缘只能有一个，如果存在多个边缘则只能留下一个。为了清晰起见只留下信号最强的边缘，将其他边缘消除。做法很简单，判断像素点在切向和法向是否为最大，如果不是则消除。</p>
<p>高低阈值是什么？我们做完非最大信号抑制之后就已经能得到一个边缘分明的图像了，但即使这样仍然不能达到对结果图像的要求。我们设定一个高阈值和低阈值，大于高阈值的保留，小于低阈值的舍弃，在中间范围的部分要做一个阈值连接操作。靠近高阈值的按保留做，靠近低阈值的按舍弃做。</p>
<h3 id="浅谈非最大信号抑制"><a href="#浅谈非最大信号抑制" class="headerlink" title="浅谈非最大信号抑制"></a>浅谈非最大信号抑制</h3><p><img src="https://s2.ax1x.com/2019/08/31/mvTS54.png"></p>
<p>非最大值抑制能帮助保留局部最大梯度而抑制所有其他梯度值。这意味着只保留了梯度变化中最锐利的位置。通过前面的讨论我们可以知道，上图所示操作是一种体现在xy方向上的梯度差异。（这不就是Sobel算子吗）没有见过的是最下面的θ，它等于一个反三角函数。这个函数又由Gy和Gx的大小确定。它叫做梯度幅值，代表梯度的具体方向。取值范围看下图。</p>
<p><img src="https://s2.ax1x.com/2019/08/31/mvT9PJ.png"></p>
<p>梯度角度θ范围从弧度-<br>π到π，然后把它近似到四个方向，分别代表水平，垂直和两个对角线方向（0°,45°,90°,135°）。可以对它进行一下分割，落在每个区域的梯度角给一个特定值，代表四个方向之一。</p>
<p>它的算法如下：</p>
<pre><code>1. 比较当前点的梯度强度和正负梯度方向点的梯度强度。
2. 如果当前点的梯度强度和同方向的其他点的梯度强度相比较是最大，保留其值。否则抑制，即设为0。比如当前点的方向指向正上方90°方向，那它需要和垂直方向，它的正上方和正下方的像素比较。</code></pre>
<h3 id="高低阈值输出二值图像"><a href="#高低阈值输出二值图像" class="headerlink" title="高低阈值输出二值图像"></a>高低阈值输出二值图像</h3><p>T1， T2为阈值，凡是高于T2的都保留，凡是小于T1都丢弃，从高于T2的像素出发，凡是大T1而且相互连接的，都保留。最终得到一个输出二值图像。</p>
<p>推荐的高低阈值比值为 T2: T1 = 3:1/2:1其中T2为高阈值，T1为低阈值。</p>
<h2 id="简单实践"><a href="#简单实践" class="headerlink" title="简单实践"></a>简单实践</h2><p>相关API：<code>cv::Canny</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Canny（  </span><br><span class="line">	InputArray src, <span class="comment">// 8-bit的输入图像  </span></span><br><span class="line">	OutputArray edges,<span class="comment">// 输出边缘图像， 一般都是二值图像，背景是黑色  </span></span><br><span class="line">	<span class="keyword">double</span> threshold1,<span class="comment">// 低阈值，常取高阈值的1/2或者1/3  </span></span><br><span class="line">	<span class="keyword">double</span> threshold2,<span class="comment">// 高阈值  </span></span><br><span class="line">	<span class="keyword">int</span> aptertureSize,<span class="comment">// Soble算子的size，通常3x3，取值3  </span></span><br><span class="line">	<span class="keyword">bool</span> L2gradient <span class="comment">// 选择 true表示是L2来归一化，否则用L1归一化，一般用L1  </span></span><br><span class="line">）  </span><br></pre></td></tr></table></figure>

<p>对边缘的检测效果还是很不错的。虽然加了trackbar，但是发现调还不如不调效果好。。</p>
<p><img src="https://s2.ax1x.com/2019/08/31/mvqI9e.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line">Mat src, gray_src, dst;  </span><br><span class="line"><span class="keyword">int</span> t1_value = <span class="number">50</span>;  </span><br><span class="line"><span class="keyword">int</span> max_value = <span class="number">255</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* OUTPUT_TITLE = <span class="string">&quot;Canny Result&quot;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Canny_Demo</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span> </span>&#123;  </span><br><span class="line">	Mat edge_output;  </span><br><span class="line">	blur(gray_src, gray_src, Size(<span class="number">3</span>, <span class="number">3</span>), Point(<span class="number">-1</span>, <span class="number">-1</span>), BORDER_DEFAULT);  </span><br><span class="line">	Canny(gray_src, edge_output, t1_value, t1_value * <span class="number">2</span>, <span class="number">3</span>, <span class="literal">false</span>);  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">//dst.create(src.size(), src.type());  </span></span><br><span class="line">	<span class="comment">//src.copyTo(dst, edge_output);		  </span></span><br><span class="line">	imshow(OUTPUT_TITLE, ~edge_output);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	src = imread(<span class="string">&quot;D:/pic4.png&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	  </span><br><span class="line">	<span class="keyword">char</span> INPUT_TITLE[] = <span class="string">&quot;input image&quot;</span>;  </span><br><span class="line">	namedWindow(INPUT_TITLE, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	namedWindow(OUTPUT_TITLE, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	imshow(INPUT_TITLE, src);  </span><br><span class="line">  </span><br><span class="line">	cvtColor(src, gray_src, CV_BGR2GRAY);  </span><br><span class="line">	createTrackbar(<span class="string">&quot;Threshold Value:&quot;</span>, OUTPUT_TITLE, &amp;t1_value, max_value, Canny_Demo);  </span><br><span class="line">	Canny_Demo(<span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="基于Canny边缘检测算法的轮廓发现"><a href="#基于Canny边缘检测算法的轮廓发现" class="headerlink" title="基于Canny边缘检测算法的轮廓发现"></a>基于Canny边缘检测算法的轮廓发现</h2><p>轮廓发现是基于图像边缘提取的基础寻找对象轮廓的方法。所以边缘提取的阈值选定会影响最终轮廓发现结果。轮廓与边缘的概念是非常相似的，但是也不完全一致。</p>
<h2 id="简单测试-2"><a href="#简单测试-2" class="headerlink" title="简单测试"></a>简单测试</h2><p>可能会用到的API：</p>
<p><code>findContours</code>发现轮廓 在灰度图像上发现轮廓</p>
<p><code>drawContours</code>绘制轮廓 根据发现的轮廓把它绘制出来</p>
<p>在二值图像上发现轮廓使用API<code>cv::findContours</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">findContours(  </span><br><span class="line">	InputOutputArray  binImg,   </span><br><span class="line">    <span class="comment">// 输入图像，非0的像素被看成1,0的像素值保持不变，8-bit  </span></span><br><span class="line"> 	OutputArrayOfArrays  contours,  </span><br><span class="line">    <span class="comment">//  全部发现的轮廓对象  </span></span><br><span class="line">	OutputArray,  hierachy  </span><br><span class="line">	<span class="comment">// 图该的拓扑结构，可选，该轮廓发现算法正是基于图像拓扑结构实现。  </span></span><br><span class="line">	<span class="keyword">int</span> mode, <span class="comment">//  轮廓返回的模式  </span></span><br><span class="line">	<span class="keyword">int</span> method,<span class="comment">// 发现方法  </span></span><br><span class="line">	Point offset=Point()<span class="comment">//  轮廓像素的位移，默认（0, 0）没有位移  </span></span><br><span class="line">)  </span><br></pre></td></tr></table></figure>

<p>在二值图像上发现轮廓使用API <code>cv::findContours</code>之后对发现的轮廓数据进行绘制显示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">drawContours(  </span><br><span class="line">	InputOutputArray  binImg, <span class="comment">// 输出图像  </span></span><br><span class="line"> 	OutputArrayOfArrays  contours,<span class="comment">//  全部发现的轮廓对象  </span></span><br><span class="line">	Int contourIdx<span class="comment">// 轮廓索引号  </span></span><br><span class="line">	<span class="keyword">const</span> Scalar &amp; color,<span class="comment">// 绘制时候颜色  </span></span><br><span class="line">	<span class="keyword">int</span>  thickness,<span class="comment">// 绘制线宽  </span></span><br><span class="line">	<span class="keyword">int</span>  lineType ,<span class="comment">// 线的类型LINE_8  </span></span><br><span class="line">	InputArray hierarchy,<span class="comment">// 拓扑结构图  </span></span><br><span class="line">	<span class="keyword">int</span> maxlevel,<span class="comment">// 最大层数， 0只绘制当前的，1表示绘制绘制当前及其内嵌的轮廓  </span></span><br><span class="line">	Point offset=Point()<span class="comment">// 轮廓位移，可选  </span></span><br><span class="line">)  </span><br></pre></td></tr></table></figure>

<p>做法是这样的：</p>
<ul>
<li>输入图像转化为灰度图</li>
<li>使用Canny算法进行边缘检测，得到二值图像</li>
<li>使用findContours寻找轮廓</li>
<li>使用drawContours绘制轮廓</li>
</ul>
<p>感觉自己手里的图不是太适合拿来做检测，毕竟插画都太花里胡哨。这次我直接拿工业相机拍下的离心机内部照片做测试。尝试采用第二种方案，去掉二维码检测边缘（第一种方案为重新贴二维码，暂时不考虑）。</p>
<p><img src="https://s2.ax1x.com/2019/08/31/mxDurR.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug cout &lt;&lt; <span class="meta-string">&quot;ok&quot;</span> &lt;&lt; endl;  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">Mat src, gsrc, dst;  </span><br><span class="line"><span class="keyword">int</span> threshold_value = <span class="number">50</span>;  </span><br><span class="line"><span class="keyword">int</span> max_value = <span class="number">255</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* output_win = <span class="string">&quot;Final Result&quot;</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* input_win = <span class="string">&quot;src image&quot;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo_contours</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span> </span>&#123;  </span><br><span class="line">	Mat cannyOutPut;  </span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Point&gt;&gt; contours;  </span><br><span class="line">	<span class="built_in">vector</span>&lt;Vec4i&gt; hierachy;  </span><br><span class="line">	Canny(gsrc, cannyOutPut, threshold_value, threshold_value * <span class="number">2</span>, <span class="number">3</span>, <span class="literal">false</span>);  </span><br><span class="line">	findContours(cannyOutPut, contours, hierachy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(<span class="number">0</span>, <span class="number">0</span>));  </span><br><span class="line">  </span><br><span class="line">	dst = Mat::zeros(src.size(), CV_8UC3);  </span><br><span class="line">	<span class="function">RNG <span class="title">rng</span><span class="params">(<span class="number">12345</span>)</span></span>;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; contours.size(); i++) &#123;  </span><br><span class="line">		Scalar color = Scalar(rng.uniform(<span class="number">0</span>, <span class="number">255</span>), rng.uniform(<span class="number">0</span>, <span class="number">255</span>), rng.uniform(<span class="number">0</span>, <span class="number">255</span>));  </span><br><span class="line">		drawContours(dst, contours, i, color, <span class="number">2</span>, <span class="number">8</span>, hierachy, <span class="number">0</span>, Point(<span class="number">0</span>, <span class="number">0</span>));  </span><br><span class="line">	&#125;  </span><br><span class="line">	imshow(output_win, dst);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	src = imread(<span class="string">&quot;D:/pic6.png&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;could not load image...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	namedWindow(output_win, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	imshow(input_win, src);  </span><br><span class="line">	cvtColor(src, gsrc, CV_BGR2GRAY);  </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* trackBarTitle = <span class="string">&quot;Threshold Value&quot;</span>;  </span><br><span class="line">	createTrackbar(trackBarTitle, output_win, &amp;threshold_value, max_value, demo_contours);  </span><br><span class="line">	demo_contours(<span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>嗯，检测轮廓还是比较有效果的，只是它现在线条还比较乱。</p>
<p>也许学了后面的绘制矩形框和圆形框就可以定位出矩形了。</p>
<p>此后的操作便是求出矩形的中心坐标，传给机器，就完成目标了。</p>
<p>慢慢来，加油。</p>
<h2 id="绘制轮廓周围矩形框和圆形框"><a href="#绘制轮廓周围矩形框和圆形框" class="headerlink" title="绘制轮廓周围矩形框和圆形框"></a>绘制轮廓周围矩形框和圆形框</h2><p>之前说到各种关于图像的操作，到现在为止我们可以把图像的轮廓简单的显示出来，今天要解决的是如何根据轮廓绘制矩形框和圆形框。</p>
<p>首先需要一个预处理。对于此绘制算法来说，如果轮廓是一个多边形，那么多边形边数越多，画起来就越难。为了解决这个问题，需要引入一个新的API。OpenCV中使用RDP算法实现减小多边形边数且尽量令其大小不变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">approxPolyDP(  </span><br><span class="line">    InputArray  curve,   </span><br><span class="line">    OutputArray approxCurve,    </span><br><span class="line">    <span class="keyword">double</span>  epsilon,  <span class="comment">// 表示两点之间的最小距离，低于这个距离的两个点会被删除  </span></span><br><span class="line">    <span class="keyword">bool</span> closed <span class="comment">//  多边形要不要闭合  </span></span><br><span class="line">)  </span><br></pre></td></tr></table></figure>

<p>然后就是绘制各种形状 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cv::boundingRect(InputArray points)   </span><br><span class="line">    <span class="comment">// 得到轮廓周围最小矩形左上交点坐标和右下角点坐标，绘制一个矩形  </span></span><br><span class="line">cv::minAreaRect(InputArray  points)  </span><br><span class="line">    <span class="comment">// 得到一个旋转的矩形，返回旋转矩形  </span></span><br><span class="line">cv::minEnclosingCircle(  </span><br><span class="line">    InputArray points, <span class="comment">//得到最小区域圆形  </span></span><br><span class="line">	Point2f&amp; center, <span class="comment">// 圆心位置  </span></span><br><span class="line">	<span class="keyword">float</span>&amp; radius)<span class="comment">// 圆的半径  </span></span><br><span class="line">cv::fitEllipse(InputArray  points)   </span><br><span class="line">    <span class="comment">// 得到最小椭圆  </span></span><br></pre></td></tr></table></figure>

<p>做法是这样的</p>
<ul>
<li>首先将图像转换为二值图像</li>
<li>发现轮廓，找到图像轮廓</li>
<li>通过相关API在轮廓点上找到最小包含矩形和圆，旋转矩形和椭圆</li>
<li>绘制它们</li>
</ul>
<p>项目中只需要绘制矩形，我就只用绘制矩形部分的吧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line">  </span><br><span class="line">Mat src, gray_src, drawImg;  </span><br><span class="line"><span class="keyword">int</span> threshold_v = <span class="number">170</span>;  </span><br><span class="line"><span class="keyword">int</span> threshold_max = <span class="number">255</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* output_win = <span class="string">&quot;rectangle-demo&quot;</span>;  </span><br><span class="line"><span class="function">RNG <span class="title">rng</span><span class="params">(<span class="number">12345</span>)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Contours_Callback</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span> </span>&#123;  </span><br><span class="line">	Mat binary_output;  </span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Point&gt;&gt; contours;  </span><br><span class="line">	<span class="built_in">vector</span>&lt;Vec4i&gt; hierachy;  </span><br><span class="line">	<span class="comment">// 阈值操作与寻找轮廓，转化成一个比较轻恰当的二值图像  </span></span><br><span class="line">	threshold(gray_src, binary_output, threshold_v, threshold_max, THRESH_BINARY);  </span><br><span class="line">	findContours(binary_output, contours, hierachy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(<span class="number">-1</span>, <span class="number">-1</span>));  </span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Point&gt;&gt; <span class="title">contours_ploy</span><span class="params">(contours.size())</span></span>;  </span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;Rect&gt; <span class="title">ploy_rects</span><span class="params">(contours.size())</span></span>;  </span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;Point2f&gt; <span class="title">ccs</span><span class="params">(contours.size())</span></span>;  </span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; <span class="title">radius</span><span class="params">(contours.size())</span></span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;RotatedRect&gt; <span class="title">minRects</span><span class="params">(contours.size())</span></span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; contours.size(); i++) &#123;  </span><br><span class="line">		<span class="comment">// 调用ADP算法  </span></span><br><span class="line">		approxPolyDP(Mat(contours[i]), contours_ploy[i], <span class="number">3</span>, <span class="literal">true</span>);  </span><br><span class="line">		ploy_rects[i] = boundingRect(contours_ploy[i]);  </span><br><span class="line">		minEnclosingCircle(contours_ploy[i], ccs[i], radius[i]);  </span><br><span class="line">		<span class="keyword">if</span> (contours_ploy[i].size() &gt; <span class="number">5</span>) &#123;  </span><br><span class="line">			minRects[i] = minAreaRect(contours_ploy[i]);  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 绘制  </span></span><br><span class="line">	drawImg = Mat::zeros(src.size(), src.type());  </span><br><span class="line">	Point2f pts[<span class="number">4</span>];  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> t = <span class="number">0</span>; t &lt; contours.size(); t++) &#123;  </span><br><span class="line">		Scalar color = Scalar(rng.uniform(<span class="number">0</span>, <span class="number">255</span>), rng.uniform(<span class="number">0</span>, <span class="number">255</span>), rng.uniform(<span class="number">0</span>, <span class="number">255</span>));  </span><br><span class="line">		<span class="comment">//rectangle(drawImg, ploy_rects[t], color, 2, 8);  </span></span><br><span class="line">		<span class="comment">//circle(drawImg, ccs[t], radius[t], color, 2, 8);  </span></span><br><span class="line">		<span class="keyword">if</span> (contours_ploy[t].size() &gt; <span class="number">5</span>) &#123;  </span><br><span class="line">			<span class="comment">//ellipse(drawImg, myellipse[t], color, 1, 8);  </span></span><br><span class="line">			minRects[t].points(pts);  </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">4</span>; r++) &#123;  </span><br><span class="line">				line(drawImg, pts[r], pts[(r + <span class="number">1</span>) % <span class="number">4</span>], color, <span class="number">1</span>, <span class="number">8</span>);  </span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	imshow(output_win, drawImg);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	src = imread(<span class="string">&quot;D:/test.bmp&quot;</span>);  </span><br><span class="line">	<span class="keyword">if</span> (!src.data) &#123;  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;could not load image...\n&quot;</span>);  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	cvtColor(src, gray_src, CV_BGR2GRAY);  </span><br><span class="line">	blur(gray_src, gray_src, Size(<span class="number">3</span>, <span class="number">3</span>), Point(<span class="number">-1</span>, <span class="number">-1</span>));  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* source_win = <span class="string">&quot;input image&quot;</span>;  </span><br><span class="line">	namedWindow(source_win, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	namedWindow(output_win, CV_WINDOW_AUTOSIZE);  </span><br><span class="line">	imshow(source_win, src);  </span><br><span class="line">  </span><br><span class="line">	createTrackbar(<span class="string">&quot;Threshold Value:&quot;</span>, output_win, &amp;threshold_v, threshold_max, Contours_Callback);  </span><br><span class="line">	Contours_Callback(<span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">	waitKey(<span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OpenCV学习笔记</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法归档</title>
    <url>/2019/03/08/algorithm/</url>
    <content><![CDATA[<p>一些关于基础算法的归档整理放在了这里，包括贪心，排序，查找，图论相关等。该部分内容是曾在2018年和2019年发布的。</p>
<p>当前博客显示的发布时间非真实时间，而是这些内容在当时发布时的最后发布时间。</p>
<p><img src="https://s2.ax1x.com/2019/03/10/ApdsfO.jpg"></p>
<a id="more"></a>

<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法是指解题方案的准确而完整的描述。程序可以作为算法的一种描述。作为一个算法，它应该具有可行性，确定性，有穷性，同时应该拥有有用的情报。</p>
<p>可行性主要包括两个方面。第一，算法中的每一个步骤必须都是可实现的。比如不可除以0，实数集范围内不可求负数的平方根等。第二，算法执行后的结果要能够达到预期的目的。算法在执行过程中往往受到计算工具的能力限制，有可能会使结果产生一定的偏差（主要是指有效数字等）。同时需要注意，算法≠计算公式，它们之间是有区别的。</p>
<p>算法的确定性是指算法中的每一个步骤都应该有明确的定义，严禁模棱两可，也不能出现歧义。它也反映了算法与数学公式的差别。比如说，在解决某个现实中的问题时，数学公式是正确的，但按照这个数学公式设计的算法可能不会让计算机接受，这是因为数学公式没有考虑异常情况，当出现异常情况时，计算机就不知道该怎么办了。</p>
<p>算法的有穷性是指的是算法必须能够在有限的时间内完成，也就是它的步骤一定是有限的。同时算法的有穷性还意味着必须要在合理的时间内完成。比如未加任何优化的八皇后问题，它一共要执行648次运算，如果一台计算机每秒钟能执行循环100万次，那这个程序执行完毕也要9年时间。这显然没有实用价值。</p>
<p>一个算法是否有效，还取决于为算法提供的情报是否足够。一个算法的执行结果总是与其输入的数据有关，不同的输入可能会带来不同的输出。当输入不够或者格式错误时，算法将无法执行。一般来说，当算法拥有足够的情报时才是有效的，否则就是无效的。</p>
<h3 id="算法设计的基本方法"><a href="#算法设计的基本方法" class="headerlink" title="算法设计的基本方法"></a>算法设计的基本方法</h3><p>计算机的解题过程通常是在实行某种算法。这种算法我们称之为计算机算法。计算机算法不同于人工处理的方法。</p>
<p>1.列举法（穷举法）</p>
<p>它的基本思想很简单，根据提出的问题，找出所有可能出现的情况，并用问题所给出的条件去检索哪些是需要的，哪些是不需要的。因此，列举法常用来解决存在性或方案数问题。</p>
<p>列举法的实现通常都比较简单，暴力枚举，暴力搜索都算是列举法。但是它有一个致命的缺点，当列举的情况比较多时，该算法的执行速度会令人非常不满意。因此，在使用列举法时，可以稍加优化（剪枝）。在设计列举算法时，只要对实际问题做出详细的分析，将与问题有关的知识条理化，是可以大大减少枚举量的。有许多实际问题的规模很大，如果采用人工操作的话工作量通常难以想象，但借助计算机强大的计算能力，这会变得很简单。</p>
<p>2.归纳法</p>
<p>通过列举少量的特殊情况，经过（冷静）分析，找出一般的关系。它是一个由特殊到一般，由现象到本质的过程。它可以解决列举量为无限的问题。但是，从一个实际问题中归纳总结出一个一般的关系，通常来说并不是一件容易的事情。尤其是归纳为一个数学模型时更为困难。归纳是一种抽象，从特殊现象中找出一般关系。但由于在归纳过程中不可能对所有的情况进行列举，因此，由归纳法得到的结论本质上还是一种猜测，我们还需要对这种猜测加以论证才可以证明归纳正确。</p>
<p>3.递推法</p>
<p>所谓递推是指，从已知的初始条件出发，逐次推出所要求的各个中间结果和最后结果。其中初始条件一般是所给问题中指定，或是从初始条件经过推导得来。递推的本质也是归纳法，它是归纳法的一种。因此，递推的关系式通常是归纳的结果。递推法在数值计算中极为常见，但是，对于数值型的递推算法必须要注意数值计算的稳定性问题。</p>
<p>4.递归法</p>
<p>人们在解决一些特殊的复杂问题时，为了降低问题的复杂程度，一般会将问题逐层分解，最后归结为一些简单的问题。这种将问题逐层分解的过程，其实并没有降低问题的复杂程度，只是将原来规模大的问题划分成若干个规模小的问题，逐个解决后合并为整个大问题的答案。换句话说，是沿着原来分解的逆过程进行综合。这就是递归法的基本思想。其实不难看出，递归的本质也是归纳。在工程中，有很多问题是递归定义的，数学上的许多函数也是递归定义的。</p>
<p>其实就是</p>
<p><del>我 调 用 我 自 己</del></p>
<p>实际上，有一些问题既可以归纳为递推算法，也可以归纳为递归算法。但是递推和递归的实现方法是大不一样的。递推是从初始条件出发，逐次推出所需的结果，一环扣一环。但是递归是从算法本身直接到达递归边界，然后逐个处理子问题。通常的，递推算法要比递归算法清晰易读，递推算法的结构也相对于递归算法要简练一些。</p>
<p>5.分治法</p>
<p>在一些资料上也叫做减半递推技术。所谓减半，是指的将问题的规模减半，但是问题的性质不变，所谓递推，是指的重复减半的过程。</p>
<p>如果您听过一个术语叫“二分答案”，说的是一回事其实</p>
<p>6.回溯法</p>
<p>实际上，有些实际问题很难归纳出一组简单的递推公式或者是直观的求解步骤，并且也很难做到无限列举。对于这类问题，“试”是一种很好的方法。通过对问题的分析，找出一个解决问题的线索，然后沿着这个线索逐步试探，对于每一步试探，如果成功，就得到问题的一个“可行解”，如果试探失败，就返回上一步，再寻找下一个方案。这种方法称作回溯法。</p>
<h2 id="算法的复杂度"><a href="#算法的复杂度" class="headerlink" title="算法的复杂度"></a>算法的复杂度</h2><p>算法的复杂度主要包括时间复杂度和空间复杂度。</p>
<p>算法的时间复杂度是指执行算法所需要的计算量。</p>
<p>为了能够比较客观的反映出一个算法的效率，在度量一个算法的计算量时，应该要与计算机本身，编写算法的人员本身，编写算法的语言无关，而且还要与实现过程中的各种细节无关。唯一有关的是算法在执行过程中的计算量，即基本运算的执行次数。同时，算法所执行的次数还与问题的规模有关，在OI上，问题的规模通常用n来表示。</p>
<p>综上所述，算法的工作量用算法所执行的基本运算次数来度量，而算法所执行的基本运算次数是问题规模的一个函数。即 </p>
<p><em>算法的工作量 = f(n)</em></p>
<p>比如有一个二重循环，每一层都是从1到n，这个算法总共要执行n2次，也就是说时间复杂度是O(n2)</p>
<p>ps:刚才牵扯到一个记号，叫大O记号，有兴趣的读者可以自行查阅相关资料。</p>
<p>通常的，我们在分析算法的时间复杂度时，要以最坏情况为基础进行分析，它更具有说服力和实用价值。还有一种方法是用各种特定输入下的基本运算次数的加权平均值来度量算法的工作量，但是不常用。</p>
<p>一个算法的空间复杂度，一般是指执行这个算法所需要的内存空间。一般包括三部分，一是算法本身所占的空间，二是输入数据所占的空间，三是算法执行过程需要的额外空间。如果额外空间量相对于问题规模来说是一个常数，则我们说这个算法是在原地工作的。在许多实际问题中，为了减少算法所占用的存储空间，我们通常会采用一些压缩存储技术，以便尽量减少不必要的额外空间。</p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>它是一种求解最优化问题的常用算法。与其说它是一种算法，倒不如说它是一种思想更为合适。在众多的算法中，贪心算法可以算是最接近人们日常思维的一种算法。</p>
<p>比较抽象的来说，就是从问题的初始状态出发，通过若干次的贪心选择而得到最优值的一种策略。换句话说，贪心策略是一种在每次决策时采取当前意义下的最优策略的算法，它只能满足局部最优，但是是否能满足全局最优则并不一定。这主要取决于问题的最优解是否包含全部的局部最优解。</p>
<p>简单来讲，就是哪个最能满足当下的需求就选哪个。比如新生赛上alice和bob那个题。</p>
<blockquote>
<p>题目大意：有n堆糖果，数量可能不同，Alice和bob轮流拿糖果直到全部拿完。<br>保证总是Alice先拿糖果，而且这两个人绝顶聪明，最后谁的糖果多谁获胜。<br>Alice获胜输出A Bob获胜输出B 平局输出again</p>
</blockquote>
<p>在这个问题里面，alice和bob每次的选择一定是最对他们有利的。那么什么才是最有利的？显然，它们会照着最大的取，这样每次都选择当前最大的堆，最后能保证答案的最大化。可以想出，如果中间有任何一个环节取走的不是最大值，那么显然最后的结果一定不是所有可能里面最大的结果，那么也就不满足“绝顶聪明”这个设定了。</p>
<p>当时我是这样想的：（具体请见原文）</p>
<blockquote>
<p>思路：两个人拿糖果自然是哪一堆最多就拿哪个，这样是对自己最有利的。所以这题考场上我直接采用了贪心思想，所以先对所有的糖果堆从大到小排个序，然后Alice拿第一大，Bob拿第二大，Alice拿第三大……如此循环往复，可以看出Alice永远拿奇数堆，Bob永远拿偶数堆，然后统计一下这俩人最后能拿到的总糖数对比一下就是结果了。</p>
</blockquote>
<h3 id="贪心算法的特点"><a href="#贪心算法的特点" class="headerlink" title="贪心算法的特点"></a>贪心算法的特点</h3><p>贪心选择。所谓贪心选择是指应用同一规则，将原问题变为一个相似的但规模更小的子问题，而后的每一步都是当前看似最佳的选择，这种选择只依赖于已作出的选择，而不依赖于未作出的选择。</p>
<p>执行算法时，每一次得到的结果都是当前局部的最优解，但只有满足全局最优解包含局部最优解时，才能保证贪心算法正确。此规律常用来证明贪心算法的正确性。</p>
<p>（实际上，在考场上几乎不会给你证明贪心正确性的时间，所以如果想到贪心算法的话，可以尝试举几个反例，如果实在举不出来，就可以基本判定贪心正确）</p>
<h3 id="简单的贪心实例"><a href="#简单的贪心实例" class="headerlink" title="简单的贪心实例"></a>简单的贪心实例</h3><h4 id="最优装载问题"><a href="#最优装载问题" class="headerlink" title="最优装载问题"></a>最优装载问题</h4><p>给定n个物品，第i个物品重量为wi，选择尽量多的物体，使得总重量不超过C。</p>
<p>只需要考虑物体的重量，那么显然按着轻的装能够保证装的物体最多，也就是选择尽量多的物品。所以排个序，从轻到重挨个装就好，一直到全部装完（所有物品重量和加起来不够C或者直到装不下）。</p>
<h4 id="部分背包问题"><a href="#部分背包问题" class="headerlink" title="部分背包问题"></a>部分背包问题</h4><p>给定n个物品，第i个物品重量为wi，价值为vi。在重量不超过C的前提下让价值最大，价值与重量成比例。</p>
<p>这里就不能只简简单单考虑物品的重量或者价值了，我们应该考虑把性价比最大化，才能保证既装的又多，价值又高。所以先预处理一下所有物品，把所有物品的性价比列出来，对性价比进行排序，然后按照性价比从大到小依次装，直到装不下或者全装上都不到C。</p>
<p>值得注意的是，在这个问题里是不存在装不下下一个东西后背包有剩余空间的情况的。因为物品可以只选择一部分。所以一直到装不下那个物品之前，之前的物品必然是全部装上的，这也是贪心思想的一种体现。</p>
<h4 id="乘船问题"><a href="#乘船问题" class="headerlink" title="乘船问题"></a>乘船问题</h4><p>有n个人，第i个人的重量为wi，每艘船的载重量为C，且每艘船最多只能载两个人。求用最少的船装下所有人的方案。</p>
<p>最早mhr讲到这个问题的时候，我这个sb是这样想的：</p>
<blockquote>
<p>把所有人的人分成两部分，一部分是重量大于C/2的，另一部分是重量小于C/2的，然后这些重量大的自己乘一艘船，重量小的两人一艘船。</p>
</blockquote>
<p>但是很快，这个算法被我自己否决了。如果有两个或更多的人的体重极小，以至于船上站上一个体重大于C/2的人还能再让他们上那几条船，那么这个答案就不正确了。</p>
<p>这个正常的贪心算法比较巧妙。它试图让最轻的人和最重的人配对。</p>
<p>大意是这样，先考虑最重的人和最轻的人，如果这俩人加起来重量超过C，那么说明这个体重比较重的人是一定不可以和任何一个其他人同乘一条船的。所以他要自己一条船，此时继续向后找体重第二大，第三大……分别与最小体重的人放在一块看一下重量是不是大于C，一直找到第一个两人加起来不大于C的组合。此时之前找过的那些人一定是无法和其他任何人同乘一条船的。所以这些人的数量直接就计入答案的一部分。在剩下这些人里面，由于最重的和最轻的都可以同乘一条船，那显然剩余的组合（就是第二重与第二轻，第三重与第三轻……）都可以同乘一条船（想一想，为什么）。</p>
<p>最后答案的话，假设找出那些只能一人一条船的人后剩下的人数为k，那么最终答案就是：(n - k) + k / 2<br>（k是偶数），奇数的话再在这个结果下+1就好。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>排序也是数据处理中的一个重要的操作。排序的过程其实就是一个整理的过程。它将一个无序序列按照一定的原则整理为有序的序列。</p>
<p>可以对很多不同的数据结构进行排序，这里主要说对线性表的排序。</p>
<p>讲的可能会比较粗略，只介绍一下思路和复杂度。</p>
<h3 id="交换类排序"><a href="#交换类排序" class="headerlink" title="交换类排序"></a>交换类排序</h3><p>这是一类排序方法，它的原理是借助数据元素之间的互相交换。</p>
<p>1.冒泡排序</p>
<p>冒排是最简单的一种交换类排序。它通过相邻元素之间的交换逐步将无序变成有序。这里讲改进后的冒泡排序。</p>
<p>基本过程如下。假设我们要升序排序。</p>
<p>从表头开始往后扫描线性表，在扫描过程中逐次比较相邻两个元素的大小，如果在两个相邻的元素之间，前边的元素大于后边的元素，则将它们互换位置。显然，在扫描过程中，不断地将两个相邻元素中较小的向前移动，最后会得到一个升序序列。此时，在数组最右边的元素一定是最大的元素。因为通过之前的移动，最大的元素会被一直交换到最右边。然后我们从倒数第二位开始从后往前扫，扫到两者较小的数就往前移动，同理，这一趟排序下来最小的元素就会被放在第一位。然后再从正数第二位开始从前往后扫……这样一直扫到左界与右界重合，就完成了排序。</p>
<p>如果线性表的长度位n，那么在最坏情况下，冒泡排序需要n/2遍的从前往后的扫描与n/2遍的从后往前的扫描，需要的比较次数为n(n-1)/2，展开，得到时间复杂度为O（n2）。</p>
<p>2.快速排序</p>
<p>冒泡排序在扫描过程中只对相邻的两个元素进行比较，因此，每次互换相邻两个元素只能消除一个逆序。实际上，通过一些改进，我们可以通过一次交换消除多个逆序。快速排序就是这样的。</p>
<p>它的基本思路如下：</p>
<p>从线性表中取一个元素，让该线性表中所有比它小的元素移动到它前面，所有比它大的元素移动到它的后面。实际上是一个分割的过程，以我们所取的元素为分界点，最后使得该元素之前的元素都比它小，之后的元素都比它大。与此同时，我们需要再对分割后的两个线性表再次使用这个操作，一直到所有的元素都排列好。可以看出，这也是一个递归的过程。</p>
<p>实际上，在选取元素的过程中，我们常选取中间元素。我们设置两个指针i和j，分别指向线性表中的开始位置和结束位置，然后反复操作下面两个步骤：</p>
<p>1.j逐渐减小，并且逐次比较线性表第j项与选取的元素的大小，直到找到一个这个第j项小于我们选取的元素。然后把这个元素与第i个元素互换。</p>
<p>2.i逐渐增大，并且逐次比较线性表第i项与选取的元素的大小，直到找到一个这个第i项大于我们选取的元素。然后把这个元素与第j个元素互换。</p>
<p>上述两个操作交替进行，直到i=j为止。</p>
<p>在快速排序过程中，随着对各个子表不断地递归地进行分割，划分出的表会越来越多，由于是递归进行，所以系统会使用栈来进行存储所有的表。在对某个表进行分割后，可以将分割出的后一个子表的第一个元素与最后一个元素的位置入栈。当分割出的子表为空时，可以从栈中退出一个子表进行分割。直到栈空为止。</p>
<p>快速排序的平均时间复杂度是O(nlogn)，但是在最坏情况下会退化成O（n2）。</p>
<h3 id="插入类排序法"><a href="#插入类排序法" class="headerlink" title="插入类排序法"></a>插入类排序法</h3><p>1.插入排序</p>
<p>所谓插入排序，实际上是指将无序序列中的各个元素依次插入到已经有序的线性表中。类似于现实中的摸牌，在把牌摸到手里的同时会立即把它放在对应的位置那样。</p>
<p>不难得出，如果表中只有一个元素，那么它一定是有序的（这不是废话么）。假设目前有n-1个元素已经按顺序排好，我现在有第n个元素，我该怎么做？</p>
<p>想一下你摸牌后是怎么整理牌的。对线性表来说，要从第n-1个元素起，向左找，挨个比对，所有大于这第n个元素的元素都要后移一位。</p>
<p>在一次操作中，只能最多“消除一个逆序”。因此，它的时间复杂度与冒泡排序相同，是O（n2）。</p>
<p>2.希尔排序</p>
<p>希尔排序也属于插入类排序。但它相对普通的插入排序做了一些改进。</p>
<p>（NOIP2017考过希尔排序，但我用快排用习惯了，完全不知道这是什么鬼东西）</p>
<p>它的基本思想是将整个无序序列分割成若干的小子序列进行插入排序。既然用到了子序列，那么一定是要先分割出子序列。我们设一个改变量（增量）大小为h，那么每相隔h我们就划分一次，构成许多子序列。在各个子序列内直接进行插入排序。在排序过程中，要让这个h不断减小，最后当h减小到1时，进行一次插入排序，就可以了。</p>
<p>增量序列一般取h = n/2k(k = 1,2,……,[log2n])，其中n代表原无序序列长度。</p>
<p>一般的，初次取序列的一半为增量，以后每次减半，直到增量为1。在最坏情况下，它的比较次数为O(n3/2)。</p>
<h3 id="选择类排序法"><a href="#选择类排序法" class="headerlink" title="选择类排序法"></a>选择类排序法</h3><p>1.选择排序</p>
<p>扫描整个线性表，从中选出最小的元素，将它交换到表的最前面，然后再从线性表的第二个位置开始，从中选出最小的元素，将它交换到表的最前面……依此类推。直到剩下没排的表空为止。该排序算法并不难理解。它的时间复杂度也是O（n2）。</p>
<p>2.堆排序</p>
<p>先来说一下什么是堆。堆的基本定义是：一个具有n个元素的序列(n1,n2,……,nk)，当且仅当满足：{ni ≥ n2i,ni ≥ n2i+1} 或者{ni<br>≤ n2i,ni ≤ n2i+1}时，称之为堆。当满足前者的条件时称之为大根堆，满足后者的条件时称之为小根堆。</p>
<p>可能细心的读者能发现，这个数据结构其实就是一个完全二叉树……拿大根堆举例来说，所有的非叶节点值都不小于其左子树或右子树的根节点值。</p>
<p>所谓堆排序，其实就是调整结点的问题。我们可以把一个无序序列看成一棵完全二叉树，这棵完全二叉树是无序的，我们要通过变换结点把它调整为一个堆，就完成了排序。<br>在调整建堆的过程中，总是将根节点的值与左、右子树的根节点值进行比较，<br>如果不满足条件，则将左右子树的根节点的值中的较大的那个与根节点进行交换。一直做到所有的子树都变成了堆，排序就完成了。</p>
<p>堆排序对于规模较小的线性表并不适合，但是如果线性表规模较大，它的优势就会变得比较明显。即使是最坏情况，它的时间复杂度也是很优秀的O(nlogn)。</p>
<h3 id="快排模板"><a href="#快排模板" class="headerlink" title="快排模板"></a>快排模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 23333  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">int</span> a[maxn], n;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">int</span> i = l, j = r;  </span><br><span class="line">	<span class="keyword">int</span> mid = a[(l + r) &gt;&gt; <span class="number">1</span>];  </span><br><span class="line">	<span class="keyword">while</span> (i &lt;= j) &#123;  </span><br><span class="line">		<span class="keyword">while</span> (a[i] &lt; mid)  </span><br><span class="line">			i++;  </span><br><span class="line">		<span class="keyword">while</span> (a[j] &gt; mid)  </span><br><span class="line">			j--;  </span><br><span class="line">		<span class="keyword">if</span> (i &lt;= j) &#123;  </span><br><span class="line">			swap(a[i], a[j]);  </span><br><span class="line">			i++, j--;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">if</span> (l &lt; j)  </span><br><span class="line">		qsort(l, j);  </span><br><span class="line">	<span class="keyword">if</span> (i &lt; r)  </span><br><span class="line">		qsort(i, r);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  </span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];  </span><br><span class="line">	&#125;  </span><br><span class="line">	qsort(<span class="number">1</span>, n);  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">	  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二路归并模板"><a href="#二路归并模板" class="headerlink" title="二路归并模板"></a>二路归并模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 233333  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">int</span> a[maxn];  </span><br><span class="line"><span class="keyword">int</span> t[maxn];  </span><br><span class="line"><span class="keyword">int</span> n;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> *t)</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">if</span> (y - x &gt; <span class="number">1</span>) &#123;  </span><br><span class="line">		<span class="keyword">int</span> mid = (x + y) &gt;&gt; <span class="number">1</span>;  </span><br><span class="line">		<span class="keyword">int</span> p = x, q = mid, i = x;  </span><br><span class="line">		merge_sort(a, x, mid, t);  </span><br><span class="line">		merge_sort(a, mid, y, t);  </span><br><span class="line">		<span class="keyword">while</span> (p &lt; mid || q &lt; y) &#123;  </span><br><span class="line">			<span class="keyword">if</span> (q &gt;= y || p &lt; mid &amp;&amp; a[p] &lt;= a[q])  </span><br><span class="line">				t[i++] = a[p++];  </span><br><span class="line">			<span class="keyword">else</span> &#123;  </span><br><span class="line">				t[i++] = a[q++];  </span><br><span class="line">				ans += (mid - p); <span class="comment">// 用来求逆序对  </span></span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">for</span> (i = x; i &lt; y; i++)  </span><br><span class="line">			a[i] = t[i];  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  </span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];  </span><br><span class="line">	merge_sort(a, <span class="number">1</span>, n + <span class="number">1</span>, t);  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  </span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>先来说个我之前听到的笑话：</p>
<p><img src="https://i.loli.net/2018/08/13/5b717442d61e3.jpg"></p>
<p>这个笑话其实就是讲的顺序查找与二分查找。大妈以为这里面只有一本书没有过安检，所以采用了二分查找来提高效率，但实际上这些书都没有过安检233333</p>
<p>查找算法是一种非常重要的算法。查找的效率直接关系着数据处理的效率。顾名思义，查找算法就是在一个给定的数据结构中寻找指定的元素。通常的，根据数据结构的不同，所使用的查找算法也不同。这里重点讨论顺序查找与二分查找。</p>
<h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>顺序查找一般用于线性表。它的思路很简单，挨个比对。从线性表的第一个元素开始，依次比对需要查找的元素。如果发现线性表中的某个元素与需要查找的元素相符，则说明查找成功。如果查遍了整个线性表都没有找到那就是查找失败。</p>
<p>顺序查找所需要的时间取决于查找元素相对于第一个元素的距离。在最坏情况下，需要对整个线性表做比较才能找到。平均的，利用顺序查找法在线性表中查找一个元素，大约要与线性表中的一半的元素进行比较。</p>
<p>也就是说，在线性表比较大的情况下，使用顺序查找的效率是比较低的。但是有两种情况，这两种情况下只能使用顺序查找。</p>
<pre><code>1. 线性表无序。这种情况下只能使用顺序查找，因为下面要介绍的二分查找是需要元素有序的（笑话所提到的那种情况比较特殊，那个不能用顺序和无序来解释）。
2. 如果采用链式存储结构，则只能使用顺序查找。</code></pre>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找只适用于顺序存储的线性有序表。它要求元素必须要递增或者递减排列。</p>
<p>其实二分查找是一个递归的过程。对于整个元素区间，我们知道它是有序的，那么我们就取一下整个区间的中间元素，比对一下是不是要找的元素。如果不是，就要判断大小。这里我们以元素从左到右升序排列举例。</p>
<p>如果要查找的值比中值小，那说明中值是比较大的，那说明要查找的值是在区间的左半边的。然后我们以中值作为最大值，最小值还是原来那个，递归地查找这个元素。递归的边界是左右区间重合。如果最后查到区间长度就剩1，这个最后的元素也不是我们想要的，那只能说明线性表中没有我们要查找的元素。</p>
<p>虽然应用二分查找需要一定条件，但是二分查找的效率要比顺序查找高得多。这就正如笑话中提到的那两个时间复杂度。顺序查找的时间复杂度是O(n)，但是二分查找的时间复杂度就是O(log2n)。</p>
<h2 id="初等数论"><a href="#初等数论" class="headerlink" title="初等数论"></a>初等数论</h2><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>计算 a^x % p。</p>
<p>其实就是想办法把x拆开。考虑先把它表示成二进制形式，可以用不超过logx个f[i]拼出我们想要的答案。</p>
<p>在x的二进制表示中，1表示“取”。二进制中的每一个1都表示2的i次方。<br>比如说计算a^100，100的二进制是01100100，可以看出在2^2，2^5，2^6位置是1，而这些数分别对应4,32,64，那么只需要把a^100拆分成a^64×a^32×a^4即可。</p>
<p>实现很容易，每次提取处最低的二进制位再除以2即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">fast_pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> p)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum = a % p;  </span><br><span class="line">    <span class="keyword">for</span> (;x;x&gt;&gt;=<span class="number">1</span>,sum = sum*sum%p)  </span><br><span class="line">        <span class="keyword">if</span> (x&amp;<span class="number">1</span>)  </span><br><span class="line">            ans = ans*sum%p;  </span><br><span class="line">    <span class="keyword">return</span> ans;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<h3 id="欧几里得-扩展欧几里得"><a href="#欧几里得-扩展欧几里得" class="headerlink" title="欧几里得/扩展欧几里得"></a>欧几里得/扩展欧几里得</h3><p>gcd:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;  </span><br><span class="line">　　<span class="keyword">if</span> (!b)  </span><br><span class="line">　　　　<span class="keyword">return</span> a;  </span><br><span class="line">　　<span class="keyword">return</span> gcd(b, a % b);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<p>证明（摘自ljp学长的课件）：</p>
<blockquote>
<p> 证明欧几里得算法正确性的关键是证明 Gcd(a,b)=Gcd(b%a,a);  </p>
<p>令x=Gcd(a,b),y=Gcd(b%a,a);  </p>
<p>b%a可表示为a和b的线性组合：b%a=b-(b/a)×a;  </p>
<p>因为 a%x=0,b%x=0;  </p>
<p>所以 (b%a)%x=0;  </p>
<p>故y%x=0;<br>又(b%a)%y=[b-(b/a)×a]%y=0, a%y=0;<br>根据同余定理可得<br>b%y-(b/a)×a%y=0,所以b%y=(b/a)×a%y=0;<br>所以x%y=0;<br>所以Gcd(a,b)=Gcd(b%a,a);<br>证毕;</p>
</blockquote>
<p>exgcd:<br>给出不定方程 ax+by = Gcd(a,b) ，拓展欧几里得算法可以用于求解不等方程组的整数根（x,y）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;d, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;  </span><br><span class="line">　　<span class="keyword">if</span> (!b) &#123;  </span><br><span class="line">　　　　d = a;  </span><br><span class="line">　　　　x = <span class="number">1</span>;  </span><br><span class="line">　　　　y = <span class="number">0</span>;  </span><br><span class="line">　　&#125;  </span><br><span class="line">　　<span class="keyword">else</span> &#123;  </span><br><span class="line">　　　　exgcd(b, a % b, d, y, x);  </span><br><span class="line">　　　　y -= (a / b) * x;  </span><br><span class="line">　　&#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<p>用来求解形似ax+by = gcd(a,b)一类方程的解。  </p>
<p>这里的x和y不一定是正整数，有可能是负数或0.  比如说我举个例子，求一直线ax+by+c = 0上有多少个整数点(x,y)满足x∈[x1,x2]，y∈[y1,y2]</p>
<p>边界情况：  </p>
<p>当b=0时，</p>
<p>gcd(a,b)=a，x=1,y=0</p>
<p>假设 ax1 + by1= gcd(a,b)，bx2 + (a % b)y2= gcd(b,a % b)  </p>
<p>由gcd的意义，知gcd(a,b) = gcd(b,a % b)，那么有ax1 + by1 = bx2+ (a % b)y2;  </p>
<p>也就是说ax1 + by1 = bx2 + (a - [a / b] × b)y2 = ay2 + bx2 - [a / b] × by2;  </p>
<p>也就是说ax1 + by1 == ay2+ b(x2 - [a / b] × y2);  </p>
<p>那么，x1 = y2; y1 = x2 - [a / b] × y2;  </p>
<p>这样我们就得到了求解 x1,y1 的方法：x1，y1 的值基于 x2，y2。我们可以通过不断递归调用求解。</p>
<p>我们这样只能得出一组解，其他解呢？如果我们现在有解（x1,y1)，任取另外一组解(x2,y2)，则有ax1 + by1 = ax2 + by2 =<br>gcd(a, b)，变形可以得到a(x1 – x2) = b(y2 – y1)，两边同时除以gcd(a, b)，得到a’(x1 – x2) = b’(y2<br>– y1)，因为(a’,b’)=1，所以(x1-x2)一定是b’的倍数，取x1-x2=kb’,得y2-y1=ka’。</p>
<p>所以我们有以下结论：  </p>
<p><strong>对方程ax+by+c=0，一组整数解为(x0,y0)，则它的任意整数解可以写成(x0+kb’,y0-ka’),其中a’=a/gcd(a,</strong><br><strong>b)，b’=b/gcd(a, b)</strong></p>
<p>关于ax+by=c有没有解，我们有这么一个结论：  </p>
<p>对于方程ax+by=c（a,b,c均为整数），如果c为gcd(a,b)的倍数，则方程有整数解，反之无整数解。因为a和b都是gcd(a,b)的倍数，所以ax+by一定也是gcd(a,b)的倍数，如果c不是gcd(a,b)的倍数，一定无解。  </p>
<p>那刚才那道题怎么做呢？</p>
<p>方程变形为ax+by = -c，看一下-c是不是gcd(a,b)的倍数，然后用exgcd求一下ax+by = gcd(a,b)的解，记为(x0,y0)。  </p>
<p>等式两边同乘(-c)/gcd(a,b)，就有ax0’+by0’ = -c  </p>
<p>用刚才的结论，求出使x = x0 + kb’落在区间[x1,x2]内的k的范围和使y = y0-ka’落在区间[y1,y2]内的k的范围，取交集就是答案。</p>
<h3 id="欧拉筛法"><a href="#欧拉筛法" class="headerlink" title="欧拉筛法"></a>欧拉筛法</h3><p>核心思想是通过让每一个数只会被它最小的质因子筛到，从而每个数只会被筛一次，时间复杂度O(n)。</p>
<p>对于任意一个合数，我们可以拆成最小质因子×某数i的形式，我们枚举这个数i，然后再枚举出所有筛的质数。</p>
<p>当我们枚举的质数可以整除i时，如果再往大里枚举，枚举的质数就不可能是最小质数了。这时就可以终止循环，继续枚举下一个i。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt;  </span><br><span class="line"><span class="keyword">int</span> prime[maxn];  </span><br><span class="line"><span class="keyword">bool</span> vis[maxn];  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Eular</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;  </span><br><span class="line">        <span class="keyword">if</span> (!vis[i])      </span><br><span class="line">            prime[++cnt] = i;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt &amp;&amp; prime[j]*i&lt;=n;++j)&#123;  </span><br><span class="line">            vis[prime[j]*i] = <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="简单图论"><a href="#简单图论" class="headerlink" title="简单图论"></a>简单图论</h2><h3 id="多源最短路：Floyd算法"><a href="#多源最短路：Floyd算法" class="headerlink" title="多源最短路：Floyd算法"></a>多源最短路：Floyd算法</h3><p>多适用于邻接矩阵，时间复杂度O(n3)，适用负边权</p>
<p>令dis[u][v]表示从u到v的最短路径长度，w[u][v]表示连接u，v边的长度。</p>
<p>首先初始化所有的dis，如果对于任意u,v有边相连则dis[u][v] = w[u][v]，如果没有则dis[u][v] = INF。</p>
<p>算法过程：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123; <span class="comment">//这层循环必须放在最外面  </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;  </span><br><span class="line">			<span class="keyword">if</span> (dis[i][j] &gt; dis[i][k] + dis[k][j])  </span><br><span class="line">				dis[i][j] = dis[i][k] + dis[k][j];  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<h3 id="单源最短路：Dijkstra算法"><a href="#单源最短路：Dijkstra算法" class="headerlink" title="单源最短路：Dijkstra算法"></a>单源最短路：Dijkstra算法</h3><p>多适用于邻接表，时间复杂度O(n²)（未经优化），O((n+m)logm)（加入堆优化），不适用负边权</p>
<p>它是一种基于贪心思想的算法。开始时设定两个集合，一个是已经更新了最短路径的点的集合，另一个就是还没有更新的。然后通过不断更新连接点的最短距离，最后一步一步地求出到达目标点的路径。</p>
<p>通过dijkstra，每一个节点都会产生若干（候选）最小距离。这些（候选）最小距离里面最小的才是真正的最小距离。  </p>
<p>具体流程：  </p>
<p>开一个数组，记录每个点当前属于哪一个阵营。  </p>
<p>从堆中所有（候选）最小距离里面挑出一个最小的。如果node属于A阵营，说明之前已经遇到了一个node的（候选）最小距离，现在这个不是真的最小，跳过。 </p>
<p>反之，检查所有node这个点的出边。假设出边指向v。如果v属于B阵营，那么我们将{v, dis[node]+w}加入堆中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">int</span> n,m,s,head[<span class="number">50010</span>],cnt;  </span><br><span class="line">ll dis[<span class="number">10010</span>];   </span><br><span class="line"><span class="keyword">bool</span> used[<span class="number">10010</span>];  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> to,from,dis;  </span><br><span class="line">&#125;edge[<span class="number">500010</span>];  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> dis)</span></span>&#123;  </span><br><span class="line">    edge[cnt].to=v;  </span><br><span class="line">    edge[cnt].from=head[u];  </span><br><span class="line">    edge[cnt].dis=dis;  </span><br><span class="line">    head[u]=cnt++;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;  </span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt; q;  </span><br><span class="line">    fill(dis,dis+n+<span class="number">1</span>,INF);  </span><br><span class="line">    fill(used,used+n+<span class="number">1</span>,<span class="literal">false</span>);  </span><br><span class="line">    dis[s]=<span class="number">0</span>;  </span><br><span class="line">    q.push(P(<span class="number">0</span>,s));  </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;  </span><br><span class="line">        P p=q.top();q.pop();  </span><br><span class="line">        <span class="keyword">int</span> u=p.second;  </span><br><span class="line">        <span class="keyword">if</span>(used[u]) <span class="keyword">continue</span>;  </span><br><span class="line">        used[u]=<span class="literal">true</span>;  </span><br><span class="line">        <span class="keyword">int</span> pp=head[u];  </span><br><span class="line">        <span class="keyword">while</span>(pp!=<span class="number">-1</span>)&#123;  </span><br><span class="line">            <span class="keyword">int</span> v=edge[pp].to;  </span><br><span class="line">            <span class="keyword">if</span>(!used[v]&amp;&amp;dis[v]&gt;dis[u]+edge[pp].dis)&#123;  </span><br><span class="line">                dis[v]=dis[u]+edge[pp].dis;  </span><br><span class="line">                q.push(P(dis[v],v));  </span><br><span class="line">            &#125;  </span><br><span class="line">            pp=edge[pp].from;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));  </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;  </span><br><span class="line">        <span class="keyword">int</span> u,v,d;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;d);  </span><br><span class="line">        add_edge(u,v,d);  </span><br><span class="line">    &#125;  </span><br><span class="line">    dijkstra(s);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,dis[i]);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<h3 id="单源最短路：Bellman-Ford算法"><a href="#单源最短路：Bellman-Ford算法" class="headerlink" title="单源最短路：Bellman-Ford算法"></a>单源最短路：Bellman-Ford算法</h3><p>（经过队列优化后的中国叫法是SPFA）</p>
<p>多适用于邻接表，时间复杂度O(NE)（未经优化，N为点数，E为边数），O(kE)（k是常数，加入队列优化），适用负边权。</p>
<p>SPFA<br>在形式上和广度优先搜索非常类似，不同的是广度优先搜索中一个点出了队列就不可能重新进入队列，但是SPFA中一个点可能在出队列之后再次被放入队列，也就是说一个点修改过其它的点之后，过了一段时间可能会获得更短的路径，于是再次用来修改其它的点，这样反复进行下去。<br>算法时间复杂度：O(kE)，E是边数。K是常数，平均值为2。</p>
<p>SPFA代码模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 5000015  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(x) memset(x,0,sizeof(x));  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> from,to,dis;  </span><br><span class="line">&#125;;  </span><br><span class="line">Edge edge[maxn];  </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n,m,s,u,v,d;  </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> head[maxn];  </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> dis[maxn];  </span><br><span class="line"><span class="keyword">bool</span> inq[maxn];  </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> from,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> to,<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> dis)</span></span>&#123;  </span><br><span class="line">    edge[++cnt].from = head[from];  </span><br><span class="line">    edge[cnt].to = to;  </span><br><span class="line">    edge[cnt].dis = dis;  </span><br><span class="line">    head[from] = cnt;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;  </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt; q;  </span><br><span class="line">    q.push(s);  </span><br><span class="line">    ms(inq);  </span><br><span class="line">    inq[s] = <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)  </span><br><span class="line">        dis[i] = INF;  </span><br><span class="line">    dis[s] = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;  </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> u = q.front();  </span><br><span class="line">        q.pop();  </span><br><span class="line">        inq[s] = <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=head[u];i!=<span class="number">0</span>;i=edge[i].from)&#123;  </span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> v = edge[i].to;  </span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> w = edge[i].dis;  </span><br><span class="line">            <span class="keyword">if</span> (dis[u]+w &lt; dis[v])&#123;  </span><br><span class="line">                dis[v] = w+ dis[u];  </span><br><span class="line">                <span class="keyword">if</span> (!inq[v])&#123;  </span><br><span class="line">                    q.push(v);  </span><br><span class="line">                    inq[v] = <span class="literal">true</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;  </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; d;  </span><br><span class="line">        add_edge(u,v,d);  </span><br><span class="line">    &#125;  </span><br><span class="line">    spfa();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<p>该算法的速度非常之快，但当该算法运行在稠密图或者人为构造的网格图上，该算法的复杂度极有可能退化成O(NE)。</p>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>时间复杂度O(ElogE)（E为边数）</p>
<p>按照边权排序所有边，然后从低到高一条一条取，每次取一条边询问这条边的两个点在不在同一个集合里，如果不在同一集合说明可以进行合并（因为如果在同一集合里，再连就不是树了），然后并这两个点，这个操作一直做，做到生成树已经有n-1条边为止。    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 5005  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 200005  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> from,to,dis;  </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Edge &amp;rhs)<span class="keyword">const</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> dis &lt; rhs.dis;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">Edge edge[maxm];  </span><br><span class="line"><span class="keyword">int</span> father[maxm];  </span><br><span class="line"><span class="keyword">int</span> n,m;  </span><br><span class="line"><span class="keyword">int</span> totedge = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">char</span> c;  </span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;  </span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) == <span class="string">&#x27; &#x27;</span> || c == <span class="string">&#x27;\n&#x27;</span> || c == <span class="string">&#x27;\r&#x27;</span>);  </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)  </span><br><span class="line">        flag = <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        num = c - <span class="string">&#x27;0&#x27;</span>;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c = getchar()))  </span><br><span class="line">        num = num * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> (flag ? <span class="number">-1</span> : <span class="number">1</span>) * num;  </span><br><span class="line">&#125;      </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)  </span><br><span class="line">        father[i] = i;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (father[x] == x)  </span><br><span class="line">        <span class="keyword">return</span> father[x];  </span><br><span class="line">    father[x] = find(father[x]);  </span><br><span class="line">    <span class="keyword">return</span> father[x];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;  </span><br><span class="line">    father[find(x)]  = find(y);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    n = read();m = read();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;  </span><br><span class="line">        edge[i].from = read();  </span><br><span class="line">        edge[i].to = read();  </span><br><span class="line">        edge[i].dis = read();  </span><br><span class="line">    &#125;  </span><br><span class="line">    sort(edge+<span class="number">1</span>,edge+m+<span class="number">1</span>);  </span><br><span class="line">    init();  </span><br><span class="line">    <span class="keyword">while</span> (totedge &lt; n<span class="number">-1</span>)&#123;  </span><br><span class="line">        <span class="keyword">if</span> (find(edge[++k].from) != find(edge[k].to))&#123;  </span><br><span class="line">            ans += edge[k].dis;  </span><br><span class="line">            merge(edge[k].from,edge[k].to);  </span><br><span class="line">            totedge++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 23333  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span>  </span><br><span class="line">	<span class="keyword">int</span> from, to, dis;  </span><br><span class="line">&#125;;  </span><br><span class="line">Edge edge[maxn];  </span><br><span class="line"><span class="keyword">int</span> n, m, s, u, v, d;  </span><br><span class="line"><span class="keyword">int</span> inDegree[maxn];  </span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">int</span> head[maxn];  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dis)</span> </span>&#123;  </span><br><span class="line">	edge[++tot].from = head[from];  </span><br><span class="line">	edge[tot].to = to;  </span><br><span class="line">	edge[tot].dis = dis;  </span><br><span class="line">	head[from] = tot;  </span><br><span class="line">	inDegree[to]++;  <span class="comment">// update in-degree  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;  </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topoSort</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  </span><br><span class="line">		<span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>)  </span><br><span class="line">			q.push(i);  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;  </span><br><span class="line">		<span class="keyword">int</span> u = q.front();  </span><br><span class="line">		q.pop();  </span><br><span class="line">		output(u);  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = edge[i].from) &#123;  </span><br><span class="line">			<span class="keyword">int</span> v = edge[i].to;  </span><br><span class="line">			inDegree[v]--;  </span><br><span class="line">			<span class="keyword">if</span> (inDegree[v] == <span class="number">0</span>)  </span><br><span class="line">				q.push(v);  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;  </span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; d;  </span><br><span class="line">		addEdge(u, v, d);  </span><br><span class="line">	&#125;  </span><br><span class="line">	topoSort();  </span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
        <tag>排序</tag>
        <tag>查找</tag>
        <tag>数论</tag>
        <tag>最短路</tag>
        <tag>最小生成树</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>ikbc c87机械键盘拆解+清理过程全记录</title>
    <url>/2019/02/05/clear-keyboard/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/02/05/5c595d71e7ac6.jpg"></p>
<p>上图是外包装和配件。</p>
<p>正文多图预警。</p>
<a id="more"></a>

<p>首先看一下键盘正面吧，这是清理之前的样子。其实基本看不出来哪里脏，脏东西都在里面藏着呢。。A,C,V键被我抠掉了，换上了赠送的红色无刻键帽，寓意嘛，23333333，你猜~</p>
<p><img src="https://i.loli.net/2019/02/05/5c595d48e1cbd.jpg"></p>
<h2 id="拔键帽"><a href="#拔键帽" class="headerlink" title="拔键帽"></a>拔键帽</h2><p>第一步，使用拔键器把所有的键帽都拔下来。像下面这样，两个分叉挂在键帽上，然后向上稍微用一点力，就可以拔出来。</p>
<p><img src="https://i.loli.net/2019/02/05/5c595f6730c7b.jpg"></p>
<p><img src="https://i.loli.net/2019/02/05/5c595f6cbc63d.jpg"></p>
<p>可以看到键盘底部的钢板上有很多脏东西，其实也就是一些点心屑和头发。。。</p>
<p>这把键盘的大键采用卫星轴的设计，按键手感上要更加的“肉”一些，一些键盘采用的是平衡杆设计，这样的大键敲起来声音比较清脆。我个人比较偏向于卫星轴的手感。</p>
<p>拔大键的时候由于是三个轴一起固定，比较难拔，我的做法是用拔键器的分叉挂住大键的左右两边，然后边向上提边摇晃拔键器。一点一点的拔出来，需要用的力度确实要比拔小键大一些。</p>
<p><img src="https://i.loli.net/2019/02/05/5c5960e3e054b.jpg"></p>
<p><img src="https://i.loli.net/2019/02/05/5c5960f416d7e.jpg"></p>
<p>从上面这个拔下来的图可以看出，这个键的右边的小卫星轴被拔了起来，但是其他的键就没有这个问题。我不知道是我用劲太大还是出厂的时候它就不结实。不过不影响使用。真受不了的话我觉得用强力胶粘一下也行。。</p>
<p>这样一个一个的拔，拔完一整排的键。</p>
<p><img src="https://i.loli.net/2019/02/05/5c59621273571.jpg"></p>
<p>空格键比较难拔，因为太长了。。。。空格键也是卫星轴的设计，我的做法是先拔起一边，再拔起另一边。也是需要用点劲才行。</p>
<p><img src="https://i.loli.net/2019/02/05/5c59628d5e028.jpg"></p>
<p>这样空格键就可以拔下来了。</p>
<p><img src="https://i.loli.net/2019/02/05/5c5962c786f66.jpg"></p>
<p>拔完最后一排是这样的：</p>
<p><img src="https://i.loli.net/2019/02/05/5c5962f375755.jpg"></p>
<p>上面就基本没有很难拔的键了。还是大键拔的时候摇晃着拔出来。小键直接拔出来就可以。整个拔键过程用时二十多分钟，不过我是中途拔一点就拍张照，实际上拔键用不了这么长时间。但是如果你是第一次拔的话也许可能需要多花一点时间。我这是第二次清理键盘了，所以感觉起来要比第一次好拔一些。。</p>
<p>耐心点，把87颗键帽全部拔完，就是这样的：</p>
<p><img src="https://i.loli.net/2019/02/05/5c5963eb08143.jpg"></p>
<p>这是全部的键帽：</p>
<p><img src="https://i.loli.net/2019/02/05/5c5963f06e5f2.jpg"></p>
<h2 id="拆解键盘"><a href="#拆解键盘" class="headerlink" title="拆解键盘"></a>拆解键盘</h2><p>ikbc<br>c87没有螺丝钉，它使用的是卡扣设计，个别地方（比如拐角处）的卡扣卡的比较紧，不太好拆解，需要费点力气才能拆开。而且每次听到卡扣打开的“啪”一声总能给我一个塑料边断裂的错觉。。。。第一次拆键盘那会听到卡扣打开那“啪”一声吓我半天，下意识以为边框断了。。。</p>
<p>拆解需要找一张质地比较柔软的塑料卡片，废旧的饭卡，学生卡都可以。名片就算了，纸质的太软。。。不过不太建议用身份证或者银行卡去拆解这个键盘，万一断里头了可就有点糟糕了。</p>
<p><img src="https://i.loli.net/2019/02/05/5c59657f8163a.jpg"></p>
<p>我在家里找到了我初中用过的饭卡，里头好像还有几分钱的余额2333，就用它拆解了。</p>
<p><img src="https://i.loli.net/2019/02/05/5c59658a8055e.jpg"></p>
<p>把键盘反过来，将卡片强行塞入底盘和边框之间的夹缝里。放心，稍微一用力就可以塞进去，边框的塑料是有一点弹性的。然后在这个夹缝里面来回的划，把里面的卡扣都划出来，让它不要顶着里面的凹槽而是顶着内壁。</p>
<p>给一张卡扣的特写：</p>
<p><img src="https://i.loli.net/2019/02/05/5c59659a80423.jpg"></p>
<p>如果这一行的卡扣全都被弄了出来，这里的边框将会“弹出”，开始与键盘主体有分离的迹象。然后如法去弄另一边的卡扣。</p>
<p>边角不太好弄的卡扣长下面这样，它的顶部内嵌在边框下面的小凹槽里。需要用卡片把它别出来。</p>
<p><img src="https://i.loli.net/2019/02/05/5c5965b47c870.jpg"></p>
<p>这一个步骤有点费力，也比较难弄，要有耐心。</p>
<p>所有的卡扣都弄出来后，边框会自动全部弹出。</p>
<p><img src="https://i.loli.net/2019/02/05/5c59680f87808.jpg"></p>
<p>可以看到底部钢板的全貌，上面脏东西还是挺多的。</p>
<p>钢板和底层的PCB板是连在一起的，如果需要清理底座或者后续要焊接LED灯的话还需要再把底部的排线卸下来。</p>
<p>钢板层和塑料底座是分开的，中间没有固定。</p>
<p><img src="https://i.loli.net/2019/02/05/5c5968159052a.jpg"></p>
<p><img src="https://i.loli.net/2019/02/05/5c59682059945.jpg"></p>
<p>这就是排线，用手指捏住两头，小心地摇晃地把排线的头拔出来。注意千万不要把线弄断了，不然就要考虑考虑怎么修了。。</p>
<p><img src="https://i.loli.net/2019/02/05/5c596823a1320.jpg"></p>
<p>成功拆下排线，拆解过程就算完成。此时可以取走钢板去清理了。</p>
<h2 id="清理键盘"><a href="#清理键盘" class="headerlink" title="清理键盘"></a>清理键盘</h2><p>我的键盘上面都是散落的点心屑和我的头发（哭唧唧），但是有的头发是夹在键轴下面的，不太好弄。试了一下用吹风机吹，可能是因为家用吹风机功率不大，效果不是很好。</p>
<p>后来用了刷子。第一次清理时我是用的刚买的新鞋刷，不过那玩意在宿舍呢没拿回来。。。然后找到了家里的“chuo子”（山东方言，我不知道这玩意学名叫啥2333），这是个大刷子，是铺床时用到的一种工具，可以清理床单上的异物，也可以整平床单。我拿来对着键盘扫了几下，效果还挺明显，头发什么都可以扫下去。</p>
<p><img src="https://i.loli.net/2019/02/05/5c596c4c31703.jpg"></p>
<p>最后效果大概就是这样。</p>
<p>来一张轴体特写：</p>
<p><img src="https://i.loli.net/2019/02/05/5c596c697c588.jpg"></p>
<p>最后提一点，下图这里，PCB板背面画圈的这些地方是焊锡盘，可以从淘宝或市场上购买3mm的LED灯，用电烙铁稍微加热后将灯从正面插进去，用这里的焊锡固定上，灯就可以亮了。emmmm至于正负极我还真忘了哪个是哪个了233333，emmm反正二极管的话，你插反了不会亮，但也不会对二极管造成损坏就是了。。。</p>
<p><img src="https://i.loli.net/2019/02/05/5c596c6fe679c.jpg"></p>
<h2 id="重新安装"><a href="#重新安装" class="headerlink" title="重新安装"></a>重新安装</h2><p>安装顺序正好和拆解顺序倒过来。首先安装排线。注意下图中的这一面是朝外的，不要插反。慢慢的推进去，对好接口，一直插到底就可以了。</p>
<p>（woc，不放图了，就简单的一个插口照片竟然不给过审，NBNB）</p>
<p>然后将钢板和底座对好，两者可能会有点不相合，这个没关系。然后卡上外边框就好了。卡扣设计虽然拆挺费劲但是装还是挺好装的。需要注意的是键盘正面有几个圆柱形的卡孔，要对好才可以去卡边上的卡扣。拐角附近的那种卡扣有时候需要用塑料卡片拨进去。不过相对于拆解，安装这里真的是省事很多。</p>
<p>最后装上键帽，就可以啦。键帽直接对准了卡进去就可以。注意大键的刻标是分左右的，最好是对着上面拆解前的图安装。</p>
<p>大功告成，整个拆解、清理、安装过程大概一个小时左右。</p>
<p><img src="https://i.loli.net/2019/02/05/5c596c7952c24.jpg"></p>
]]></content>
      <categories>
        <category>各种瞎搞操作</category>
      </categories>
      <tags>
        <tag>机械键盘</tag>
      </tags>
  </entry>
  <entry>
    <title>制作RJ45-B类网线口的一般方法</title>
    <url>/2018/11/22/rj45b/</url>
    <content><![CDATA[<p>事出有因，舍友想从宿舍里拉一条网线用。正巧宿舍里有一条废弃的网线，但是有一头是裸露的没法直接用，正巧我两周之前学了如何制作网线，所以这正是一个实战的好机会啦2333333</p>
<p>结局很成功，宿舍里通有线网啦（高兴脸）</p>
<p><img src="https://s2.ax1x.com/2019/04/26/EnGbAs.jpg" alt="EnGbAs.jpg"></p>
<a id="more"></a>

<p><img src="https://i.loli.net/2018/11/22/5bf66a4eaf0e0.jpg"></p>
<h2 id="开工之前"><a href="#开工之前" class="headerlink" title="开工之前"></a>开工之前</h2><p>宿舍里有一条废弃的网线缠在墙附近，有一头是裸露的，另一头看起来好像是伸进了墙里面。之前由于都没有用校园网，也就没怎么关注它。后来有舍友想要用一下这根线，我们便开始讨论起来了这件事。</p>
<p>当时我们想，插个头还不就能用了。我便去橙果工作室问了一下学长，学长表示可以接并借给我了一些器材：一把用来压水晶头的钳子，一个剥线器，还有两个水晶头。</p>
<p><img src="https://i.loli.net/2018/11/22/5bf66c6520118.jpg"></p>
<p><img src="https://i.loli.net/2018/11/22/5bf66c65221a4.jpg"></p>
<p>回到宿舍，拿起这条网线，开工。</p>
<h2 id="开工中"><a href="#开工中" class="headerlink" title="开工中"></a>开工中</h2><p>（没有在开工时拍照，我就画一下简单的示意图吧23333）</p>
<p><img src="https://i.loli.net/2018/11/22/5bf66e1007afb.png" alt="线1.png"></p>
<p>一开始是这样的，由于我们需要整理线序，需要剥开一部分外皮，这里用工具把大约3cm左右的线外皮剥去，里面是四股两两缠绕的线。</p>
<p>简单来讲就是8根线，一开始是两两缠绕的，取开之后8根线的颜色互不相同，有4根纯色线和4根花线，四根纯色线是橙色，绿色，蓝色，棕色；花线其实就是纯色线的颜色与白色相间，即分别为橙白，绿白，蓝白<br><del>（喔！）</del> ，棕白。然后把它们全部捋直，像这样：</p>
<p><img src="https://i.loli.net/2018/11/22/5bf66f62799dc.png" alt="线2.png"></p>
<p>我们把线从左到右标一下顺序。</p>
<p><img src="https://i.loli.net/2018/11/22/5bf66fcfbab4b.png" alt="线3.png"></p>
<p>然后进行跳线操作。也就是四六跳线，把四号位和6号位的线换一下位置。</p>
<p><img src="https://i.loli.net/2018/11/22/5bf6702a8dcde.png" alt="线4.png"></p>
<p>这样会得到这样一个颜色序列：</p>
<p>​    </p>
<pre><code>橙白，橙，绿白，蓝，蓝白，绿，棕白，棕</code></pre>
<p>把线按照此顺序排列好后捋直，用剪刀等工具把线剪到1~2cm左右，取一水晶头，让它弹片朝下，按照从左到右顺序为橙白，橙，绿白，蓝，蓝白，绿，棕白，棕把线插入水晶头。要保证所有的线都尽量顶到头，长度基本一致，同时在进口处能塞进一些线皮，这样是为了保证后续压头的时候能更加牢固。</p>
<p>这里有两张图可以参考一下。</p>
<p><img src="https://i.loli.net/2018/11/24/5bf8c6e07ffd4.jpg"></p>
<p><img src="https://i.loli.net/2018/11/24/5bf8c6e1d5e9b.jpg"></p>
<p>图2正好和我刚才说的反过来，它这个弹片是向上的。。。</p>
<p>全部做好后，用下图这个工具把水晶头压结实。不压结实的话这个头就是没法用的。但是要注意，这个操作是不可逆的，如果压结实后发现这个头没法用，那这个头就算废了，修复的话只能换一个新的。</p>
<h2 id="测试、吐槽和感想"><a href="#测试、吐槽和感想" class="headerlink" title="测试、吐槽和感想"></a>测试、吐槽和感想</h2><p>接完水晶头之后，我插到电脑上试了一下，发现没反应，心里突然感觉很失望。但我反复检查了我的接口后实在是找不出什么问题，我便捋着线寻找一下另一头在哪，顺便看一下这条线是不是坏线。</p>
<p>结果。。。我特么找着找着，把另一个头给找出来了……</p>
<p>原来……它并不是插上就能直接联网的。。。正在我感到绝望之时，突然发现宿舍门上边有一个路由器状的东西23333</p>
<p>然后我和一个舍友一起把另外一个舍友抬了上去把网线插上（那个位置是真的高，踩凳子根本够不到），于是，宿舍就通网啦wwwwwww</p>
<p>感觉挺好呢www第一次实战成功</p>
]]></content>
      <categories>
        <category>各种瞎搞操作</category>
      </categories>
      <tags>
        <tag>网线制作</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言语法基础</title>
    <url>/2018/08/29/c-language/</url>
    <content><![CDATA[<p>关于C语言基础语法的一些整理。该部分内容是曾在2018年发布的。</p>
<p>当前博客显示的发布时间非真实时间，而是这些内容在当时发布时的最后发布时间。</p>
<p><img src="https://i.loli.net/2018/08/29/5b8664859b6c0.png"></p>
<a id="more"></a>

<h2 id="程序和程序设计"><a href="#程序和程序设计" class="headerlink" title="程序和程序设计"></a>程序和程序设计</h2><p>源程序指的是高级语言编写的程序，目标程序是由二进制代码表示的程序。机器并不能看得懂我们的代码，所以软件工作者们就写了一种叫做编译程序的东西，它可以把我们的源程序翻译成二进制的机器指令，这样机器就能听得懂。</p>
<p>C源程序经过C的编译程序编译后生成一个.obj的二进制文件，我们称为目标文件，然后由称为“连接程序”的软件，把.obj文件与C语言提供的各种库函数连接起来，生成一个.exe，这个是可执行文件。</p>
<p>#include并不是一个语句。</p>
<h2 id="标识符、常量、变量、整型数据、实型数据相关"><a href="#标识符、常量、变量、整型数据、实型数据相关" class="headerlink" title="标识符、常量、变量、整型数据、实型数据相关"></a>标识符、常量、变量、整型数据、实型数据相关</h2><p>C语言的标识符分为关键字、预定义标识符和用户标识符。关键字是C语言预先规定的，不可以另作他用。预定义标识符是C语言中预先定义好并表示一定含义的标识符。比如库函数和预编译处理命令。C语言允许把这类标识符重定义，但是这样做它将失去原来的含义。但是强烈不建议去尝试这么做。用户标识符允许用户自定义标识符，但是不能与关键字相同，如果与预定义标识符相同，系统不会报错，但是原来的预编译标识符会失去原来的含义。</p>
<p>整型常量和实型常量又称为数值型常量，有正负的区分。实型常量必须带小数点，整型常量不带。C编译程序根据字面形式确定常量类型。</p>
<p>使用#define命令行（这个也不是语句）定义某个符号常量。在程序中出现这个符号的时候，一律替换至所定义的值。</p>
<p>变量的名字由用户自定义，该名字必须符合规则。在定义变量时说明类型，系统在编译时就能根据它的类型分配相应的存储单元。</p>
<p>十六进制数可以是0X开头（平时用0x比较多），进制中的六个字母大小写均可。在C程序中，只有十进制可以是负数，八进制和十六进制只能是整数（没错，你没看错，不是正数，是整数）。</p>
<p>不同的编译系统int变量开辟内存单元大小不同。VC会为int变量开辟4个字节的内存单元，我们知道，一个字节是八位二进制数，那么int就是32位的二进制数。它的取值范围是-2147482648到2147483647。</p>
<p>无论是短整型数还是长整型数，都会被识别为有符号整数。无符号整数在数的末尾应该加上后缀u或者U，如果是长整型无符号常量，可以加lu或者LU。短整型无符号常量取值是0到65535，长整型无符号常量取值在0到4294967295。</p>
<p>bit与byte并不是一回事。bit是计算机中最小的存储单位，只能存放0或1，称为二进制位。大多数的计算机把八个二进制位组成一个字节，这个就是byte，每个字节都有自己的地址。若干的字节会组成一个“字”，这个“字”用来存放机器指令或者数据。机器不同。“字”的长度也就不同。我们常说32位的计算机（当然现在已经out了），它就是以32个二进制位作为一个“字”的计算机，这一个“字”就是4byte。</p>
<p>对于有符号整数，它的最高位是存放符号的。最高位是0位正，1为负。</p>
<p>负数以补码形式存放。补码=反码+1。</p>
<p>在内存中存放的补码，怎么显示出来？首先对除符号位的所有位按位取反，把所得二进制数转化为十进制数后-1。</p>
<p>C语言中以两种形式表示一个实型常量。第一种形式是小数形式，第二种是指数形式。和数学中的指数形式很像，在C语言中以一个字母e或者E后跟一个整数来表示以10位底的幂数。C语言规定，字母e或者E之前必须要有数字，后面的指数必须是整数，这三部分中间没有空格。</p>
<p>在一般的计算机系统中，为float类型的变量分配4个字节的存储单元，为double类型的存储变量分配8个字节的存储单元，但是它并不是按照实型数的存储方式存放数据。在VC中，所有的float类型数据运算都自动转换成double。实型数值的范围非常大，而且是存在一定误差的。</p>
<h2 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h2><p>双目运算符两边运算符类型一致，所得类型一致，如果类型不一致，系统会进行转换到一致后进行计算。转换规律如下：</p>
<p>短整型 运算 长整型 短整型会变成长整型</p>
<p>整型 运算 长整型 整型会变成长整型</p>
<p>字符型 运算 整型 字符型会变成整型</p>
<p>有符号整型 运算 无符号整型 有符号整形会变成无符号整型</p>
<p>整型 运算 浮点型 整型会变成浮点型</p>
<h2 id="赋值表达式"><a href="#赋值表达式" class="headerlink" title="赋值表达式"></a>赋值表达式</h2><p>赋值运算符的优先级别只比逗号运算符高，比其他的运算符都低。</p>
<p>复合赋值运算符的优先级和赋值运算符相同。</p>
<p>赋值时如果赋值号左右边类型相同，那么好，没事。如果不相同，分成下面几种情况：（以下情况把变量名和表达式的类型反过来同样适用）</p>
<p>短整型 = 长整型，短整型会变成长整型。</p>
<p>有符号整型 = 无符号整型，有符号整型会变成无符号整型。</p>
<p>同时应当注意：</p>
<p>当短整型 = 长整型的情况出现时，短整型变量只能接受长整型数位上两个字节里的数据，高位上的数据将舍弃（丢失）。</p>
<p>当无符号整型 = 有符号整型时，会发生什么？</p>
<p>哦抱歉，什么也不会发生。内存中的内容会全部被复制进去。你发现了什么问题吗？</p>
<p>没错，负数会变成一个巨大的正数（想一想，为什么）。</p>
<p>同理，如果是有符号整型 = 无符号整型，这个无符号整型在足够大时会变成一个负数。</p>
<p><del>（我发现luogu上有好多人吐槽我这个“想一想，为什么”[笑抽]，这话颇具刘汝佳大佬的写作风格23333其实真不是有意而为之，我就是想把这句加上，没别的意思[笑抽]）</del></p>
<h2 id="逗号表达式"><a href="#逗号表达式" class="headerlink" title="逗号表达式"></a>逗号表达式</h2><p>结合性从左到右，最后一个表达式的值就是此逗号表达式的值。逗号运算符优先级最低。</p>
<h2 id="格式字符"><a href="#格式字符" class="headerlink" title="格式字符"></a>格式字符</h2><p>%c 输出一个字符。</p>
<p>%d 输出带符号的十进制整数（最常用），还有%ld长整型，%hd短整型，%I64d(%lld)为64位长整数（long long类型）。</p>
<p>%o 八进制 %#o 加先导0的八进制</p>
<p>%x 十六进制 %#x 同上</p>
<p>%u 无符号十进制整数</p>
<p>%f 以带小数点的数学形式输出浮点数</p>
<p>%e 以指数形式输出浮点数</p>
<p>%g 由系统决定是采用%f还是%e，目标是输出宽度最小</p>
<p>%s 输出字符串，直到遇到\0。</p>
<p>%p 输出内存地址</p>
<p>% % 输出一个”%”</p>
<p>%* 跳过此处数据，输入但不处理。</p>
<h2 id="关系运算和逻辑运算"><a href="#关系运算和逻辑运算" class="headerlink" title="关系运算和逻辑运算"></a>关系运算和逻辑运算</h2><p>&lt;,&lt;=,&gt;,&gt;=的优先级别相同，=,!=优先级别相同，前四种运算符优先级高于后两种。</p>
<p>算术运算符的优先级别最高，关系运算符次之，赋值运算符最低。</p>
<p>若x和y都是浮点数，像x==y这样的关系表达式尽量要少用，因为浮点数存在误差，两者可能会因为误差而导致不相等。</p>
<p>逻辑非级别最高，逻辑与次之，逻辑或最低（指优先级）。</p>
<h2 id="条件表达式构成的选择结构"><a href="#条件表达式构成的选择结构" class="headerlink" title="条件表达式构成的选择结构"></a>条件表达式构成的选择结构</h2><p>条件运算符是C语言提供的唯一的三目运算符。它可以被当作一个简单的if使用。有三个表达式，先求出表达式1的真假，真则执行表达式2，假则执行表达式3。条件运算符优先于赋值运算符，但是低于关系运算符和算术运算符。</p>
<h2 id="字符型常量"><a href="#字符型常量" class="headerlink" title="字符型常量"></a>字符型常量</h2><p>字符常量在内存中仅占一个字节，它实际上存放的是ASCII的代码值。</p>
<p>‘A’ 65 ‘a’ 97 ‘0’ 48 ‘ ‘ 32</p>
<p>各种转义字符：</p>
<p>\n 换行，很常用（有的系统中写作\r，我的旧博客中讲快读的部分使用过\r）。</p>
<p>\t 敲一个“Tab”，我喜欢用Tab进行缩进。</p>
<p>\v 竖向跳格 （还有这种操作？）</p>
<p>\f 换页符 （没用过。。。）</p>
<p>\b 敲一个“Backspace”，退格。</p>
<p>\ 敲一个“\”。</p>
<p>‘ 敲一个’， （想一想，为什么把这个单独摘出来，连带着下边那个）</p>
<p>“ 敲一个”，双引号 （233333）</p>
<p>\0 就是一个空值。</p>
<p>\后面加一个 <strong>八进制</strong> 数字，代表的是ASCII码的符号，会显示对应符号。</p>
<p>\x后面加一个 <strong>十六进制</strong> 数字，也是一样的意思。</p>
<p>字符串常量要占用一个字节存放末尾的\0，它代表串的结束。</p>
<h2 id="指针变量相关"><a href="#指针变量相关" class="headerlink" title="指针变量相关"></a>指针变量相关</h2><p>指针移动的最小单位是一个存储单元而不是一个字节。因此，对于基类型不同的指针变量，地址值的增1减1跨越的字节数是不同的。基类型不同的指针变量不可以混合使用。</p>
<p>求地址运算符只能应用于变量和数据元素，不可以用于表达暗示、常量或者register变量。</p>
<p>可以通过调用库函数malloc和calloc在内存中开辟动态存储单元。</p>
<p><em>可以作为间接访问运算符，它通过指针引用某个地址的存储单元。这里和“</em>p”中的星号意思不同。</p>
<p>*p++和++<em>p的意思并不相同，间接访问运算符的优先级和++是一样的，计算时从左到右计算。</em>p++会先取p指向的地址的值，然后让值++，但是++*p会让p这个指针的地址+1，它里面所指向的值并没有改变，总之，应该先取再改才是满足我们的要求的。</p>
<h2 id="数组相关"><a href="#数组相关" class="headerlink" title="数组相关"></a>数组相关</h2><p>可以通过赋初值来确定数组的大小。可以认为数组名是一个地址常量。当调用函数时，数组元素可以作为一个实参传送给形参，但是这样做并不能改变原数组当中的值。数组名也可以作为一个实参传送，但是数组名本身是一个地址值，所以传入的实际上应该是一个指针变量。</p>
<p>二维数组名也是一个地址常量，二维数组名应该理解为一个行指针，对于二维数组名，并不支持a++，a+=i这样的运算。</p>
<p>[]的优先级高于*，所以可以建立指针数组来用做各种用途。</p>
<p>要注意，(*p)[2]并不表示指针数组。它是 <strong>一个</strong> 指针，它的基类型是一个包含两个int元素的数组。</p>
<p>当二维数组名作为实参时，对应的形参必须是一个行指针变量。当指针数组名作为实参时，对应的形参应该是一个指向指针的指针（对就是有这种操作）。像int<br>**p,它就是让p指向一个指针，基类型是指针型，所以它是指针的指针。</p>
<h2 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h2><p>\0标志作为字符串的结束标志，它实际上要占用物理存储空间，但是在计算串长度时不计入。定义字符串时并不需要手动添加\0，系统会帮助你完成。每一个字符串常量分别占用内存中一连串的存储空间，可以理解为字符型的一维数组。这些数组没有名字，但是地址是存在的。</p>
<p>但是，以下代码是不合法的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">s = <span class="string">&quot;Hello!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这是为什么呢？字符串常量在赋值过程中给出的是这个字符串在内存中所占的一串连续存储单元的首地址，而s是一个不可以重新赋值的数组名，这样的赋值就是不合法的。</p>
<p>不过稍加修改就没有问题了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *s;</span><br><span class="line">s = <span class="string">&quot;Hello!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这个赋值语句使用了指针，它并不是把串的内容放到*s中，而是把s这个指向字符的指针指到了字符串在内存中所占的首地址，我们说，该指针指向该字符串。</p>
<p>字符数组的每个元素中课存放一个字符，但它并不限定最后一个字符必须是什么。因为有关字符串的大量操作都与串结束标志\0有关，因此，在字符数组中的有效字符后面加上\0这一特定情况下，可以把这种一维字符数组看作字符串变量，但是又不同于一般的字符串变量。可以说，字符串是字符数组的一种具体应用。</p>
<p>所以，在使用字符数组存放字符串时，不要把数组大小开到正好存下整个串，至少要多一个位置来存放\0。虽然计算机在刚才的操作中会自动在末尾添加\0，但是若用下面的操作初始化则不会：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = &#123; &amp;aposh&amp;apos,&amp;apose&amp;apos,&amp;aposl&amp;apos,&amp;aposl&amp;apos,&amp;aposo&amp;apos &#125;;</span><br></pre></td></tr></table></figure>

<p>它就是一个字符数组，因为它没有\0，系统并不会认为它是字符串。如果此时你把它误用作字符串，系统就会在内存池中上翻下找，直到找到一个\0，乱套了那就。这个时候，要把它当作字符串使用，必须在末尾手动的加上一个\0。</p>
<p>不过实际上没多少人会用这种方式初始化字符串的……</p>
<p>真要是想用，可以这么写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>] = &#123; <span class="string">&quot;hello&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>花括号可以去掉。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>但是这样写就是不太合理的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">5</span>] = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>为啥呢？\0没有地方放了。但是这样做有可能会正常运行，但是实质上是不正确的，这个添加的\0有可能会破坏掉其他数据。</p>
<p>如果对字符串开辟的内存长度没有明确要求，数组大小其实是可以不写的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>它的长度系统会算出来。</p>
<p>对于字符串的复制，我们知道直接使用赋值语句是不可以的。有两种方法可以实现这个操作。一是用for循环按位复制再手动加\0，还有一种方式是用strcpy()。</p>
<p>字符串的格式说明是%s。用%s格式输入字符串时，空格和回车符都被作为输入数据的分隔符而不能读入。但这并不是说我把一个字符串用空格分割为两部分用scanf也能输入到一个串中，实际上，它只能输入空格前的部分。当字符串长度越界时，系统并不报错，这可能会导致一些隐性错误。</p>
<p>实际上在使用时，数组的长度大多数时候都是开的比较大的。</p>
<h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><p>正常情况下，在写main函数时，里面的参数是空的。其实，main函数是可以有参数的。这样写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中argc和argv可以由用户自己修改名称，但是类型是固定的。</p>
<p>这样写出来有什么用呢？我们可以通过命令行中执行程序。假如这个程序叫test，这时候argc的值为1，argv[0]中讲存放字符串“test”的首地址。</p>
<p>argc存的是命令行中字符串的个数。为了执行程序，argv[0]必不可少，argc的值至少为1。另外，按照标准规定，argv[argc]由系统置为\0。</p>
<p>在C语言中函数名代表函数的入口地址，因此可以定义一种指向函数的指针来存放这种地址。</p>
<p>函数名或指向函数的指针变量可以作为实参传送给函数。</p>
<h2 id="用户标识符的作用域和存储类"><a href="#用户标识符的作用域和存储类" class="headerlink" title="用户标识符的作用域和存储类"></a>用户标识符的作用域和存储类</h2><p>C语言中有两种存储类别，一种是自动类，一种是静态类。局部变量既可以说明成自动类，也可以说明成静态类。但是全局变量只能是静态类。</p>
<p>当在函数内部或复合语句内定义变量时，如果没有指定存储类，或使用了auto说明符，系统就认为该变量具有自动类别。自动变量被分配在动态存储区，每当进入函数体时，系统自动为auto变量分配内存单元，退出时自动释放。使用这类局部变量的优点是可造成信息隔离，不同函数中使用了同名变量也不会造成影响。</p>
<p>用register声明的变量叫做寄存器变量。它并不占用内存单元，而是“建议”程序把它放在CPU的寄存器里。对寄存器的访问要比内存快得多，当程序在该部分对性能有较高要求时，可以使用它。</p>
<p>那我们为什么不在所有地方都是用寄存器变量呢？</p>
<p>刚才有个细节可能有读者忽略了，那就是“建议”这个词。实际上，使用register声明的变量 <strong>不一定</strong><br>会被分配到寄存器里。CPU中寄存器的数量是有限的，我们只能同时使用很少的寄存器变量。如果寄存器满了，它就会变成auto类型放在内存里。寄存器变量的数目与运行程序的CPU有关，也与所使用的编译程序有关。所以说，register只是一个“建议”，而不是强制。</p>
<p>此外，register变量如果被放在了寄存器里的话，它就是没有地址的（想一想，为什么），所以这时候不能对它进行取地址运算，与地址相关的操作均不适用。register变量在使用时要注意尽量靠近它使用的地方，做到开辟完马上使用，避免浪费。</p>
<p>静态局部变量使用static来说明。静态局部变量的作用域与auto和regster一样，但是static与它们有一些本质性的区别。在整个程序运行期间，静态局部变量仍然是在使用原来的存储单元，也就是说它并不会被释放。静态局部变量的生存期将一直延长到程序运行时结束。</p>
<p><del>（emmmmm，长寿变量，苟……）（打住</del></p>
<p>此外，静态局部变量的初值是在编译时已经赋好的，并不是执行到复制语句时才会赋值。对于未赋初值的静态变量，系统会自动赋予初值0。静态变量的上述特点对于编写那些在函数调用之间必须保留局部变量值的独立函数是很有用的。</p>
<p>若全局变量和某个函数的局部变量重名，则在该函数中全局变量会被屏蔽。其实，除十分必要外，一般不提倡使用全局变量（我在这方面做的不够好）。第一，不论是否需要，全局变量在整个程序运行期间都占用内存空间。第二，全局变量在函数以外定义，它会降低函数的通用性，影响函数的独立性。第三，使用全局变量容易因疏忽或使用不当导致全局变量中的值意外改变，引起副作用。</p>
<p>那还有一个extern是干啥的呢？</p>
<p>想一下下面的一个情况。在程序的前半部分有一个函数，使用了一个全局变量，但是这个全局变量是在函数之后定义的，系统会报错。但是从语法上讲这样做并没有什么问题，<br>这是为啥？</p>
<p>系统是个250，它不知道你定义了这个全局变量……</p>
<p>如果出现这种情况，我们需要在函数引用全局变量时加入extern进行说明（但是要注意，定义的时候不能使用）。这个玩意就是用来告诉那个函数：这个变量已经被定义了，你直接用就行，出了事我担着。</p>
<p>extern还有一个用途，是在多文件连接编译时出现的问题。我们把每一个可以单独编译的源文件叫“编译单位”，一个程序实际上是可以由许多编译单位组成的（本博客中目前展示的代码编译时都是由一个文件进行编译的）。当一个程序由多个编译单位组成，但是这些编译单位中都出现一个同名的全局变量，在连接时就会有“重复定义”的错误。一般解决这个问题的办法就是在其中一个文件中定义所有全局变量，在其它用到这些全局变量的文件中用extern进行说明，说明这些变量已经被定义，我不再去定义它。</p>
<p>比如有一个程序前面是这么写的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="keyword">int</span> x;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="comment">//...  c</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>然后还有一个程序这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="comment">//...  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>它俩连接起来编译就可以通过。</p>
<p>对于第二个程序，extern int x;并不是定义语句，而是说明语句，去说明我要用这个变量，这个变量在另一个程序里已经定义好了。</p>
<p>当使用说明符static说明全局变量时，它就是静态全局变量，它仅限于本编译单位使用，其他的编译单位是不可以用的。它能够起到一个很好的信息隐蔽作用。</p>
<p>当定义函数时用extern说明时，这个函数就被称为外部函数。一般的函数都隐含说明为extern，这个说明其实是可以省略的。外部函数可以被其他编译单位中的函数调用。通常，当函数调用语句与被调用函数不在同一编译单位，且函数的返回值为非整型时，extern不能省略。</p>
<p>同样的，加上static就是静态函数了。它可以理解为是一个内部函数，其他编译单位不能对他进行调用。使用静态函数可以避免不同编译单位因函数同名而引起混乱。</p>
<h2 id="编译预处理和动态存储分配"><a href="#编译预处理和动态存储分配" class="headerlink" title="编译预处理和动态存储分配"></a>编译预处理和动态存储分配</h2><p>在C语言中，凡是以#开头的行，都称为编译预处理命令行。在C编译程序对C源程序进行编译之前，由编译预处理程序对这些编译预处理命令行进行处理。目前常用的有这些：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">line</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span>  </span></span><br></pre></td></tr></table></figure>

<p>#define可以用作不带参数的宏定义。它可以用来替换文本，也可以用来仅定义一个符号。如果在一行中写不下，要在下一行继续时，只需要在最后一个字符后紧接着加一个\就可以。替换文本不能替换字符串中与宏名相同的字符串。替换文本不替换用户标识符中与宏名相同的部分，用作宏名的标识符一般用全大写表示，这不是规定，只是一种通用的习惯。</p>
<p>带参数的宏定义中，形参表必须和宏名挨着。它和函数调用很像，但是在宏替换中，对参数没有类型要求。宏替换在编译时完成，并不占用运行时间。</p>
<p>#undef提前解除宏定义的作用域。</p>
<p>在使用C语言开发程序时，我们可以把一些宏定义按照功能分别存入不同的文件中。当我们需要使用某个宏定义时，只需要#include<br>一下它所在的文件就可以。这里可以使用#include “文件名”而不是#include<br>&lt;文件名&gt;，用前者的写法会让程序先在源程序所在目录下寻找包含文件。头文件名可以由用户指定，后缀不一定是.h。</p>
<p>关于动态存储分配。malloc函数分配size个字节的存储区，返回一个指向存储区首地址的基类型为void的地址，如果没有足够的内存单元，返回NULL。在ANSI<br>C中malloc函数返回的指针为void *（不是返回void啊，那样就算没有返回值了），在调用函数时，必须利用强制类型转换转成我们需要的类型。</p>
<p>可是我如果突然忘了某个类型占多少字节怎么办？不慌，用sizeof()就好。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pi = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>

<p>像这样写就好啦。这样写还有一个好，由系统计算字节数，这样是有利于程序的移植的。（因为跨系统时不同类型所占的字节数可能是不一样的）。</p>
<p>使用malloc申请的内存 <strong>必须</strong><br>进行释放。free函数将指针所指向的存储空间进行释放，它只能释放由malloc或者calloc分配的地址。free函数没有返回值。</p>
<p>ANSI C规定calloc函数返回值类型为void *，和malloc一样。它可以这样调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">calloc</span>(n, size);</span><br></pre></td></tr></table></figure>

<p>要求n和size的类型都是unsigned<br>int。它用来给n个同一类型的数据项分配连续的存储空间，每个数据项的长度是size字节。分配成功时返回存储空间的首地址，否则返回NULL。通过calloc函数分配的存储单元，系统自动把初值设为0。</p>
<p>显然，使用calloc开辟的存储单元相当于开辟了一个一维数组。它也可以用free函数释放，释放指向首地址的指针就好。</p>
<h2 id="结构体、共用体、用户自定义类型"><a href="#结构体、共用体、用户自定义类型" class="headerlink" title="结构体、共用体、用户自定义类型"></a>结构体、共用体、用户自定义类型</h2><p>ANSI<br>C标准规定结构体至少允许嵌套15层。并且允许内嵌结构体成员的名字与外层成员的名字相同。结构体变量中的各个成员在内存中按说明的顺序依次排列。对于多层嵌套的结构体，引用方式是按照从外层到最内层的顺序逐层引用，每一层之间用点号隔开。</p>
<p>在调用函数时，可以将结构体变量中的成员作为实参单独传递，也可以将结构体变量作为实参进行整体传送。向函数传递结构体变量时，传递的是实参结构体变量中各成员的值，函数中形参结构体变量的改变不会影响到实参结构体变量，利用这一指针变量对数组进行任何的操作都将直接影响到实参结构体数组。</p>
<p>利用结构体可以实现链表。其中的一个成员指向本结构体类型，这种结构体也叫引用自身的结构体。每一个结构体变量作为一个结点。</p>
<p><del>我 引 用 我 自 己</del></p>
<p>共用体的类型说明和变量的定义方式与结构体的类型说明和变量定义的方式完全相同，不同的是，结构体变量中的成员各自占有自己的存储空间，而共用体变量中的所有成员占有同一个存储空间。关键字是union。</p>
<p>共用体变量在定义的同时只能用第一个成员的类型的值进行初始化。结构体变量中的每个成员分别占有独立的存储空间，因此结构体变量所占内存字节数是其成员所占字节数的总和。但是共用体变量中的所有成员共享一段公共存储区，所以共用体变量所占内存字节数与其成员中所占字节数最多的那个成员相等。</p>
<p>ANSI C允许在两个类型相同的共用体变量之间进行赋值操作。同结构体变量一样，共用体类型的变量可以作为实参进行传递，也可以传送共用体变量的地址。</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>C语言中，位运算的对象只能是整型或字符型数据，不能是其它类型数据。C语言提供了六种位运算符，我在以前的文章中也有使用。现在列出。</p>
<p>运算符~。按位求反，优先级最高。</p>
<p>运算符&lt;&lt;，左移，二进制数整体左移一位，也就是乘2，左移两位就是乘4……优先级次于~。</p>
<p>运算符&gt;&gt;是右移，相当于除以2，优先级和&lt;&lt;相同。</p>
<p>运算符&amp;,按位与。按照1&amp;1 = 1，其他的情况都是0的规则处理，它比左移和右移的优先级低。</p>
<p>运算符^，按位异或。两个值不相同时为1，相同时为0。它比按位与的优先级低。</p>
<p>运算符|，按位或，只有在0|0时才会是0，其余情况都是1。它的优先级最低。</p>
<p>还有一些扩展运算符诸如&lt;&lt;=,&gt;&gt;=,&amp;=,^-,|=，用法和之前说过的类似。</p>
<p>位运算的对象可以是整型和字符型数据。当两个运算数类型不同时位数也会不同。遇到这种情况时，系统将自动进行如下处理：</p>
<p>1.将两个运算数右端对齐。</p>
<p>2.将位数短的一个运算数往高位补位，无符号数和正整数左侧补0，负数左侧用1补全，然后再进行计算。</p>
<p>位运算的速度非常快，快到单次位运算的时间很难被计算机测量出来。</p>
<h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><p>C语言中，对于输入、输出的数据都按照“数据流”的形式进行处理，也就是说，输出时，系统不添加任何信息，输入时，逐一读入数据，直到遇到EOF或者文件结束标志。C程序中的输入、输出文件都以数据流的形式存储在介质上。C语言支持顺序存取和直接存取。</p>
<p>顺序存取文件的特点是：每当“打开”这类文件，进行读写操作时，总是从文件的头开始，从头到尾顺序地读写。</p>
<p>直接存取文件又称随机存取文件，其特点是：可以通过调用C语言的库函数去指定开始读或写的字节号，然后直接对此位置上的数据进行读写或者把数据写在此位置。数据可以按文本形式或者二进制形式存放在介质上，因此文件可以按数据的存放形式分为文本文件和二进制文件，这两种文件都可以用上述两种方法进行存取。但是对二进制文件的操作要比对文本文件的操作要快一些，因为省去了一步转化的操作。</p>
<p>ANSI C规定，在对文件进行输入或输出的时候，系统将为输入或输出文件开辟缓冲区。它是系统在内存中为各个文件开辟的一片存储区，当对某个文件进行输出时，系统首先把输出的数据填入为该文件开辟的缓冲区内，每当缓冲区被填满时，就把缓冲区的内容一次性地输出到对应的文件中。当从某文件输入数据时，首先将从输入文件中输入一批数据放入到该文件的内存缓冲区中，输入语句将从该缓冲区依次读取出局，当该缓冲区中的数据被读完时，将再从输入文件中输入一批数据放入。这种方式使得读、写操作不必频繁地访问外设，从而提高了读写操作的速度。</p>
<p>文件指针实际上是一个指向结构体类型的指针，这个结构体中包含诸如缓冲区的地址，在缓冲区中当前存取字符的位置，对文件是读还是写，是否出错，是否文件结束等一些列信息。一般称之为FILE。</p>
<p>在C语言中，使用fopen打开文件就可以把程序要读写的文件和磁盘中的文件联系起来。格式是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *f;</span><br><span class="line">f = fopen(<span class="string">&quot;文件名&quot;</span>, <span class="string">&quot;文件打开方式，不仅仅是r和w&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当打开文件错误时，fopen将返回NULL。可以利用这个性质设置文件读错误的报错信息。</p>
<p>文件打开方式比较常用的有这些：</p>
<p>1.”r”，以读方式打开文本。只能读，如果文件不存在会报错，如果文件不可读会报错。</p>
<p>2.”rb”，以只读方式打开二进制文本。其他的和上边那个一样。</p>
<p>3.”w”，以只写方式打开文本。如果指定的文件不存在，则系统会以指定的文件名新建一个文件。</p>
<p><strong>如果指定的文件已存在，则会把原来的内容全部覆盖，千万要注意！！！</strong></p>
<p>4.”wb”，以只写方式打开二进制文本。其他的和上边那个一个样。</p>
<p>5.”a”，为在后面添加数据而打开文本文件。如果指定的文件不存在，则系统会以指定的文件名新建一个文件。如果指定的文件已存在，则会在原来文件的末尾继续写。</p>
<p>6.”ab”，为在后面添加数据而打开二进制文本文件。其他的和上边那个一个样。</p>
<p>7.”r+”，为读和写打开文本文件，用这种方式时，指定的文件应该存在。既可以读又可以写，中间无需关闭。只是对于文件来说，读和写总是从该文件的起始位置开始。在写新的数据时，只覆盖新数据所占的空间，原来的数据不会丢失。</p>
<p>8.”rb+”，为读和写而打开二进制文本文件。除了它可以在任意位置开始读写，其他的和上边那个一个样。</p>
<p>9.”w+”，建立一个新文件，进行写操作，然后可以从头开始读。</p>
<p><strong>如果指定的文件已存在，则会把原来的内容全部覆盖，千万要注意！！！</strong></p>
<p>10.”wb+”，建立一个新二进制文件，进行写操作，然后可以从头开始读。除了它可以在任意位置开始读，其他的和上边那个一个样。</p>
<p>11.”a+”，功能与”a”相同，但是在文件尾部添加新数据后，可以从头读。</p>
<p>12.”ab+”，功能与”a+”相同，但是在文件尾部添加新数据后，可以从任意位置开始读。</p>
<p>（上面的任意位置开始读都是由一个叫做位置函数的东西完成的操作。）</p>
<p>当开始运行一个程序时，系统将负责打开三个文件，它们是标准输入文件、标准输出文件、标准错误文件。它们相应的文件指针叫做stdin，stdout，stderr。通常情况下，stdin与键盘连接，stdout和stderr与终端屏幕连接。注意：这些指针是常量，不可以重新赋值。</p>
<p>（相信OIer对此并不陌生，我们常用的freopen就少不了它们）</p>
<p>当对文件的读写操作完成后，必须将它关闭。关闭文件可以调用库函数fclose来完成。格式是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fclose(文件指针);</span><br></pre></td></tr></table></figure>

<p>在完成了对文件的操作后，应该关闭文件，否则文件缓冲区的剩余数据就会丢失。</p>
<p>使用putc/fputc输出字符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">putc(待输出的字符，可以是字符常量可以是字符变量, 文件指针);</span><br></pre></td></tr></table></figure>

<p>如果输出成功，该函数返回输出字符，失败返回EOF。</p>
<p>（tip：EOF的值是-1。）</p>
<p>fputc和它完全一样。。</p>
<p>同样的，getc/fgetc是输入字符的函数。和之前在游戏设计中使用到的getch一样，输入的字符是作为返回值的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ch = getc(文件指针);</span><br></pre></td></tr></table></figure>

<p>它从文件指针指定的文件中读入一个字符，对，就读入一个。</p>
<p>fgetc和它完全一样。。</p>
<p>EOF用来判断文本的结束，因为ASCII中没有-1所对应的字符，所以它可以用作文本结束的标志，但是对于二进制文件来说，可能会出现-1，这个时候EOF就不管用了。还好，ANSI<br>C 提供了一个feof函数，判断文件是否结束。它接收一个参数，文件指针。返回值为1时文件结束，否则返回0。</p>
<p>fscanf函数只能从文本文件中按照格式读入，它与scanf唯一的区别就是参数表的最前面加了个文件指针。</p>
<p>fprintf函数按格式将内存中的数据转换成对应字符，并以ASCII代码形式输出到文件中。它也是多一个文件指针，其他的和printf一样。</p>
<p>fgets用来读入字符串。形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fgets(存放字符串的起始地址, 向后读多少位（并不是读多少位）, 文件指针);</span><br></pre></td></tr></table></figure>

<p>这里第二个参数要注意说明。假设写了一个n，那么它会从字符串的起始地址向后读n-1个字符。如果未读满字符时就读到了换行符或者EOF，则结束本次读操作。读入结束后系统自动加\0，返回值是读到的字符串。</p>
<p>fputs函数输出字符串到文件中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(等待输出的字符串, 文件指针);</span><br></pre></td></tr></table></figure>

<p>等待输出的字符串可以是字符串常量，可以是指向字符串的指针，或者字符数组名。该函数输出并不会输出\0，也不换行。输出成功函数值为一个正整数，否则是EOF。</p>
<p>根据它的特点，在调用fputs输出字符串时，文件中各字符串将首尾相接，它们之间不存在任何间隔符。为了便于读入，在输出字符串时，应当注意人为加入\n进行分分隔。</p>
<p>fread和fwrite分别用来读、写二进制文件。它们调用形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fread(指向数据块的指针（内存块的首地址）, 每个数据块的字节数, 每读写一次输入或输出的数据块个数, 文件指针);</span><br><span class="line">fwrite(准备输出的数据块的起始地址, 每个数据块的字节数, 每读写一次输入或输出的数据块个数, 文件指针);</span><br></pre></td></tr></table></figure>

<p>还有一个文件定位函数。在介绍文件定位函数之前，要先介绍一下文件位置指针。</p>
<p>文件指针和文件位置指针是不同的概念。文件指针是指在程序中定义的FILE类型的变量，通过fopen函数调用给文件指针赋值，使文件指针和某个文件建立联系，C程序中通过文件指针实现对文件的各种操作。</p>
<p>文件位置指针是一个形象化的概念。我们将用文件位置指针来表示当前读或写的数据在文件中的位置。当通过fopen函数打开文件时，可以认为文件位置指针总是指向文件的开头、第一个数据之前。当文件位置指针指向文件末尾时，表示文件结束。当进行读操作时，总是从文件位置指针所指位置开始，去读其后的数据，然后位置指针移动到尚未读的数据之前，以备指示下一次的读或写操作。当进行写操作时，总是从文件位置指针所指位置开始去写，然后移到刚写入的数据之后，以备指示下一次输出的起始位置。</p>
<p>fseek函数用来移动文件位置指针到指定的位置上，接着的读或写操作将从此位置开始。它的调用形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fseek(文件指针, 以字节为单位的偏移量（长整型）, 起始地点（可以是标识符也可以是数字，代表偏移操作以哪个地方为基准）);</span><br></pre></td></tr></table></figure>

<p>起始地点标识符有三个。</p>
<p>SEEK_SET，也是数字0，代表文件开始。</p>
<p>SEEK_END，也是数字2，代表文件末尾。</p>
<p>SEEK_CUR，也是数字1，代表文件当前位置。</p>
<p>对于二进制文件，偏移量为正时向文件尾部移动，偏移量为负时向文件首部移动。</p>
<p>对于文本文件，偏移量必须是0。</p>
<p>ftell函数用来获得文件当前位置指针的位置。函数给出当前位置指针相对于文件开头的字节数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> t;</span><br><span class="line">t = ftell(文件指针);</span><br></pre></td></tr></table></figure>

<p>当函数调用出错时，返回-1L。</p>
<p>当打开一个文件时，通常不知道它的长度，可以先通过fseek把位置指针移到末尾，然后用ftell求出文件长度。</p>
<p>如果是二进制文件，里面存放的是struct test中的数据，还可以拿求出来的长度除以sizeof(struct<br>test)来获得以该结构体为单位的数据块个数。</p>
<p>rewind函数又称反绕函数，让文件的位置指针返回文件开头，它没有返回值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rewind(文件指针);</span><br></pre></td></tr></table></figure>

<p>完结撒花~</p>
]]></content>
      <categories>
        <category>程序设计基础</category>
      </categories>
  </entry>
  <entry>
    <title>数据库系统概论 学习笔记</title>
    <url>/2018/08/25/database/</url>
    <content><![CDATA[<p>数据库技术是计算机领域的一个重要分支。数据库技术就是作为一门数据处理技术发展起来的。随着计算机应用的普及和深入，数据库技术变得越来越重要。</p>
<p>该部分学习笔记曾在2018年发布。</p>
<p>当前博客显示的发布时间非真实时间，而是这些内容在当时发布时的最后发布时间。</p>
<p><img src="https://i.loli.net/2018/08/25/5b80d069098b0.png"></p>
<a id="more"></a>

<h2 id="数据库系统的基本概念"><a href="#数据库系统的基本概念" class="headerlink" title="数据库系统的基本概念"></a>数据库系统的基本概念</h2><p>数据是一种描述事物的符号记录。计算机中的数据一般分为两个部分，其中一部分与程序仅有短时间的交互关系，它们被称之为临时性数据，它一般被放在内存里。还有一部分数据被称之为持久性数据，它对系统起着长期而持久的作用。数据库处理什么？处理持久性数据。</p>
<p>我们知道，数据是有一定结构的。首先，数据有型与值之分，数据的型给出了数据表示的类型，如整型，实型，字符型等，而数据的值给出了符合型的一个值。许多复杂的数据按照一定方式组合到一起是数据结构。数据库在特定条件下称之为数据模式。在数据库系统中需要对数据进行集中、统一的管理。</p>
<p>数据库是数据的集合，它具有统一的结构形式并存放于统一的存储介质中。数据库存放数据是按照数据所提供的数据模式存放的。数据库中的数据具有“集成”，“共享”的特点。</p>
<h2 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h2><p>数据库管理系统简称DBMS，是数据库的机构，它是一种系统软件，负责数据库中的数据组织、数据操纵、数据维护、控制及保护数据服务等。数据库中的数据结构复杂，必须要提供管理工具。数据库管理系统是数据库系统的核心，它主要有如下几方面的具体功能：</p>
<p>1.数据模式定义。</p>
<p>2.数据存取的物理构建</p>
<p>3.数据操纵</p>
<p>4.数据的完整性</p>
<p>5.数据库的并发控制与故障恢复</p>
<p>6.数据的服务</p>
<p>数据库管理系统一般提供相应的数据语言，它们是：数据定义语言（DDL），该语言负责数据的定义与构建。数据操纵语言（DML），该语言负责数据的操纵。数据控制语言（DCL），该语言负责数据的完整性、安全性的定义与检查以及并发控制、故障恢复等功能。</p>
<p>上述数据语言按其使用方式有两种结构形式：交互式命令语言与宿主型语言。</p>
<p>关系数据库中普遍使用了结构化查询语言SQL，该语言是一种介于关系代数数和关系演算之间的非过程性操作语言，是集DDL、DML、DCL于一体的关系数据库语言。SQL是高级的非过程性语言，允许用户在高层数据结构上工作。SQL语言也可以嵌入到其他高级语言中使用。</p>
<p>此外，数据库管理系统还有为用户提供服务的服务性程序，包括数据初始装入程序、数据转存程序、性能监测程序、数据库再组织程序、数据转换程序、通信程序等。</p>
<p>目前流行的DBMS均为关系数据库系统。另外有一些小型的数据库，他们只具备数据库管理系统的一些简单功能。</p>
<h2 id="数据库管理员"><a href="#数据库管理员" class="headerlink" title="数据库管理员"></a>数据库管理员</h2><p>由于数据库的共享性，因此对数据库的规划、设计、维护、监视等需要有人专门管理，我们称他们为数据库管理员（DBA）。</p>
<p>DBA的主要任务之一是做数据库设计，具体的说是数据模式的设计。DBA必须对数据库中的数据安全性、完整性、并发控制及系统恢复、数据定期转存等实施提供维护。</p>
<p>DBA必须随时监视数据库运行状态，不断调整内部结构，使系统保持最佳状态与最高效率。当效率下降时，DBA应该采取适当的措施。</p>
<h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><p>数据库系统（DBS）由如下几部分组成：数据库，数据库管理系统，数据库管理员，硬件平台，软件平台。这五个部分构成了一个以数据库为核心的的完整的运行实体，简称为数据库系统。</p>
<p>硬件平台包括：计算机，网络。</p>
<p>软件平台包括：操作系统，数据库系统开发工具，接口软件。</p>
<h2 id="数据库系统的发展"><a href="#数据库系统的发展" class="headerlink" title="数据库系统的发展"></a>数据库系统的发展</h2><p>数据管理发展至今经历了三个阶段：人工阶段，文件系统阶段和数据库系统阶段。随着计算机应用领域不断扩大，数据库系统的功能和应用范围越来越广，到目前已成为计算机系统的基本及主要的支撑软件。</p>
<p>目前，数据库技术也与其他信息技术一样在迅速发展之中，计算机处理能力的增强和越来越广泛的英语是促进数据库技术发展的重要动力。分布式数据库技术是大数据时代云计算技术的基础，是数据的基本存储方式；在大量应用中对数据库管理系统提出里高可靠性、高性能、高伸缩性和高安全性的要求。一般认为，未来的数据库系统应该支持数据管理、对象管理和知识管理，应该具有面向对象的基本特征。在关于数据库的诸多新技术中，下面三种是比较重要的。</p>
<p>面向对象的数据库系统：用面向对象的方法构筑面向对象数据模型，使其具有比关系数据库系统更为通用的能力；</p>
<p>知识库系统：用人工智能中的方法特别是用谓词逻辑知识表示方法构筑数据模型，使其模型具有特别通用的能力。</p>
<p>关系数据库系统的扩充：利用关系数据库做进一步扩展，使其在模型的表达能力与功能上有进一步的加强。</p>
<h2 id="数据库系统的基本特点"><a href="#数据库系统的基本特点" class="headerlink" title="数据库系统的基本特点"></a>数据库系统的基本特点</h2><p>1.数据的集成性</p>
<p>在数据库系统中采用统一的数据结构方式。在数据库系统中按照多个应用的需要组织全局的统一的数据结构，数据模式不仅可以建立全局的数据结构，还可以建立数据见的语义联系从而构成一个内在紧密联系的数据整体。数据库系统中的数据模式是多个应用共同的、全局的数据结构，而每个应用的数据则是全局结构中的一部分，称为局部结构。这种全局与局部的结构模式构成了数据库系统数据集成性的主要特征。</p>
<p>2.数据的高共享性与低冗余性</p>
<p>数据库与网络的结合扩大了数据关系的应用范围。数据的共享自身又可极大的减少数据的冗余性。</p>
<p>3.数据独立性</p>
<p>数据独立性是数据与程序间的互不依赖性，即数据库中数据独立于应用程序而不依赖于应用程序。数据独立性一般分为物理独立性与逻辑独立性两级。</p>
<p>物理独立性即是数据的物理结构的改变都不影响数据库的逻辑结构，从而不至于引起应用程序的变化。</p>
<p>数据库总体逻辑结构的改变，不需要相应修改应用程序。</p>
<p>4.数据统一管理与控制</p>
<h2 id="数据库系统的内部结构体系"><a href="#数据库系统的内部结构体系" class="headerlink" title="数据库系统的内部结构体系"></a>数据库系统的内部结构体系</h2><p>数据库系统在其内部具有三级模式以及二级映射。三级模式分别是概念级模式、内部级模式、外部级模式。二级映射则分别是概念级到内部级映射以及外部级到概念级的映射。这种三级模式与二级映射构成了数据库系统内部抽象的结构体系。</p>
<h2 id="数据库设计概述"><a href="#数据库设计概述" class="headerlink" title="数据库设计概述"></a>数据库设计概述</h2><p>数据库设计是数据库应用的核心。在数据库应用系统中的一个核心问题就是设计一个能满足用户要求，性能良好的数据库，这就是数据库设计。数据库设计的基本任务是根据用户对象的信息需求，处理需求和数据库的支持环境设计出数据模式。所谓信息需求主要是值用户对象的数据以及其结构，它反映了数据库的静态要求；所谓处理需求则表示用户对象的行为和动作，它反映了数据库的动态要求。数据库设计中有一定的制约条件，它们是系统设计平台，包括系统软件、工具软件以及设备、网络等硬件。因此，数据库设计即是在一定平台的制约下，根据信息需求与处理需求设计出性能良好的数据模式。</p>
<p>在数据库设计中有两种方法。一种是以信息需求为主，兼顾处理需求，称之为面向数据的方法。另一种方法则是处理需求为主，兼顾信息需求，称为面向过程的方法。这两种方法目前都在使用中，在早期面向过程的方法应用比较多，目前是面向数据的方法使用越来越广泛。数据在系统中稳定性较高，目前数据已经成为了系统的核心，因此面向数据的设计方法已经成为了主流方法。</p>
<p>数据库设计目前一般采用生命周期法，即将整个数据库应用系统的开发分解成目标独立的若干阶段。它们是：需求分析阶段、概念设计阶段、逻辑设计阶段、物理设计阶段、编码阶段、测试阶段、运行阶段、进一步修改阶段。</p>
<h2 id="数据库设计的需求分析"><a href="#数据库设计的需求分析" class="headerlink" title="数据库设计的需求分析"></a>数据库设计的需求分析</h2><p>这是数据库设计的第一阶段。这一阶段收集到的基础数据和一组DFD是下一步的基础。需求分析阶段的任务是通过详细调查现实世界要处理的对象吗充分了解原系统的工作概况，明确用户的各种调查需求，然后在此基础上确定新系统的功能。新系统必须充分考虑今后可能的扩充和改点，不能仅按照当前应用需求来设计数据库。</p>
<p>调查的重点是数据和处理，需要如下要求。</p>
<p>1.信息要求，指用户需要从数据库中获得信息的内容与性质。</p>
<p>2.处理要求，指用户要完成什么处理功能，对处理的响应时间、方式做何要求。</p>
<p>3.安全性和完整性的要求。</p>
<h2 id="数据库概念设计"><a href="#数据库概念设计" class="headerlink" title="数据库概念设计"></a>数据库概念设计</h2><p>数据库概念设计的方法有以下两种：</p>
<p>1.集中式模式设计法。这是一种统一的模式设计方法，它根据需求由一个统一机构或人员设计一个综合的全局模式。这种方法简单方便，适合小型部门，但是对大型单位则不太适合。</p>
<p>2.视图集成设计法。将一个单位分解为若干部分，对每个部分做局部模式设计， 建立视图，再以视图为基础进行集成。集成过程中可能存在冲突。</p>
<p>使用E-R模型与视图继承法进行设计时，首先选择局部应用，再进行局部视图设计，最后对局部视图进行集成得到概念模式。</p>
<h2 id="数据库的逻辑设计"><a href="#数据库的逻辑设计" class="headerlink" title="数据库的逻辑设计"></a>数据库的逻辑设计</h2><p>数据库的逻辑设计主要工作是将E-R图转换为指定RDBMS中的关系模式。从E-<br>R图到关系模式的转换是比较直接的，实体与联系都可以表示成关系。E-R图中的属性也可以转化成关系的属性。</p>
<p>转换时可能绘遇到一些问题。</p>
<p>关系模式中的命名可以用E-<br>R图中原有命名，也可以另行命名，但是应该尽量避免重名。RDBMS一般只支持有限种的数据类型。如果有RDBMS不支持的数据类型则要进行转换。</p>
<p>E-R图中允许出现非原子属性。但是关系模式一般不允许。非原子属性主要有集合型和元组型，如果有这种情况可以进行转换。集合属性纵向展开，元组关系横向展开。</p>
<p>转换一定要体现规范化。关系数据库设计的关键是关系数据库模式的设计，即确定构造几个关系模式以及每一个模式自身包含的属性，将相互关联的模式组成合适的关系模型。设计不良的关系模式会有数据冗余，插入删除修改异常等问题。</p>
<p>逻辑设计的另一个重要内容是关系视图的设计。它又称为外模式设计。关系视图是在关系模式基础上所设计的直接面向操作用户的视图，它可以根据用户需求随时创建。一般的RDBMS都提供这样的功能。</p>
<h2 id="数据库的物理设计"><a href="#数据库的物理设计" class="headerlink" title="数据库的物理设计"></a>数据库的物理设计</h2><p>数据库物理设计的主要目标是对数据库内部物理结构做出调整并选择合理的存取路径，以提高数据库访问速度以及有效利用存储空间。在现代关系数据库中已经大量屏蔽了内部物理结构，因此留给用户参与物理设计的余地并不多。一般的RDBMS中留给用户参与物理设计的内容大概有：索引设计、集簇设计和分区设计。</p>
<h2 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h2><p>数据库管理需要专人进行。这人叫DBA，之前的文章说过。</p>
<p>首先是数据库的建立。数据模式由DBA负责建立。在数据模式定义后就可以加载数据，DBA可以编制加载程序将外界数据加载至数据模式内，从而建立起数据库。</p>
<p>然后是数据库的调整。数据库建立并经过一段时间后往往会产生一些不适应的情况，这时候我们需要对它们做出调整。这个工作也是DBA去完成。主要是调整关系模式与视图，调整索引与集簇，调整分区、数据库缓冲区大小等。</p>
<p>然后是数据库的重组。数据库在经过一定时间运行后性能会有所下降，下降的原因主要是不断地修改，删除和插入造成的。由于不断地删除造成盘区内废块增多，磁盘的I/O速度会受到影响，DBA要对此情况作出整理操作。实际中，往往是先做程序卸载，再加载数据从而达到数据重组的目的。</p>
<p>然后是数据库安全心控制与完整性控制。数据库是一个单位的重要资源，安全性是极端重要的。DBA应该采取措施保证数据不被非法盗用或者破坏。此外，为保证数据的正确性，需要有数据的完整性控制。</p>
<p>最后是数据库的故障恢复与监控。一旦数据库中的数据遭受破坏，DBA应该立即着手恢复。现在的RBDMS一般都提供这个功能。DBA需要随时观察数据库的动态变化，并且在发生异常时做出判断并采取措施。</p>
<h2 id="数据模型的基本概念"><a href="#数据模型的基本概念" class="headerlink" title="数据模型的基本概念"></a>数据模型的基本概念</h2><p>数据是现实世界符号的抽象，而数据模型则是数据特征的抽象，它从抽象层次上描述了系统的静态特征、动态行为和约束条件，为数据库的信息表示与操作提供一个抽象的框架。数据模型所描述的内容分成三个部分，数据结构，数据操作与数据约束。</p>
<p>1.数据结构</p>
<p>数据模型中的数据结构主要描述数据的类型、内容、性质以及数据之间的联系等。数据结构是数据模型的基础，数据操作与约束都建立在数据结构上。</p>
<p>2.数据操作</p>
<p>数据模型中的数据操作主要描述在相应数据结构上的操作类型与操作方式。</p>
<p>3.数据约束</p>
<p>数据模型中的数据约束主要描述数据结构内数据见的语法、语义联系，他们之间的制约与依存关系，以及数据动态变化的规则，以保证数据的正确，有效与相容。</p>
<h2 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h2><p>长期一来被广泛使用的概念模型是E-<br>R模型。该模型将现实世界的要求转化为实体、联系、属性等几个基本概念，以及它们间的两种基本连接关系，并且可以用一种图非常直观地表示出来。</p>
<p>1.E-R模型的基本概念</p>
<p>现实世界中的事物可以抽象为实体，实体是概念中的基本单位，它们是客观存在的且又能相互区别的事物。</p>
<p>现实世界中事物均有一些特性，这些特性可以用属性来表示。属性刻画了实体的特征。</p>
<p>现实世界中事物的关联称之为联系。在概念世界中联系反映了实体集间的一定关系。这种联系的个数可以是一个也可以是多个。两个实体之间的联系实际上是实体集之间的函数关系。</p>
<p>函数关系还是那些，一对一，一对多或多对一，多对多……其中一对一简记为1:1，它是最常见的函数关系。一对多简记为1：M，多对一简记为M：1，这两种函数关系其实算一种，举个例子，学生与其宿舍房间的关系是多对（有好多学生入住这一个宿舍），但是宿舍房间对学生的关系就是一对多。多对多简记为M:N，这种关系相对复杂一些，比如教师与学生的关系。一个教师可以教很多学生，同时，一个学生又可以被多个老师教。</p>
<p>2.E-R模型三个基本概念之间的连接关系。</p>
<p>E-R模型的基本概念是哪三个？</p>
<p>实体，联系，属性。这三者结合起来才能表示现实世界。</p>
<p>实体是概念世界中的基本单位，属性附属于实体，属性本身并不构成独立单位。属性有属性域，每个实体可以取这个域内的值。一个实体的所有属性取值的集合叫做元组。在概念世界中，元组可以表示实体，也可以区别实体。</p>
<p>实体有型和值之分，和之前讲的数据一样。</p>
<p>联系也可以附有属性，联系和它的所有属性构成了联系的一个完整描述，因此，联系与属性间也有连接关系。</p>
<p>实体集间可通过联系建立关系。一般而言，实体集间无法建立直接关系，他只能通过联系才能建立起连接关系。</p>
<p>在E-R模型中有三个基本概念以及它们之间的两种基本连接关系。它们将现实世界中的错综复杂现象抽象成简单明了的几个概念关系，具有极强的概括性和表达能力。</p>
<p>3.E-R模型的图示法</p>
<p>E-R模型可以通过一个很直观的图来表示，这种图叫做E-R图。在E-R图中我们下面不同的几何图形表示这三个概念和两个连接关系。</p>
<p>首先是实体集表示法。用矩形表示，在里面写实体集的名字。</p>
<p><img src="https://i.loli.net/2018/08/24/5b8008c27f7d6.png"></p>
<p>然后是属性表示法。用椭圆。里面写属性名。</p>
<p><img src="https://i.loli.net/2018/08/24/5b8008c27f376.png"></p>
<p>最后是联系表示法。用菱形。内写联系名。</p>
<p><img src="https://i.loli.net/2018/08/24/5b8008c285e5f.png"></p>
<p>要表示之间有关系，连起来就好了。</p>
<p>（图片来自网络，博主有点懒）（摊┑(￣Д ￣)┍</p>
<p><img src="https://i.loli.net/2018/08/24/5b8009de76095.jpg"></p>
<p>连起来大概是这么个玩意。</p>
<p>然后，这鬼东西还有两种不同的模型。</p>
<h2 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h2><p>层次模型是最早发展起来的数据库模型。它的基本结构是树形。这种结构方式在现实生活中非常普遍。自顶向下，层次分明。既然基本结构是树，那么树的一些性质它也是满足的。</p>
<p>性质1 每棵树有且仅有一个无双亲结点，称之为根。</p>
<p>性质2 树中除根节点外所有一个节点有且只有一个父节点。</p>
<p>由性质2，这种模型是受到一定限制的。在对这种模型进行插入或者删除操作时，一定要注意满足约束条件。层次模型的结构简单，操作简单，层次模型的性能是比较高的。但是由于它受文件系统影响大，模型限制较多，在实际使用上效果并不是很理想。它并不适合表示非层次关系。</p>
<p>大概长这个样：（图片来自网络）</p>
<p><img src="https://i.loli.net/2018/08/24/5b800bcbe79f9.jpg"></p>
<p>·网状模型</p>
<p>网状模型的出现略晚于层次模型。如果从图论的角度去理解网状模型，它就是一张无向图。网状模型在结构上要稍微好一点，它的要求没有层次模型那么严格。</p>
<p>在实现中，网状模型将通用的网络拓扑结构分成一些基本结构。一般采用的分解方法是将一个网络分成若干个二级树，也就是只有两个层次的树。为了实现的方便，一般规定根节点与任一叶节点间的联系都是一对多的（有时候也是一堆一）。</p>
<p>在网状模型的标准中，基本结构简单二级树叫系，系的基本数据单位是记录，它相当于E-R模型中的实体集。记录又可以由若干数据项组成，它相当于E-<br>R模型中的属性。系有一个首记录，它相当于简单二级树的根，若干个成员记录相当于叶。</p>
<p>（图片来自刚才的图，博主懒）（摊┑(￣Д ￣)┍</p>
<p><img src="https://i.loli.net/2018/08/24/5b8009de76095.jpg"></p>
<h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><p>1.关系的数据结构</p>
<p>关系模型用表格来表示。这个表格我们一般称二维表。二维表由框架以及元组组成。</p>
<p>表框架由n和属性组成，n称作属性元数。每个属性有一个取值范围，称为值域。</p>
<p>在表框架中按行可以存放数据，每一行的数据称为元组。实际上，一个元组是由n个元组分量构成的。一个表框架可以放m个元组，m称为基数。</p>
<p>这种二维表的元组个数是有限的，各个元组互不相同，元组次序可任意交换，元组的分量是不可以再分割的基本数据项，属性名各不相同，属性与次序无关，属性的分量具有与该属性相同的值域。</p>
<p>如果一个二维表能够满足上面的性质，那么它被称为关系。以这种二维表为基本结构建立的模型就是关系模型。</p>
<p>关系模型中的一个重要概念是键。键具有标识元组、建立元组间联系等重要作用。在二维表中凡能唯一标识元组的最小属性集称为该表的键。</p>
<p>二维表可能有很多的键，它们称为该表的候选键。</p>
<p>从二维表的所有候选键中选一个作为用户的键，称为主键。表A中的某个属性集是某表B的键，则称该属性集为A的外键。</p>
<p>在关系元组的分量中允许出现空值，表示信息空缺。空值表示未知或者不可能的值，一般表示为NULL。</p>
<p>2.关系操纵</p>
<p>关系模型的数据操纵即是建立在关系上的数据操纵。一般有查询、增加、删除和修改这四种操作。</p>
<p>用户可以查询关系数据库中的数据，它包括一个关系内的查询以及多个关系之间的查询。</p>
<p>这四种操作可以分解成六种基本操作：关系的属性指定；关系的元组选择；两个关系的合并；一个或多个关系的查询；关系中元组的插入；关系中元组的删除。</p>
<p>3.关系中的数据约束</p>
<p>关系模型中存在一些约束。</p>
<p>首先是实体完整性约束，它要求主键不能为NULL。这是数据库完整性的最基本的要求，因为主键是唯一决定元组的，如果为空值那么就不符合定义了。</p>
<p>然后是参照完整性约束。它不允许关系引用不存在的元组，即在关系中的外键要么是所关联关系中所实际存在的元组，要么为空。</p>
<p>最后是用户自定义的一些完整性约束。这个是针对具体情况由用户进行编写的。</p>
<p>实体完整性约束和参照完整性约束是关系数据库必须遵守的规则，在任何一个关系数据库管理系统中均由系统自动支持。</p>
<p>关系数据库系统的特点之一就是它建立在数学理论的基础之上。有很多数学理论可以表示关系模型的数据操作。其中最著名的是关系代数与关系演算。数学上已经证明了二者是等价的。关系数据库中使用的SQL语言可以支持关系代数中的运算和操作。</p>
<h2 id="关系模型的基本操作"><a href="#关系模型的基本操作" class="headerlink" title="关系模型的基本操作"></a>关系模型的基本操作</h2><p>关系是由若干个不同的元组组成，因此关系可以视为元组的集合。n元关系是一个n元有序组的集合。</p>
<p>设有一个n元关系R，它有n个域，分别是D1，D2，….，Dn。此时它们的笛卡尔积是</p>
<p><code>D1ｘD2ｘ…ｘDｎ</code></p>
<p>完了，笛卡尔积是啥……</p>
<blockquote>
<p>百度百科上这样讲：笛卡尔乘积是指在数学中，两个集合X和Y的笛卡尓积（Cartesian product），又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员。</p>
</blockquote>
<p>其实就是集合里面的成员乘积辣……</p>
<p>该集合的每个元素都是具有如下形式的n元有序组：</p>
<p><code>(d1,d2,…,dｎ)di∈Di(i = 1,2,…,n)</code></p>
<p>该集合与n元关系R有如下联系：</p>
<p><code>R⊆D1×D2×…×Dn</code></p>
<p>即n元关系R是n元有序组的集合，是它的域的笛卡尔积的子集。</p>
<p>关系模型的六种基本操作是：</p>
<p>1.关系的属性指定。用来检索与定位，用它确定列。</p>
<p>2.关系的元组的选择。也是用来检索与定位，用它确定行。</p>
<p>3.两个关系的合并。将两个关系合并成一个关系。</p>
<p>这三个操作可以进行多个关系的定位。</p>
<p>4.关系的查询。在一个关系或多个关系之间做查询，结果也是一个关系。</p>
<p>5.关系元组的插入。</p>
<p>6.关系元组的删除。</p>
<h2 id="关系模型的基本运算"><a href="#关系模型的基本运算" class="headerlink" title="关系模型的基本运算"></a>关系模型的基本运算</h2><p>由于操作是对关系的运算，而关系是有序组的集合，因此可以把操作看成集合之间的运算。</p>
<p>首先是插入，设把R插入到R’中，插入可以用集合的并运算。表示为<code>R∪R’</code></p>
<p>然后是删除，比如从R元组中删除掉关系R’（它是要删除的元组组成的集合），就可以用集合的差运算。表示为<code>R-R’</code></p>
<p>然后是修改，如果需要修改R’，那么先把它删除。然后进行修改操作，设修改后的元组构成关系R’’，再将其插入。<code>(R-R’)∪R’’</code></p>
<p>然后是查询。查询的操作没有办法用集合运算表示，需要引入一些新的运算。</p>
<p>投影运算</p>
<p>对于关系内的域，指定可引入新的运算叫做投影运算。它是一个一元运算，一个关系通过投影运算后仍为一个关系R’，R’是R中投影运算所指出的那些域的列所组成的关系。假设这个R有n个域，分别是A1，A2，….，An，则在R上对域的Ai1，Ai2，….，Aim(Aij ∈ |A1，A2，….，An|)的投影可以表示为下面的一元运算:</p>
<p><code>πAi1，Ai2，….，Aim(R)</code></p>
<p>选择运算</p>
<p>选择运算也是一个一元运算，关系R通过选择运算后仍为一个关系。这个关系是由R中那些满足逻辑条件的元组构成。如果设关系的逻辑条件为F，则R满足F的选择运算可以写成：</p>
<p><code>σF(R)</code></p>
<p>逻辑条件F是一个表达式，该表达式遵循下面的规则。</p>
<p>①可以是αΘβ的形式，α和β是变量（也就是域）或者常量，但是不能同时为常量，Θ作为比较符，就是什么大于小于等于不等于……这种东西。这一个形式的表达式是基本的逻辑条件，如果想表达更复杂的逻辑条件，还要用到且或非。这里且运算表示为∧，或运算表示为∨，非运算注意，表示为~而不是┐。</p>
<p>使用这些运算可以快速地限定寻找范围。</p>
<p>笛卡尔积运算</p>
<p>对于两个关系的合并操作可以用笛卡尔积来表示。设有n元关系R以及m元关系S，他们分别有p和q个元组，则关系R与S经过笛卡尔积运算记作R×S，它是一个n+m元的关系，元组个数是p×q，由R和S的有序组组合而成。</p>
<h2 id="关系代数中的扩充运算"><a href="#关系代数中的扩充运算" class="headerlink" title="关系代数中的扩充运算"></a>关系代数中的扩充运算</h2><p>1.交运算</p>
<p>关系R和S经过交运算后得到的关系是那些两者都在的有序组所组成。记作R∩S。</p>
<p>其实，不难得出</p>
<center>R∩S = R-(R-S)</center>

<p>等号右边不就是S吗？R∩S=S？？？</p>
<p>并不，这里的R-S说白了是集合间的运算，去括号那套操作……没法用。</p>
<p>2.除运算</p>
<p>它其实就是笛卡尔积的逆运算。当存在T = R×S时，则有</p>
<center>T÷R=S</center>

<p>也可以写成</p>
<center>T/R=S</center>

<p>S称为T除以R的商。</p>
<p>由于除法是一种逆运算，因此它的执行是需要满足一定条件的。假设有关系T和R，T能被除的充要条件是T的域中包含R的所有属性，且T中有一些域不在R中。</p>
<p>说白了就是R得是T的子集T才能除以R。。</p>
<p>除法运算不是基本运算，下面给出推导。</p>
<p>设关系R有域A1，A2，….，An，关系S有An-s+1，An-s+2，….，An，此时，有：</p>
<p><code>R÷S = πA1，A2，….，An-s(R)-πA1，A2，….，An-s( (πA1，A2，….，An-s(R)×S )-R )</code></p>
<p>妈耶，这也太复杂了……</p>
<p>3.连接与自然连接运算</p>
<p>在数学上，可以用笛卡尔积建立两个关系之间的连接，但是这样得到的关系巨大，数据冗余也比较多。实际应用中一般两个相互连接的关系往往须满足一些条件，所得到的结果也相对比较简单，这样我们引入了连接运算与自然连接运算。</p>
<p>连接运算是一种二元运算，它可以将两个关系合并为一个大关系。设有关系R、S以及表达式αΘβ，α表示R的域，β表示S中的域，Θ还是那个Θ，那么可以把连接运算定义为（woc这个我是真用HTML打不出来了，画图解决）</p>
<p><img src="https://i.loli.net/2018/08/25/5b811e7a55a1e.png"></p>
<p>这个鬼畜的式子啥意思呢。。R与S的的Θ链接是由R与S的笛卡尔积中满足限制αΘβ的元构成的关系，一般其元组的数目远少于R×S的数目。应当注意的是，在Θ连接中，α与β应该具有相同的域，否则无法做出比较。</p>
<p>在Θ连接中，如果Θ为“=”号，那么我们称该连接为等值连接，否则称为不等值连接。</p>
<p>在实际应用中最常用的连接是一个叫自然连接的特例。它满足下面的条件：两个关系之间具有公共域，通过公共域的相等值进行连接。</p>
<p>设有关系R、S，R有域A1，A2，….，An，S有域B1，B2，….，Bm，并且，Ai1，Ai2，….，Aij与B1，B2，….，Bj分别为相同域，此时它们的自然连接可以记为</p>
<p><img src="https://i.loli.net/2018/08/25/5b81219e20989.png" alt="img"></p>
<p>自然连接的含义可以用下式表示：</p>
<p><img src="https://i.loli.net/2018/08/25/5b8126075c311.png" alt="img"></p>
<p>（↑做上边那几个式子快把我做吐了）</p>
<p>在以上运算中最常用的是投影运算、选择运算、自然连接运算、并运算、差运算。</p>
<h2 id="关系代数的应用举例"><a href="#关系代数的应用举例" class="headerlink" title="关系代数的应用举例"></a>关系代数的应用举例</h2><p>不难看出，查询其实是最复杂的操作。查询语言一般是非过程语言，仅仅说明查询的要求，不说明查询的做法。最终通过查询优化技术解决了这个问题，而对于查询语句本身的优化也就是代数优化是最基本的技术。</p>
<p>比如说有一个学生选课的数据库，它由下面三个关系模式组成：</p>
<p>S(S#,Sn,Sd,Sa)</p>
<p>C(C#,Cn,P#)</p>
<p>SC(S#,C#,G)</p>
<p>其中S#表示学号，C#表示课程号（喂不是那个C#啊），Sn表示学生姓名，Sd表示学生系别，Sa表示学生年龄，Cn表示课程名，P#表示预修课程号，G表示成绩，C表示课程，S表示学生，SC表示选课关系。</p>
<p>那么，各种查询表达式：</p>
<p>1.检查学生所有情况。顾名思义，所有情况，那看来要把整个关系都调出来，所以查询表达式是</p>
<center>S</center>
2.检查学生年龄大于等于20岁的学生姓名。这里要用到投影运算。其实不难理解，我们只是调出来看一看，不用修改，投影运算正好是不改变原来的关系的。这里有两个限制，一个是学生姓名，还有一个是大于等于二十岁。我们要查的是姓名，所以要写πSn，后面年龄的条件怎么写呢？是σSa≥20。可是这样就完了吗？并不，我们要查询的关系是在哪的？查询的是学生，所以在S里面，最后，写出来是这么个鬼东西：

<center>π<sub>Sn</sub>(σ<sub>Sa</sub>≥<sub>20</sub>(S))</center>
3.我要检索预修课号为C2的课程的课程号。这是查询课程，要在C里面查询。课程号是C#，预修课号是P#，所以，很简单的吧。。

<center>π<sub>C#</sub>(σ<sub>P#</sub>=<sub>C2</sub>(C))</center>
4.检索课程号为C里面所有成绩是A的学生姓名。这个就稍微复杂一些，学生选课的关系放在SC里面，学生姓名放在S里面，所以查询的位置应该是S⋈SC。课程号为C，成绩为A，两个条件，同时满足，写表达式时要用到且运算。最后写出来是这么个鬼东西：

<center>π<sub>Sn</sub>(σ<sub>C#</sub>=<sub>C∧G</sub>=<sub>A</sub>(S⋈SC))</center>

<p>前面看起来挺懵逼的，其实实际操作起来还是相对容易一些。如果要查询非常多条件的数据，可以分步，然后再合并。</p>
]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>关系代数</tag>
        <tag>数据模型</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程基础 学习笔记</title>
    <url>/2018/08/23/software-engineering/</url>
    <content><![CDATA[<p>这里记录了关于软件工程基础概念的一些相关内容，该部分学习笔记曾在2018年发布。</p>
<p>当前博客显示的发布时间非真实时间，而是这些内容在当时发布时的最后发布时间。</p>
<p><img src="https://i.loli.net/2018/08/22/5b7d73173aed7.png"></p>
<a id="more"></a>

<h2 id="软件定义与软件特点"><a href="#软件定义与软件特点" class="headerlink" title="软件定义与软件特点"></a>软件定义与软件特点</h2><p>计算机软件是计算机系统中与硬件相互依存的另一部分。是包括程序，数据以及相关文档的完整集合。可见软件由两部分组成：一是机器可执行的程序和数据，二是机器不可执行的，与软件开发、运行、维护、使用等有关的文档。软件是一种逻辑实体，而不是物理实体，它具有抽象性。人们可以把它记录在纸上或者存储介质上，但是没有办法看到软件本身的形态。软件的生产与硬件不同，它没有明显的制作过程。一旦研制开发成功，可以大量拷贝同一内容副本。此外，软件在运行、使用期间不存在磨损，老化问题。但是软件可以退化，因为随着软件的不断更新，开发者们需要对软件做出一定的修改，而这些修改又会不可避免地引入错误，软件失效率会升高，软件就有可能退化。</p>
<p>与此同时，软件的开发与运行对计算机系统具有依赖性，受到计算机系统的限制，这会导致很多软件的移植问题。<br>目前的软件还存在很多跨版本兼容问题。软件的复杂性决定了开发软件的成本是很高的。可以说，软件是人类有史以来生产的复杂度最高的工业产品。软件涉及到人类社会的各行各业，方方面面。也就是说，软件开发通常会涉及到其他领域的专业知识。软件开发需要投入大量、高强度的脑力劳动，成本高，风险大<br><del>（祭天事件，手机壳事件了解一下）</del> 。</p>
<p>而且，软件的开发还涉及很多的社会因素。许多软件的开发和运行涉及到软件用户的机构设置，体制问题以及管理方式等等因素，它甚至会涉及到人们的观念，心理，甚至知识产权和法律的问题。</p>
<p>软件根据应用目标的不同，分类是多种多样的。按照功能，可以分为应用软件、系统软件、工具软件。应用软件是为了解决特定领域的应用而开发的软件。系统软件是计算机管理自身资源，提高计算机使用效率并服务于其他程序的软件。工具软件介于系统软件和应用软件之间，它可以协助用户进行开发。</p>
<h2 id="软件危机与软件工程"><a href="#软件危机与软件工程" class="headerlink" title="软件危机与软件工程"></a>软件危机与软件工程</h2><p>软件工程的的概念的出现源自于软件危机。所谓软件危机是泛指在计算机软件的开发和维护中遇到的一系列严重的问题。实际上，几乎所有的软件都不同程度的存在这样的问题。随着计算机技术的发展和应用领域的扩大，计算机的性价比和质量在逐步提高，软件规模不断增加，复杂度也不断增加。</p>
<p>那么软件危机主要体现在哪些地方呢？</p>
<p>1.软件需求的增长得不到用户的满足，用户对软件不满意的情况时常发生。</p>
<p>（行行行你是甲方你牛逼）</p>
<p>2.软件开发的成本和进度无法控制，开发成本日常超出预算，开发周期远超过计划的事情时有发生。</p>
<p>3.软件质量难以保证。</p>
<p>4.软件可维护性很差。</p>
<p>（上一个接手这个项目的程序员在哪？我要砍死这个一句注释不写的小崽子）</p>
<p>5.软件开发的生产率的提高赶不上硬件发展和应用需求的增长</p>
<p>（说白了还是你们甲方牛逼是吧，你们以为程序员是创造神吗，想要啥就能立马造出啥来。。）</p>
<p>总之，软件危机很严重就是了。。。。</p>
<p>所以，为了消除软件危机，软件工程的概念慢慢进入人们的视野。软件工程就是试图用工程、科学和数学的原理与方法研制维护计算机软件的有关技术以及管理方法。它让软件开发更加系统化，规范化。</p>
<p>软件工程包含三个要素，方法，工具和过程。方法是完成软件工程项目的技术手段，工具用来支持软件的开发、管理、文档生成；过程支持软件开发的各个环节的控制和管理。软件工程的进步和学科的发展是近几十年来软件产业迅速发展的重要原动力。软件工程的核心思想就是把软件产品看作是一个工程产品来处理。把各种工程化的概念引入到软件生产当中。同时，软件工程也有很多有别于一般工业工程技术的一些技术方法。</p>
<p>特别的，从经济学的意义上来说，考虑到软件庞大的维护费用远比软件开发费用高，因而开发软件不能只考虑开发期间的费用，而应该考虑到软件在一个生命周期内需要的全部费用。</p>
<h2 id="软件过程与软件生命周期"><a href="#软件过程与软件生命周期" class="headerlink" title="软件过程与软件生命周期"></a>软件过程与软件生命周期</h2><p>软件过程是把输入转化为输出的一组彼此相关的资源和活动。软件过程通常包含4中基本活动。</p>
<p>1.软件规格说明，简称P，规定软件的功能以及限制。</p>
<p>2.软件开发或软件设计与实现，简称D，生产满足规格的软件。</p>
<p>3.软件确认，简称C，确认客户满意该软件。</p>
<p>4.软件演进，简称A，为了满足客户变得比天都快的需求，软件必须能够在不断使用中演进。</p>
<p>通常，将软件产品从提出、实现、使用到维护到停止使用的过程称为软件生命周期。我们可以把它分成简单的三个阶段，首先是定义阶段，它包括可行性研究与初步项目计划，然后就是需求分析。然后是开发阶段，从上至下是总体设计，详细设计，编码，测试。第三阶段就是软件的维护阶段，分为使用，维护和退役三个过程。</p>
<h2 id="软件工程的目标与原则"><a href="#软件工程的目标与原则" class="headerlink" title="软件工程的目标与原则"></a>软件工程的目标与原则</h2><p>在给定成本、进度的前提下，开发出具有有效性、可靠性、可理解性、可维护性、可重用性、可适应性、可移植性、可追踪性和可操作性且满足用户需求的产品。基于软件工程的目标，软件工程的理论和技术性研究的内容主要包括软件开发技术和软件工程管理。</p>
<p>软件开发技术包括软件开发方法学、开发过程、开发工具和软件工程环境，其主题内容是软件开发方法学。软件开发方法学是根据不同的软件类型，按照不同的观点和原则对软件开发中应该遵循的策略、原则、步骤和必须产生的文档资料都做出规定，从而使得软件的开发能进入规范化和工程化的阶段。</p>
<p>软件工程管理包括软件管理学，软件工程经济学，软件心理学等内容。</p>
<p>软件工程管理是软件按工程化生产时的重要环节，它要求<br>按照预先制定的计划、进度和预算执行，以实现预期的经济效益和社会效益。有很多软件开发项目的失败，并不是由于软件开发技术方面的原因，它们的失败是由于管理不当造成的。</p>
<p>软件工程经济学是研究软件开发中成本的估算、成本效益分析的方法和技术。它用经济学基本原理研究软件工程开发中的经济效益问题。</p>
<p>软件心理学是软件工程领域具有挑战性的一个全新视角，它是从个体心理、人类行为、组织行为和企业文化等角度来研究软件管理和软件工程的。</p>
<p>所以，为了达到上述的软件工程目标，在软件开发过程中，必须遵循软件工程的基本原则。下面就说一下这些基本原则。</p>
<p>1.抽象。抽取事物最基本的特性和行为，而忽略非本质细节。</p>
<p>2.信息隐蔽。采用封装技术，把程序模块的实现细节隐藏起来，使得模块接口尽量简单。</p>
<p>3.模块化。之前反复强调过。</p>
<p>4.局部化。要求在一个物理模块内集中逻辑上相互关联的计算资源，保证模块之间具有松散的耦合关系，模块内部内聚性较强，这有助于控制解的复杂性。</p>
<p>5.确定性。软件开发中所有的概念的表达应该是确定的、无歧义的而且应该是规范的。</p>
<p>6.一致性。包括程序、数据和文档的整个软件系统的各个模块应该使用已知的概念、符号和术语；程序的内部和外部接口应该保持一致，系统规格说明与系统行为应保持一致。</p>
<p>7.完备性。软件不能丢失任何重要成分。</p>
<p>8.可验证性。开发大型软件需要对系统自上而下逐层分解。系统分解应该遵循容易检查、测评、评审的原则，以确保系统的正确性。</p>
<h2 id="软件开发工具与软件开发环境"><a href="#软件开发工具与软件开发环境" class="headerlink" title="软件开发工具与软件开发环境"></a>软件开发工具与软件开发环境</h2><p>早期的软件开发除了一般的程序设计语言之外，尚缺少工具的支持，致使编程工作量大，质量和进度难以保证，导致人们将很多精力和时间花费在程序的编制和调试上。软件开发工具的完善和发展可以促进软件开发以高速度和高质量发展。所谓“工欲善其事，必先利其器”，发展软件开发工具是很重要的。</p>
<p>软件开发环境或者说软件工程环境是全面支持软件开发全过程的软件工具集合。这些软件开发工具按照一定的方法或者模式组合起来，支持软件生命周期内的各个阶段和各项任务的完成。</p>
<p>计算机辅助软件工程（CASE）是当前软件开发环境中富有特色的研究工作和发展方向。CASE将各种软件工具、开发机器和一个存放开发过程信息的中心数据库组合起来，形成软件工程环境。CASE的成功产品将最大限度地降低软件开发的技术难度并且使全检的开发的质量得以保证。</p>
<p>结构化方法经过30多年的发展，已经成为系统、成熟的软件开发方法之一。结构化方法包括已经形成了配套的结构化分析方法、结构化设计方法和结构化设计方法，其核心和基础是结构化程序设计理论。</p>
<h2 id="需求分析与需求分析方法"><a href="#需求分析与需求分析方法" class="headerlink" title="需求分析与需求分析方法"></a>需求分析与需求分析方法</h2><p>先来明确什么是需求。需求是用户解决问题或达到目标所需的条件或权能；系统或系统部件要满足合同、标准、规范或其他正式规定文档所具有的条件或权能；由需求的定义可知，需求以及需求分析的内容包括提炼、分析和仔细审查已经收集到的需求；确保所有利益相关者都明白其含义并且能够找出其中的错误、遗漏或者其他不足的地方。从用户最初的非形式化需求到满足用户对软件产品要求的映射，对用户意图进行不断地提示和判断。</p>
<p>需求分析阶段的工作，可以概括为四个方面。</p>
<p>首先是需求获取，它涉及的关键问题有：对问题空间的理解，人与人之间的通信和不断变化的需求。在同用户的交流过程中，不断收集和积累用户的信息，并且通过认真理解用户的各项要求，澄清模糊的需求，排除不合理的需求，全面地提炼系统的功能性和非功能性需求。要特别注意的是，在需求获取过程中，容易产生诸如与用户交流存在障碍，相互误解，缺乏共同语言，忽视需求变化，混淆目标和需求等问题，这些问题都将直接影响到需求分析和系统后续开发的成败。</p>
<p>然后是需求分析。搞定了难缠的客户，程序员们就要分析一下这些需求到底应该怎么实现。这一步最终的结果就是给出系统的解决方案，或者说模型。</p>
<p>第三步是编写需求规格说明书。它为各方面人员之间的交流提供了方便。</p>
<p>最后就是需求评审。在需求分析的最后一步，对需求分析阶段的工作进行复审，验证需求文档的一致性，可行性，完整性和有效性。</p>
<p>常见的需求分析方法有结构化分析方法和面向对象的分析方法。</p>
<h2 id="结构化分析方法"><a href="#结构化分析方法" class="headerlink" title="结构化分析方法"></a>结构化分析方法</h2><p>结构化分析方法是结构化程序设计理论在软件需求分析阶段的运用。其目的是帮助弄清用户对软件的需求。</p>
<p>结构化分析方法的是指是着眼于数据流，自顶向下逐层分解，建立系统的处理流程，以数据流图和数据字典为主要工具，建立系统的逻辑模型。</p>
<p>它的步骤如下：</p>
<p>1.通过对用户的调查，以软件的需求为线索，获得当前系统的具体模型。</p>
<p>2.去掉具体模型中的非本质因素，抽象出逻辑模型。</p>
<p>3.根据计算机的特点分析当前系统与目标系统的差别，建立目标系统的逻辑模型。</p>
<p>4.完善目标系统并补充细节，写出目标系统的软件需求规格说明。</p>
<p>5.评审直到确认完全符合用户对软件的需求。</p>
<p>结构化分析的常用工具。其中第一个就是数据流图，简称DFD。它是描述数据处理过程的工具，是需求理解的逻辑模型的图形表示，它直接支持系统的功能建模。</p>
<p>这种图主要的图形元素有四个。</p>
<p><img src="https://i.loli.net/2018/08/18/5b7811a228066.png"><br>这个代表数据的源点和终点。它表示系统和环境的接口，属于系统之外的实体。</p>
<p><img src="https://i.loli.net/2018/08/18/5b7811a235f75.png"><br>这个代表数据流。沿着箭头的方向为传送数据的通道，一般在旁边标注数据流名。</p>
<p><img src="https://i.loli.net/2018/08/18/5b7811a236404.png"><br>这个代表存储文件。表示处理过程中存放的各种数据文件。</p>
<p><img src="https://i.loli.net/2018/08/18/5b7811a243005.png"><br>这个代表加工或者转换。输入数据经过这样的加工变换产生输出。</p>
<p>我们使用数据流图为系统建立逻辑模型。</p>
<p>第一步，由外向里，先画出系统的输入输出，然后再画出系统的内部。</p>
<p>第二步，自顶向下，顺序完成顶层，中间层，底层数据流图。</p>
<p>第三步，逐层分解。</p>
<p>数据流图的建立从顶层开始。顶层数据流图应该包含说有相关外部实体，以及外部实体与软件中间的数据流，其作用主要是描述软件的作用范围，对总体功能，输入，输出进行抽象描述，并反应软件和系统，环境的关系。对复杂系统的表达应采用控制复杂度策略，需要按照问题的层次结构逐步分解细化，使用分层的数据流图表达这种结构关系。</p>
<p>应注意以下几个地方：</p>
<p>1.对加工处理建立唯一、层次性的编号，每个加工处理通常要求既有输入又有输出。</p>
<p>2.数据存储之间不应该有数据流。</p>
<p>3.数据流图应该具有一致性。读和写应该是同时存在的。</p>
<p>4.相邻两层的DFD之间具有父子关系。子图代表对父图的详细描述，父图表示了子图间的接口。子图个数不大于父图中的处理个数。</p>
<p>第二个是数据字典，简称DD。</p>
<p>它是结构化分析方法的核心。数据字典是对所有与系统相关的数据元素的一个有组织的列表，以及精确的严格的定义，使得用户和系统分析员对于输入，输出，存储成分和中间计算结构有着共同的理解。数据字典把不同的需求文档和分析模型紧密地结合在一起，与各模型的图形表示配合，能清楚地表达大数据处理的要求。</p>
<p>数据字典的作用是对DFD中出现的被命名的图形元素做出确切解释。通常，数据字典包含的信息有：名称，别名，何处/如何使用，内容描述，补充信息等。</p>
<p>在数据字典中，通常要用到一些符号，释义如下：</p>
<p>“=”：表示等于，定义为，或者说，由某物构成。</p>
<p>“[…|…]”：表示或的关系，选项中用|分隔各项中的某一项</p>
<p>“+”：表示与，和</p>
<p>“n{ }ｍ”：表示重复，即花括号中的项要重复若干次，n和m表示下限和上限。</p>
<p>“(…)”：表示可选，括号中的项可以没有。</p>
<p>“* *”：表示注释。</p>
<p>“..”：表示连接符。</p>
<h2 id="软件需求规格说明书"><a href="#软件需求规格说明书" class="headerlink" title="软件需求规格说明书"></a>软件需求规格说明书</h2><p>它简称为SRS，是描述需求中的重要文档。它有很多作用。</p>
<p>1.便于用户和开发人员进行理解和交流。</p>
<p>2.反映出用户问题的结构，可以作为软件开发工作的基础和依据。</p>
<p>3.作为确认测试和验收的依据。</p>
<p>4.为成本估算和编制计划进度提供基础。</p>
<p>5.软件不断改进的基础。</p>
<p>软件需求规格说明书应该重点描述软件的目标，软件的功能需求，性能需求，外部接口，属性以及约束条件。该说明书是确保软件质量的有力措施，衡量软件需求规格说明书好坏的标准、标准的优先级以及标准的内涵是：</p>
<p>1.正确性。</p>
<p>2.无歧义性。</p>
<p>3.完整性。</p>
<p>4.可验证性。</p>
<p>5.一致性。</p>
<p>6.可理解性。</p>
<p>7.可修改性。</p>
<p>8.可追踪性。</p>
<p>软件需求规格说明是一份在软件生命周期中至关重要的文档，它在开发早期就为尚未诞生的软件系统建立了一个可见的逻辑模型，它可以保证开发工作的顺利进行，因而应该及时地建立并保证它的质量。说明书越精确，以后出现错误，混淆，反复的可能性越小。用户能看懂需求说明书，并且发现和指出其中的错误是保证软件系统质量的关键，因而需求说明必须简单易懂，尽量少包含术语。</p>
<h2 id="软件设计的基本概念"><a href="#软件设计的基本概念" class="headerlink" title="软件设计的基本概念"></a>软件设计的基本概念</h2><p>软件设计是软件工程的重要阶段，是一个把软件需求转换为软件表示的过程。软件设计是确定系统的物理模型。</p>
<p>从技术观点来看，包括软件结构设计，数据设计，接口设计，过程设计。其中，结构设计是定义软件系统各个主要部件之间的关系；数据设计是将分析时创建的模型转化为数据结构的定义；接口设计是描述软件内部、软件和协作系统之间以及软件与人之间如何通信；过程设计则是把系统结构部件转换成软件的过程性描述。软件设计分成概要设计和详细设计。</p>
<p>软件设计的一般过程是：软件设计是一个迭代的过程；先进行高层次的结构设计，再进行低层次的过程设计；穿插进行数据设计和接口设计。</p>
<p>软件设计过程中应该遵循软件工程的基本原理。该基本原理可以概括为以下几点：</p>
<p>1.抽象。抽象是把事物本质的共同特性提取出来而暂时忽略它们的细节以及它们之间的差异。软件设计中考虑模块化解决方案时，可以定义多个抽象级别。抽象的层次从软件的总体设计到详细设计到编码逐层降低。软件工程的每一步都是对上一层抽象的一次精化。</p>
<p>2.逐步求精和模块化。这个之前说过，化繁为简，分而治之。</p>
<p>3.信息隐蔽和局部化。所涉及的模块其包含的信息对于不需要这些信息的模块是不可以访问的。局部化与信息隐蔽概念密切相关。它是指把一些关系密切的软件元素物理地放得彼此靠近。局部化有助于实现信息隐蔽。</p>
<p>4.模块独立性。它的概念时抽象、模块化、信息隐蔽和局部化的直接结果。模块的独立性是指软件模块的编写和修改应使得其具有独立供暖，且与其他模块的关联尽可能少。换句话讲，设计软件结构时，应使得每一个模块仅完成一个相对独立的子功能。</p>
<p>与结构化需求分析方法相对应的事结构化设计方法。它的基本思想是将软件设计成由相对独立、单一功能的模块组成的结构。</p>
<h2 id="软件概要设计"><a href="#软件概要设计" class="headerlink" title="软件概要设计"></a>软件概要设计</h2><p>1.设计软件系统结构。</p>
<p>2.数据结构以及数据库设计。</p>
<p>3.编写概要设计文档。</p>
<p>4.概要设计文档评审。</p>
<p>常用的软件结构设计工具是结构图，简称SC，也称程序结构图。它反映了整个系统的功能实现以及模块与模块之间的联系与通信。</p>
<p>经常使用的四种模块类型：传入模块，传出模块，变换模块和协调模块。</p>
<p>这里先解释一些术语：</p>
<p>深度：表示控制的层数。</p>
<p>上级模块、从属模块：上、下两层模块，上调用下，称上为上级模块，下为从属模块。</p>
<p>宽度：整体控制跨度的表示。跨度是指最大模块数的层。</p>
<p>扇入：调用一个给定模块的模块个数。</p>
<p>扇出：一个模块直接调用的其他模块数。</p>
<p>原子模块：树中位于叶子节点的模块。</p>
<p>这四种模块类型是这样解释的：</p>
<p>传入模块：从下属模块取得数据，经过处理再将其传送给上级模块。</p>
<p>传出模块：和传入模块相反。</p>
<p>变换模块：从上级模块取得数据经过特定处理，转换成其他形式再传回上级模块。</p>
<p>协调模块：对所有下属模块进行协调和管理的模块。</p>
<h2 id="面向数据流的结构化设计方法"><a href="#面向数据流的结构化设计方法" class="headerlink" title="面向数据流的结构化设计方法"></a>面向数据流的结构化设计方法</h2><p>典型的数据流类型有两种：变换型和事务型。变换型是指信息沿着输入通路进入系统，同时由外部形式变换成内部形式。它大致分为三步，取得数据，变换数据，输出数据。还有一种叫做事务型。在很多软件应用中，存在某种作业数据流，它可以引发一个或多个处理，这些处理能够完成该作业要求的功能，这种数据流就叫做事务。它的特点是接收一项事务，根据事务处理的特点与性质，选择分派一个适当的处理单元，然后给出结果。</p>
<p>那么，面向数据流的设计方法实施要点是什么呢？</p>
<p>1.分析，确认是事务型还是变换型。</p>
<p>2.说明数据流的边界。</p>
<p>3.把数据流图映射为程序结构。</p>
<p>4.根据设计准则对产生的结构进行细化和求精。</p>
<h2 id="常见的过程设计工具"><a href="#常见的过程设计工具" class="headerlink" title="常见的过程设计工具"></a>常见的过程设计工具</h2><p>图形工具有程序流程图，N-S图，PAD图，HIPO图。表格工具有判定表。语言工具有PDL（伪码）。</p>
<p>程序流程图就是程序框图。这玩意高中学过。它虽然简单易学，但是若程序员不受任何约束，随意转移控制，会破坏结构化设计的原则，并且它不太适合表示数据结构。</p>
<p>N-S图其实是用方框图来代替传统的程序流程图。对于一张N-<br>S图来说，每个构建都具有明确的功能域。控制转移必须遵守结构化设计要求。它易于确定局部数据和全局数据的作用域，易于表达嵌套关系和模块的程序结构。</p>
<p>PAD图是问题分析图的英文缩写。PAD图结构清晰，结构化程度高，易于阅读。对于这样的图，最左端的纵线是程序的主干线，对应程序的第一层结构；每增加一层PAD图向右扩展一条纵线，所以纵线的条数就是程序层次数。程序执行时，从PAD图最左边的纵线上端结点开始，自上而下、自左向右依次执行，程序中止于最左干线。</p>
<p>PDL的中文全称是过程设计语言。它也被称为结构化的英语和伪码。它是一种混合语言。PDL可以由编程语言转换得到，也可以是专门为过程描述而设计的。但应该具备以下特征：由为结构化构成元素、数据说明和模块化特征提供的关键词语法；处理部分的描述采用自然语言语法；可以说明简单和复杂的数据结构；支持各种接口的描述的子程序定义和调用技术。</p>
<h2 id="软件测试的目的、定义与准则"><a href="#软件测试的目的、定义与准则" class="headerlink" title="软件测试的目的、定义与准则"></a>软件测试的目的、定义与准则</h2><p>通过对软件产品进行必要的测试是非常重要的一个环节。软件测试也是在软件投入运行前对软件需求、设计、编码的最后审核。软件测试的投入，包括人员和资金的投入是巨大的。软件测试是保证软件质量的重要手段，其主要过程涵盖了整个软件生命期的过程.</p>
<p>在1990年，IEEE610.12标准中给出了软件测试的定义。在规定条件下运行系统或构件的过程：在此过程中观察和记录结果，并对系统或构件的某些方面给出评价。检测现有状况和所需状况的不同（也就是找bug），并评估软件项目的特性。</p>
<p>软件测试是一个过程，它是一项验证和评估的活动，其目的是基于满足规定的需求来保证软件的质量。测试要以查找错误为中心，而不是为了演示软件的正确功能。</p>
<p>软件测试人员需要充分理解和运用软件测试的一些基本准则：</p>
<p>1.所有测试都应追溯到需求。最严重的错误不外乎是导致程序无法满足用户需求的错误。</p>
<p>2.严格执行测试计划，排除测试的随意性。测试计划应该包括：所测软件的功能、输入和输出、测试内容、各项测试的目的和进度安排、测试资料、测试工具、测试用例的选择、资源要求、测试的控制方式和过程等。</p>
<p>3.充分注意测试中的群集现象。经验表明，程序中存在错误的概率与该程序中已发现的错误数成正比。这一现象说明，为了提高测试效率，测试人员应该集中对付那些错误群集的程序。</p>
<p>4.程序员应该避免检查自己的程序。为了达到好的测试效果，应该由独立的第三方来构造测试。因为从心理学的角度来讲，程序人员或设计方在测试自己的程序时，要采取客观的态度是程度不同地存在障碍的。</p>
<p>5.穷举测试不可能。所谓穷举测试就是把程序所有可能的执行路径都进行检查的测试。但是，即使规模较小的程序，其路径排列数也是相当大的。实际测试过程中根本不可能去把所有路径都测试一遍。这说明，测试只能证明程序有错误，不能证明程序没有错误。</p>
<p>6.妥善保存测试计划、测试用例、出错统计和最终分析报告，为维护提供方便。</p>
<h2 id="软件测试方法与技术综述"><a href="#软件测试方法与技术综述" class="headerlink" title="软件测试方法与技术综述"></a>软件测试方法与技术综述</h2><p>若从是否需要执行被测软件的角度，可以分为静态测试与动态测试。若按照功能划分，可以分为白盒测试和黑盒测试方法。</p>
<p>1.静态测试与动态测试</p>
<p>静态测试包括代码检查，静态结构分析，代码速度质量等。静态测试可以人工进行，充分发挥人的思维优势，也可以借助工具。经验表明，使用人工测试能够有效地发现30%到70%的逻辑设计和编码错误。代码检查主要检查代码设计的一致性，包括代码的逻辑表达的正确性，代码结构的合理性等方面。这项工作可以发现违背程序编写标准的问题，程序中不安全、不明确和模糊的部分，找出程序中不可移植的部分、违背程序编程风格的问题。代码检查包括代码审查，代码走查，桌面检查，静态分析等具体方式。</p>
<p>代码审查指的是小组集体阅读、讨论、检查代码。代码走查是执行代码的过程中进行检查，但是这个执行过程是在脑内进行。桌面检查是指的程序员自己检查自己编写的程序。程序员在程序过编译之后，绝对源代码进行分析，检验，并且补充相关文档，目的是发现错误。静态分析是指的对代码的机械性，程式化的特性分析方法。包括控制流分析，数据流分析，接口分析和表达式分析。</p>
<p>动态测试是基于计算机的测试。与静态测试不同，静态测试主要通过人工进行，动态测试是根据软件开发各个阶段的规格说明和程序的内部结构而精心设计一批测试用例，并利用这些测试用例去运行程序，以发现程序错误的过程。</p>
<p>2.白盒测试方法与测试用例设计</p>
<p>白盒测试方法也成结构测试或逻辑驱动测试。白盒测试是在程序内部进行，主要用于完成软件内部操作的验证。它要求保证所测模块中每一独立路径至少执行一次；保证所测模块所有判断的每一分支至少执行一次；保证所测模块每一循环都在边界条件和一般条件下至少各执行一次；验证所有内部数据结构的有效性。可以看出，它是一种穷举路径测试。但是即使每条路径都测试了，可能还是会有错误。</p>
<p>有三种错误是白盒测试检测不出来的。首先，违反设计规范的错误无法检测；其次，遗漏路径的错误无法检测；最后，与数据相关的错误无法检测。</p>
<p>白盒测试的主要方法有逻辑覆盖测试和基本路径测试。</p>
<p>3.黑盒测试方法与测试用例设计</p>
<p>黑盒测试方法也称功能测试或数据驱动测试。黑盒测试是对软件已经实现的功能是否满足需求进行测试和验证。黑盒测试完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求和功能规格说明。黑盒测试主要诊断功能不对或遗漏、界面错误、数据结构或外部数据库访问错误、性能错误、初始化和终止条件（边界）错。</p>
<p>黑盒测试的主要方法有等价划分法、边界值分析法、错误推测法、因果图法。</p>
<p>实际上，没有一种用例测试及方法能够适应所有的解决方案，应该根据实际情况进行选择使用或者混合使用。应该在测试成本和测试效果之间做一个合理的折中。</p>
<h2 id="软件测试的策略"><a href="#软件测试的策略" class="headerlink" title="软件测试的策略"></a>软件测试的策略</h2><p>软件测试一般是按照4个步骤进行，即单元测试、集成测试、确认测试和系统测试。</p>
<p>1.单元测试</p>
<p>单元测试的目的是发现各模块内部可能存在的错误，它的依据是详细设计说明书和源程序。单元测试的技术可以采用静态分析和动态测试。对动态测试来说，用白盒测试比较多，辅之以黑盒测试。</p>
<p>它主要针对下面的五个基本特性进行：模块接口测试、局部数据结构测试、重要的执行路径的检查、出错处理测试、影响以上各点以及其他相关点的边界条件测试。</p>
<p>2.集成测试</p>
<p>集成测试是测试和组装软件的过程。它是在把模块按照设计要求组装起；来的同时进行测试，主要目的是发现与接口有关的错误。集成测试的依据是概要设计说明书。</p>
<p>集成测试所涉及的内容包括：软件单元的接口测试、全局数据和结构测试、边界条件和非法输入的测试等。</p>
<p>集成测试时将模块组装成程序通常采用两种方式:非增量方式组装和增量方式组装。</p>
<p>3.确认测试</p>
<p>确认测试的任务是验证软件的功能和性能以及其他特性是否满足需求规格说明中确定的需求，以及软件配置是否完全、正确。</p>
<p>4.系统测试</p>
<p>系统测试是将通过测试确认的软件，作为整个基于计算机系统的一个元素，与计算机硬件、外设、支持软件、数据和人员等其他元素组合在一起，在实际运行环境下对计算机系统进行一系列的集成测试和确认测试。</p>
<p>系统测试的具体实施一般包括：功能测试、性能测试、操作测试、配置测试、外部接口测试、安全测试等。</p>
]]></content>
      <categories>
        <category>软件工程基础</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>控制台小游戏集锦</title>
    <url>/2018/08/06/c-game/</url>
    <content><![CDATA[<p>这里收集了我初次接触C语言游戏开发时的学习笔记，该部分内容是曾在2018年发布的。</p>
<p>当前博客显示的发布时间非真实时间，而是这些内容在当时发布时的最后发布时间。</p>
<p><img src="https://i.loli.net/2018/08/10/5b6d26f421718.png"></p>
<a id="more"></a>

<h2 id="实现一个简易的反弹球游戏"><a href="#实现一个简易的反弹球游戏" class="headerlink" title="实现一个简易的反弹球游戏"></a>实现一个简易的反弹球游戏</h2><h3 id="屏幕坐标"><a href="#屏幕坐标" class="headerlink" title="屏幕坐标"></a>屏幕坐标</h3><p><img src="https://i.loli.net/2018/08/08/5b6ad9113c956.png"></p>
<p>我们要让一个小球在一个给定的平面上弹跳，第一步是什么？</p>
<p>当然是要创造一个平面啊……在控制台上，这个平面的“建立”就可以由一个二重for循环来完成。两个循环变量i和j，走到哪个地方，这里的“坐标”就可以由相应的i，j的值来代替。看一下这张图片，相信您就能大致的明白小球的坐标应该如何表示了。</p>
<p>可能有人会问，我们要坐标干什么？其实，小球在平面上的移动，本质上是小球坐标的改变，我们只需要改变小球的坐标，就可以改变小球的位置。</p>
<p>这个所谓的“坐标系”，严格来说并不可以称之为坐标系，只能说它可以方便我们描述物体在屏幕上的位置。</p>
<p>思考：坐标原点在哪？</p>
<h3 id="打印一个静止的小球"><a href="#打印一个静止的小球" class="headerlink" title="打印一个静止的小球"></a>打印一个静止的小球</h3><p>我们使用printf()函数打印小球，利用for循环找到小球的位置。</p>
<p>下面给出一个简单的代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">15</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> y = <span class="number">20</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++)  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; y; j++)  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;O\n&quot;</span>);  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>把它改成一个二重循环也可以，但是要通过if else来换行，不如这样实现的简洁一些。执行程序，发现在一个大黑框中出现了一个静止的小球（字母O），就算大功告成。更改x和y的值，就可以改变小球的位置。</p>
<p>当然，如果使用二维数组会让更简单。想一想，怎么做？</p>
<h3 id="让小球动起来"><a href="#让小球动起来" class="headerlink" title="让小球动起来"></a>让小球动起来</h3><p>我们已经有了一个静止的小球，现在我们要尝试让这个球上下弹跳。</p>
<p>（暂时不考虑落体和弹跳的物理规律）<br>先来考虑一下，要让小球一直不停地跳，要怎么办？使用for循环只能显示小球静止，那要让小球动起来，要怎么办？</p>
<p>一个显然的想法是一直不停地使用for循环。可以在打印的for循环之外再加一层管理“时间”的循环。可是那样的程序小球也只能跳动一定时间。</p>
<p>想让小球一直跳动，外面得加一层“死循环”——while(1)。</p>
<p>与此同时，需要注意的是，使用for循环打印换行符或者空格后，那些位置已经有字符存在了，如果直接去打印下一帧的小球肯定是不行的，此时我们需要一个清除屏幕的操作，只需要把以前打印的符号全部删除，然后重新画就可以了。</p>
<p>放心，电脑运行速度很快。这个操作听起来麻烦，但是电脑却可以在几乎一瞬间完成。可以使用位于stdlib.h里的system函数来清屏，只需调用system(“cls”);即可。</p>
<p>好，下面解决最主要的问题，处理下落，上升和碰撞。</p>
<p>我们先考虑单独处理下落。由坐标变化可以得知，下落的本质是x坐标的增加（想一想，为什么）。那么在外层管理“时间”的循环只需要写成管理x的循环就可以啦，每次循环x都要增加，小球看起来就像是“下落的”。</p>
<p>hint：只需要将上一份示例代码的打印部分外面套一层x递增的循环，然后在里面调用一下清屏函数就可以了。</p>
<p>下面，我们要让小球在这个平面的一条直线上来回运动。既然考虑到碰撞，碰撞所需要的边界就是我们需要考虑的问题。需要设置一个“地板”和一个“天花板”，也就是下界和上界。这一点很好实现，设置好常量即可。</p>
<p>再来想下一个问题，如何处理碰撞？我们不考虑现实的物理规律，只需要知道，当球碰到地板或者天花板时，速度的方向应该和原来的方向相反，大小是不需要改变的。（实际碰撞并非如此，我们只是简化了一下）</p>
<p>这里牵扯到了速度，我们设速度为v就好。  </p>
<p>那么，坐标的变化，就可以由一个公式来表达。  </p>
<p>设原来的x坐标是x __ old，该时刻变化后的坐标是x __ new，那么有：  </p>
<p><em>x __ new = x __ old + v</em></p>
<p>可能有人会说，这个公式是错误的。为什么？你怎么能直接把坐标和速度相加呢？实际上，这里的“速度”是已经“乘”上了“时间”的。换句话说，这里的v虽然我们设成了“速度”，但它实际上表示的是坐标的改变量，也算作是坐标。这个公式是在死循环下使用的，也就是说每执行一次循环都会使用一次这个公式，这样x就可以不断改变了。</p>
<p>但是，v并不是保持不变的。当小球触碰天花板或地板时，根据我们简化的碰撞规律，速度要变为反向。那么如何体现速度为反向呢？学过高中物理的同学应该知道，速度是一个矢量，它既有大小又有方向。表示速度时所带的正负号不参与比较大小，只代表速度的方向是与给定的正方向相同还是相反。所以，要让速度反向，取一个相反数就好啦。</p>
<p>下面给出一个简单的代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Top 20  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bottom 0  </span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;										<span class="comment">//这里就不能加const了  </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> y = <span class="number">10</span>;  </span><br><span class="line"><span class="keyword">int</span> v = <span class="number">1</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">		x = x + v;  </span><br><span class="line">		system(<span class="string">&quot;cls&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++)  </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; y; j++)  </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;O\n&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">		<span class="keyword">if</span> (x == Top || x == Bottom)  </span><br><span class="line">			v = -v;  </span><br><span class="line">  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行该程序，会发现有一个小球以超级快的速度上下运动。如果想让它慢下来，可以使用Sleep()函数。这个函数可以让程序在执行至某位置时暂停一定时间，该时间由函数的参数决定，参数的单位是毫秒。这个函数在windows.h里，使用函数时不要忘了#include &lt;windows.h&gt;。</p>
<h3 id="斜向弹跳"><a href="#斜向弹跳" class="headerlink" title="斜向弹跳"></a>斜向弹跳</h3><p>其实和在一条直线上来回弹跳是一样的，把上下的速度设为vx，左右的速度设为vy就可以。实现方式和上文所述完全相同。设定边界的时候除了Top和Bottom外还要加上左边和右边的“墙”——Left和Right。</p>
<h3 id="绘制边框和添加撞击音效"><a href="#绘制边框和添加撞击音效" class="headerlink" title="绘制边框和添加撞击音效"></a>绘制边框和添加撞击音效</h3><p>绘制边框在打印换行时一并完成。此时打印部分需要做少许修改。</p>
<p>我们不能只打印到球为止，而是应该要把整个画布打印出来。所以此时需要二重循环+if判断再输出的结构。</p>
<p>我们来看一下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Top 20  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bottom 0  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Left 0  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Right 30  </span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;									  </span><br><span class="line"><span class="keyword">int</span> y = <span class="number">10</span>;  </span><br><span class="line"><span class="keyword">int</span> vx = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">int</span> vy = <span class="number">1</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">		x = x + vx;  </span><br><span class="line">		y = y + vy;  </span><br><span class="line">		system(<span class="string">&quot;cls&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = Bottom; i &lt; Top; i++) &#123;  </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = Left; j &lt; Right; j++) &#123;  </span><br><span class="line">				<span class="keyword">if</span> ((i == Bottom) || (i == Top - <span class="number">1</span>))  </span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);  </span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> ((j == Left) || (j == Right - <span class="number">1</span>))  </span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);  </span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> ((i == x) &amp;&amp; (j == y))  </span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;O&quot;</span>);  </span><br><span class="line">				<span class="keyword">else</span>  </span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);				  </span><br><span class="line">                    <span class="comment">//没有东西的地方一定要打印空格,不能什么也不做,这点一定注意  </span></span><br><span class="line">			&#125;  </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">		&#125;  </span><br><span class="line">  </span><br><span class="line">		<span class="keyword">if</span> (x == Top - <span class="number">1</span> || x == Bottom + <span class="number">1</span>)  </span><br><span class="line">			vx = -vx;  </span><br><span class="line">		<span class="keyword">if</span> (y == Left + <span class="number">1</span> || y == Right - <span class="number">1</span>)  </span><br><span class="line">			vy = -vy;  </span><br><span class="line">  </span><br><span class="line">		Sleep(<span class="number">100</span>);  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>可以看出，在打印部分使用了if<br>else结构来判断到某个位置应该打印什么。有个比较细节的地方需要说一下。在打印后的碰撞检测里，我们检测的边界不再是Top、Bottom、Left、Right，而是Top + 1、Bottom + 1、Left + 1、Right -1，这是为什么呢？很简单，本来要检测的边界变成了边框，小球的活动范围就缩小了一圈，不然会出现小球进墙的bug。</p>
<p>碰撞音效？其实就是printf(“\a”)啦。在碰撞检测成功后，变换速度的同时加一句这个就可以啦。这其实是系统的提示声，如果想播放其他声音……emmmm后续会说到的。</p>
<h2 id="实现一个简易的打砖块游戏"><a href="#实现一个简易的打砖块游戏" class="headerlink" title="实现一个简易的打砖块游戏"></a>实现一个简易的打砖块游戏</h2><h3 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h3><p>接着昨天的反弹球继续写。运用昨天的反弹球可以写出例如flappy bird，打砖块等游戏的核心部分。</p>
<p>为了方便我们的开发，程序中的各个部分通常要用函数进行封装，这样会使各种功能模块化，方便我们日后的调试和维护。</p>
<p>这里给出一个书上的最初的简易游戏框架。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">	startup();  </span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;  </span><br><span class="line">		show();  </span><br><span class="line">		updateWithInput();  </span><br><span class="line">		updateWithoutInput();  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>解释一下那几个函数所需要包含的功能。</p>
<p>startup：游戏数据初始化</p>
<p>show：显示游戏画面</p>
<p>updateWithInput：和用户输入有关的游戏更新</p>
<p>updateWithoutInput：和用户输入无关的游戏更新</p>
<p>以后的程序我尽量都会按照这样的结构进行代码编写，这只是一个最基础的框架，随着游戏变得更复杂，游戏所需要的函数就会变得更多。</p>
<p>好，那么让我们把昨天的框架弹球程序按照这个结构重构一下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Top 20  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bottom 0  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Left 0  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Right 30  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x,y,vx,vy;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	x = <span class="number">5</span>;  </span><br><span class="line">	y = <span class="number">10</span>;  </span><br><span class="line">	vx = <span class="number">1</span>;  </span><br><span class="line">	vy = <span class="number">1</span>;  </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Bottom; i &lt; Top; i++) &#123;  </span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> j = Left; j &lt; Right; j++) &#123;  </span><br><span class="line">    		<span class="keyword">if</span> ((i == Bottom) || (i == Top - <span class="number">1</span>))  </span><br><span class="line">    			<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);  </span><br><span class="line">    		<span class="keyword">else</span> <span class="keyword">if</span> ((j == Left) || (j == Right - <span class="number">1</span>))  </span><br><span class="line">    			<span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);  </span><br><span class="line">    		<span class="keyword">else</span> <span class="keyword">if</span> ((i == x) &amp;&amp; (j == y))  </span><br><span class="line">   				<span class="built_in">printf</span>(<span class="string">&quot;O&quot;</span>);  </span><br><span class="line">   		 	<span class="keyword">else</span>  </span><br><span class="line">    			<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);			  </span><br><span class="line">    	&#125;  </span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateWithInput</span><span class="params">()</span> </span>&#123;   <span class="comment">//该程序不需要用户进行输入，所以该函数是空的，但是不可以删去   </span></span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateWithoutInput</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">x = x + vx;  </span><br><span class="line">y = y + vy;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x == Top - <span class="number">1</span> || x == Bottom + <span class="number">1</span>)  </span><br><span class="line">vx = -vx;  </span><br><span class="line"><span class="keyword">if</span> (y == Left + <span class="number">1</span> || y == Right - <span class="number">1</span>)  </span><br><span class="line">vy = -vy;  </span><br><span class="line"></span><br><span class="line">Sleep(<span class="number">100</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	startup();  </span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">		show();  </span><br><span class="line">		updateWithInput();  </span><br><span class="line">		updateWithoutInput();  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>重构完成。不过该程序在显示方面有一个很明显的缺陷：闪屏现象严重，并且伴随光标胡乱跳动。这是由于system(“cls”)的性能较差导致的。现在来介绍一个新的清屏函数。这里面牵扯到一个叫句柄的东西，不理解的话只需要记住这个函数能干什么就好。下面给出实现方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gotoxy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  </span><br><span class="line">	HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);  </span><br><span class="line">	COORD pos;  </span><br><span class="line">	pos.X = x;  </span><br><span class="line">	pos.Y = y;  </span><br><span class="line">	SetConsoleCursorPosition(handle, pos);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>然后把system(“cls”)替换为gotoxy(0,0)就可以了。</p>
<p>下面我们来解决光标的问题。可以自定义一个HideCursor()函数进行解决。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HideCursor</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	CONSOLE_CURSOR_INFO cursor_info = &#123; <span class="number">1</span>,<span class="number">0</span> &#125;;  </span><br><span class="line">	SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这个函数只需要调用一次，放在while(1)之前就可以。</p>
<h3 id="添加挡板"><a href="#添加挡板" class="headerlink" title="添加挡板"></a>添加挡板</h3><p>既然是打砖块游戏，接砖块的挡板自然是必不可少的。对于一个挡板，我们需要两个参数（其实是三个）来进行决定。一个是挡板的中心坐标，另一个是挡板左右延伸的长度。此外，还需要两个辅助变量来记录挡板左右端点的位置，方便我们进行打印和后续的接球判定。</p>
<p>（实际上，以左端起始，再加一个长度参数也可以，只要能正确表示出一个挡板就可以）</p>
<p>我们在上一篇文章的代码基础上修改三个函数。此外，再添加一些全局变量。</p>
<p>全局变量部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ball_x, ball_y;  </span><br><span class="line"><span class="keyword">int</span> ball_vx, ball_vy;  </span><br><span class="line"><span class="keyword">int</span> pos_x, pos_y;  </span><br><span class="line"><span class="keyword">int</span> ridus;  </span><br><span class="line"><span class="keyword">int</span> pos_left, pos_right;  </span><br></pre></td></tr></table></figure>

<p>初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	ball_x = Top - <span class="number">3</span>;  </span><br><span class="line">	ball_y = Right / <span class="number">2</span>;  </span><br><span class="line">	ball_vx = <span class="number">1</span>;  </span><br><span class="line">	ball_vy = <span class="number">1</span>;  </span><br><span class="line">	ridus = <span class="number">5</span>;  </span><br><span class="line">	pos_x = Top - <span class="number">2</span>;  </span><br><span class="line">	pos_y = Right / <span class="number">2</span>;  </span><br><span class="line">	pos_left = pos_y - ridus;  </span><br><span class="line">	pos_right = pos_y + ridus;  </span><br><span class="line">  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>显示函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	gotoxy(<span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = Bottom; i &lt; Top; i++) &#123;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = Left; j &lt; Right; j++) &#123;  </span><br><span class="line">			<span class="keyword">if</span> ((i == Bottom) || (i == Top - <span class="number">1</span>))  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((j == Left) || (j == Right - <span class="number">1</span>))  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((i == ball_x) &amp;&amp; (j == ball_y))  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;O&quot;</span>);  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((i == Top - <span class="number">2</span>) &amp;&amp; (j &gt;= pos_left) &amp;&amp; (j &lt;= pos_right))  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;=&quot;</span>);  </span><br><span class="line">			<span class="keyword">else</span>  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);			  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">	&#125;  </span><br><span class="line">	  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这里要注意，我们的游戏界面存在一个方框，它的上边界是0，由于高度是Top，所以下边界是Top-1，左右边界同理。所以想要把挡板放在离下边界最近的地方的话，就要放在Top-2了。小球的位置倒是可以随意，别放在边界上就好。</p>
<p>运行程序，大抵如此：  </p>
<p><img src="https://i.loli.net/2018/08/08/5b6ad91138892.png"></p>
<p>可是这个时候挡板是不能运动的，而且小球碰到挡板时会直接把挡板“吃掉”，接下来我们要怎么办呢？</p>
<h3 id="让挡板动起来"><a href="#让挡板动起来" class="headerlink" title="让挡板动起来"></a>让挡板动起来</h3><p>要让挡板按照玩家的意愿移动，需要从键盘获取录入信息。</p>
<p>从键盘读取数据？难道要用scanf吗？</p>
<p>实际上，使用scanf输入字符后要按一下回车才可以继续进行，但这显然不是我们想要的。这里我们使用conio.h里面的getch()函数获取输入。getch不需要任何参数，用法和getchar一样的（我相信您会用getchar）。</p>
<p>再来介绍一个函数，它叫kbhit，也是在conio.h里面的一个函数，它可以监听键盘输入，如果有任何键盘输入就会返回1，否则返回0。</p>
<p>这里我用a控制左移，d控制右移。如果想用上下左右来控制也是可以的，这里给出方向键对应的ascii码：</p>
<p>左键：37 上键：38 右键：39 下键：40</p>
<p>判断键盘输入其实很简单，使用if或者switch就可以，当输入为什么按键时要向哪里移动，更新坐标的值即可。</p>
<p>PS：笔者使用Visual Studio 2017 Community最初编译此程序时出现了编译错误的问题，后发现高版本的Visual<br>Studio直接使用getch和kbhit函数会出现编译错误，要让编译通过应该在函数名前加一下划线，具体原因未知。</p>
<p>下面给出修改后的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateWithInput</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">	<span class="keyword">char</span> input;  </span><br><span class="line">	<span class="keyword">if</span> (_kbhit()) &#123;  </span><br><span class="line">		input = _getch();  </span><br><span class="line">		<span class="keyword">if</span> (input == <span class="string">&#x27;a&#x27;</span>) &#123;  </span><br><span class="line">			pos_y--;  </span><br><span class="line">			pos_left = pos_y - ridus;  </span><br><span class="line">			pos_right = pos_y + ridus;  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">if</span> (input == <span class="string">&#x27;d&#x27;</span>) &#123;  </span><br><span class="line">			pos_y++;  </span><br><span class="line">			pos_left = pos_y - ridus;  </span><br><span class="line">			pos_right = pos_y + ridus;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>思路是，先检测有无输入，有则获取输入并判断。为什么不直接用getch呢？如果直接用getch，当程序跑到getch那一行时会一直等待键盘输入，这样会导致一个不按键不进行游戏的bug。更新挡板坐标位置的操作并不难理解，由于打砖块游戏通常不允许挡板上下移动，所以只会有y坐标发生变化。中心坐标发生变化时，其左端点和右端点的坐标也要随之变化。</p>
<h3 id="判定接球和失球"><a href="#判定接球和失球" class="headerlink" title="判定接球和失球"></a>判定接球和失球</h3><p>当小球到达游戏画面底部时，应要做一些判断。如果小球即将到达与挡板平齐的位置时，我们要检测小球的y坐标是否在左右端点覆盖的范围之内。如果是则按照反弹规律反弹小球，否则游戏失败。</p>
<p>由于小球的反弹与用户输入没有联系，所以我们修改updateWithoutInput函数。只需要在撞墙反弹前判断是否撞上了挡板就可以。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateWithoutInput</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	  </span><br><span class="line">	<span class="keyword">if</span> (ball_x == Top - <span class="number">3</span>) &#123;  </span><br><span class="line">		<span class="keyword">if</span> ((ball_y &gt;= pos_left) &amp;&amp; (ball_y &lt;= pos_right)) &#123;  </span><br><span class="line">			  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">else</span> &#123;  </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;GAME OVER\n&quot;</span>);  </span><br><span class="line">			system(<span class="string">&quot;pause&quot;</span>);  </span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	  </span><br><span class="line">	ball_x = ball_x + ball_vx;  </span><br><span class="line">	ball_y = ball_y + ball_vy;  </span><br><span class="line">		  </span><br><span class="line">	<span class="keyword">if</span> (ball_x == Top - <span class="number">3</span> || ball_x == Bottom + <span class="number">1</span>)  </span><br><span class="line">		ball_vx = -ball_vx;  </span><br><span class="line">	<span class="keyword">if</span> (ball_y == Left + <span class="number">1</span> || ball_y == Right - <span class="number">1</span>)  </span><br><span class="line">		ball_vy = -ball_vy;  </span><br><span class="line">	  </span><br><span class="line">	Sleep(<span class="number">100</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>目前有一个问题不能解决，那就是“底线”到底在哪。如果把底线放在与挡板相同一行，那么小球会落到边框上才会宣告失败，这和我们的想法是一样的，但是小球打在挡板上时会先进入到挡板里面再反弹，但如果把底线放在挡板上一行，挡板没有接到小球时小球会悬停在半空中宣告失败，这也是不太合适的。但是这个问题等使用了easyX就可以解决。</p>
<p>代码当中有一个if后面执行的语句我留了空，那里可以写一些当小球撞到挡板上可以做的事情，比如记分，播放音效等。</p>
<h3 id="添加得分记录器和一个砖块"><a href="#添加得分记录器和一个砖块" class="headerlink" title="添加得分记录器和一个砖块"></a>添加得分记录器和一个砖块</h3><p>得分记录很好实现，设立一个变量score初始化为0，然后在show函数的最后添加一行printf输出这个变量就好。</p>
<p>那么怎样判断是否得分呢？既然是打砖块游戏，那自然是习惯上认作是打掉砖块得分。所以我们来添加一个砖块，没错，先只加一个。</p>
<p>在updateWithoutInput函数里，添加这样的一块代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((ball_x == block_x) &amp;&amp; (ball_y == block_y)) &#123;  </span><br><span class="line">	score++;  </span><br><span class="line">	block_x = rand() % <span class="number">5</span> + <span class="number">1</span>;  </span><br><span class="line">	block_y = (rand() % (Right - <span class="number">1</span>)) + <span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>我们让这个砖块被敲掉后在一个限定的范围内重新生成一个砖块，同时加1分。在使用前我先初始化了随机数种子，使用了srand((unsignedint)time(NULL));即以时间为种子初始化随机数。srand函数接收一个无符号整型的参数，而time函数的返回值是time_t类型，如果不进行类型转换会产生一个warning：</p>
<p>warning C4244: “参数”: 从“time_t”转换到“unsigned int”，可能丢失数据</p>
<p>好了，现在一个最基础的打砖块游戏就做好了。</p>
<p>下一步我们要添加大量砖块，同时要用到二维数组作为画布，这样的画布从某种方面上讲会更方便。</p>
<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>我们用一个二维数组canvas存储需要打印到屏幕上的所有元素。该数组存储几个特定的值，比如0输出空格，1输出小球，在后续添加挡板，砖块时可以用2，3来表示。</p>
<p>ps:我只是说用这个数字来进行表示，并不是要直接打印0,1,2到屏幕上。</p>
<p>（偷个懒，用了以前的代码，该代码只会显示一半的边框，你可以尝试在细节处进行修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	gotoxy(<span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High; i++) &#123;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Width; j++) &#123;  </span><br><span class="line">			<span class="keyword">if</span> (canvas[i][j] == <span class="number">0</span>)  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (canvas[i][j] == <span class="number">1</span>)  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (canvas[i][j] == <span class="number">2</span>)  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (canvas[i][j] == <span class="number">3</span>)  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;#&quot;</span>);  </span><br><span class="line">			  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;|\n&quot;</span>);  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Width; j++)  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;score: %d\n&quot;</span>, score);  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="添加大量砖块"><a href="#添加大量砖块" class="headerlink" title="添加大量砖块"></a>添加大量砖块</h3><p>在采用数组后，初始化砖块变得方便了许多。敲掉砖块的操作也很好写，直接把值3变为值0即可。</p>
<p>在startup函数里可以这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; k++)  </span><br><span class="line">		canvas[position_x][k] = <span class="number">2</span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; Width; k++)  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High / <span class="number">4</span>; i++)  </span><br><span class="line">			canvas[i][k] = <span class="number">3</span>;  </span><br></pre></td></tr></table></figure>

<p>消砖块</p>
<p>判断小球坐标是否与砖块坐标重合即可。其实没那么麻烦，只需要询问一下小球坐标对应的canvas值是不是3就可以了。在敲掉砖块后小球也是要反弹的，规律与撞墙相同。</p>
<p>在updateWithoutInput这样写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (canvas[ball_x - <span class="number">1</span>][ball_y] == <span class="number">3</span>) &#123;  </span><br><span class="line">	ball_vx = -ball_vx;  </span><br><span class="line">	canvas[ball_x - <span class="number">1</span>][ball_y] = <span class="number">0</span>;  </span><br><span class="line">	score++;  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\a&quot;</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h3><p>（里面包含了少许我用来debug的东西，无视就好。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> High 15  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Width 20  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug printf(<span class="meta-string">&quot;ok\n&quot;</span>);  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> ball_x, ball_y;  </span><br><span class="line"><span class="keyword">int</span> ball_vx, ball_vy;  </span><br><span class="line"><span class="keyword">int</span> canvas[High][Width] = &#123; <span class="number">0</span> &#125;;  </span><br><span class="line"><span class="keyword">int</span> position_x, position_y;  </span><br><span class="line"><span class="keyword">int</span> ridus;  </span><br><span class="line"><span class="keyword">int</span> left, right;  </span><br><span class="line"><span class="keyword">int</span> score;  </span><br><span class="line"><span class="keyword">int</span> SPD;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gotoxy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  </span><br><span class="line">	HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);  </span><br><span class="line">	COORD pos;  </span><br><span class="line">	pos.X = x;  </span><br><span class="line">	pos.Y = y;  </span><br><span class="line">	SetConsoleCursorPosition(handle, pos);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HideCursor</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	CONSOLE_CURSOR_INFO cursor_info = &#123; <span class="number">1</span>,<span class="number">0</span> &#125;;  </span><br><span class="line">	SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	ball_x = <span class="number">10</span>;  </span><br><span class="line">	ball_y = Width / <span class="number">2</span>;  </span><br><span class="line">	ball_vx = <span class="number">-1</span>;  </span><br><span class="line">	ball_vy = <span class="number">1</span>;  </span><br><span class="line">	canvas[ball_x][ball_y] = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">	ridus = <span class="number">5</span>;  </span><br><span class="line">	position_x = High - <span class="number">1</span>;  </span><br><span class="line">	position_y = Width / <span class="number">2</span>;  </span><br><span class="line">	left = position_y - ridus;  </span><br><span class="line">	right = position_y + ridus;  </span><br><span class="line">	  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; k++)  </span><br><span class="line">		canvas[position_x][k] = <span class="number">2</span>;  </span><br><span class="line">	  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; Width; k++)  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High / <span class="number">4</span>; i++)  </span><br><span class="line">			canvas[i][k] = <span class="number">3</span>;  </span><br><span class="line">	  </span><br><span class="line">	score = <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	gotoxy(<span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High; i++) &#123;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Width; j++) &#123;  </span><br><span class="line">			<span class="keyword">if</span> (canvas[i][j] == <span class="number">0</span>)  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (canvas[i][j] == <span class="number">1</span>)  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (canvas[i][j] == <span class="number">2</span>)  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (canvas[i][j] == <span class="number">3</span>)  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;#&quot;</span>);  </span><br><span class="line">			  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;|\n&quot;</span>);  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Width; j++)  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;score: %d\n&quot;</span>, score);  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateWithoutInput</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">if</span> (ball_x == High - <span class="number">2</span>) &#123;  </span><br><span class="line">		<span class="keyword">if</span> ((ball_y &gt;= left) &amp;&amp; (ball_y &lt;= right)) &#123;  </span><br><span class="line">			<span class="comment">//printf(&quot;\a&quot;);  </span></span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">else</span> &#123;  </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;GG\n&quot;</span>);  </span><br><span class="line">			system(<span class="string">&quot;pause&quot;</span>);  </span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">		&#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">	canvas[ball_x][ball_y] = <span class="number">0</span>;  </span><br><span class="line">	ball_x = ball_x + ball_vx;  </span><br><span class="line">	ball_y = ball_y + ball_vy;  </span><br><span class="line">	canvas[ball_x][ball_y] = <span class="number">1</span>;  </span><br><span class="line">	  </span><br><span class="line">	<span class="keyword">if</span> ((ball_x == <span class="number">0</span>) || (ball_x == High - <span class="number">2</span>)) &#123;  </span><br><span class="line">		ball_vx = -ball_vx;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">if</span> ((ball_y == <span class="number">0</span>) || (ball_y == Width - <span class="number">1</span>)) &#123;  </span><br><span class="line">		ball_vy = -ball_vy;  </span><br><span class="line">	&#125;  </span><br><span class="line">	  </span><br><span class="line">	<span class="keyword">if</span> (canvas[ball_x - <span class="number">1</span>][ball_y] == <span class="number">3</span>) &#123;  </span><br><span class="line">		ball_vx = -ball_vx;  </span><br><span class="line">		canvas[ball_x - <span class="number">1</span>][ball_y] = <span class="number">0</span>;  </span><br><span class="line">		score++;  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\a&quot;</span>);  </span><br><span class="line">	&#125;  </span><br><span class="line">	  </span><br><span class="line">	Sleep(<span class="number">100</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateWithInput</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">char</span> input;  </span><br><span class="line">	<span class="keyword">if</span> (_kbhit()) &#123;  </span><br><span class="line">		input = _getch();  </span><br><span class="line">		<span class="keyword">if</span> ((input == <span class="string">&#x27;a&#x27;</span>) &amp;&amp; (left &gt; <span class="number">0</span>)) &#123;  </span><br><span class="line">			canvas[position_x][right] = <span class="number">0</span>;  </span><br><span class="line">			position_y--;  </span><br><span class="line">			left = position_y - ridus;  </span><br><span class="line">			right = position_y + ridus;  </span><br><span class="line">			canvas[position_x][left] = <span class="number">2</span>;  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">if</span> ((input == <span class="string">&#x27;d&#x27;</span>) &amp;&amp; (right &lt; Width - <span class="number">1</span>)) &#123;  </span><br><span class="line">			canvas[position_x][left] = <span class="number">0</span>;  </span><br><span class="line">			position_y++;  </span><br><span class="line">			left = position_y - ridus;  </span><br><span class="line">			right = position_y + ridus;  </span><br><span class="line">			canvas[position_x][right] = <span class="number">2</span>;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	startup();  </span><br><span class="line">	HideCursor();  </span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">		show();  </span><br><span class="line">		updateWithInput();  </span><br><span class="line">		updateWithoutInput();  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="实现一个简易的flappy-bird游戏"><a href="#实现一个简易的flappy-bird游戏" class="headerlink" title="实现一个简易的flappy bird游戏"></a>实现一个简易的flappy bird游戏</h2><p>最后一个游戏示例了。后续将介绍easyX以及使用easyX包装后的程序。  </p>
<h3 id="显示小鸟"><a href="#显示小鸟" class="headerlink" title="显示小鸟"></a>显示小鸟</h3><p>对flappy bird中小鸟的控制与之前在反弹球中介绍的差不多。我们还是用二维数组当作画布，先画一个随时间下落的小鸟，然后通过按下空格让小鸟的位置上升，代码如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> High 15  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Width 20  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> bird_x, bird_y;  </span><br><span class="line"><span class="keyword">int</span> canvas[High][Width];  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gotoxy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  </span><br><span class="line">	HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);  </span><br><span class="line">	COORD pos;  </span><br><span class="line">	pos.X = x;  </span><br><span class="line">	pos.Y = y;  </span><br><span class="line">	SetConsoleCursorPosition(handle, pos);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HideCursor</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	CONSOLE_CURSOR_INFO cursor_info = &#123; <span class="number">1</span>,<span class="number">0</span> &#125;;  </span><br><span class="line">	SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="built_in">memset</span>(canvas, <span class="number">0</span>, <span class="keyword">sizeof</span>(canvas));  </span><br><span class="line">	bird_x = High / <span class="number">2</span>;  </span><br><span class="line">	bird_y = <span class="number">3</span>;  </span><br><span class="line">	  </span><br><span class="line">	canvas[bird_x][bird_y] = <span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	gotoxy(<span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High; i++) &#123;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Width; j++) &#123;  </span><br><span class="line">			<span class="keyword">if</span> (canvas[i][j] == <span class="number">1</span>)  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;@&quot;</span>);  </span><br><span class="line">			<span class="keyword">else</span>  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateWithInput</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">char</span> input;  </span><br><span class="line">	<span class="keyword">if</span> (_kbhit()) &#123;  </span><br><span class="line">		input = _getch();  </span><br><span class="line">		<span class="keyword">if</span> (input == <span class="string">&#x27; &#x27;</span>) &#123;  </span><br><span class="line">			canvas[bird_x][bird_y] = <span class="number">0</span>;  </span><br><span class="line">			bird_x -= <span class="number">3</span>;  </span><br><span class="line">			canvas[bird_x][bird_y] = <span class="number">1</span>;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateWithoutInput</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	Sleep(<span class="number">150</span>);  </span><br><span class="line">	canvas[bird_x][bird_y] = <span class="number">0</span>;  </span><br><span class="line">	bird_x++;  </span><br><span class="line">	canvas[bird_x][bird_y] = <span class="number">1</span>;  </span><br><span class="line">	  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	startup();  </span><br><span class="line">	HideCursor();  </span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">		show();  </span><br><span class="line">		updateWithInput();  </span><br><span class="line">		updateWithoutInput();  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h3 id="制造障碍物"><a href="#制造障碍物" class="headerlink" title="制造障碍物"></a>制造障碍物</h3><p>其实没必要在设置的时候把整个障碍物都设置出来。想一下，flappy bird的障碍物是长什么样的？其实，我们只需要设定三个值就可以表示一个障碍物。</p>
<p>我们默认同屏有三个障碍物出现。笔者尝试用数组优化实现但是无果，最后选择使用单独的变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> High 20  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Width 30  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Barnum 3  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> bird_x, bird_y;  </span><br><span class="line"><span class="keyword">int</span> canvas[High][Width];  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> bar1_y, bar2_y, bar3_y;  </span><br><span class="line"><span class="keyword">int</span> bar1_xtop, bar2_xtop, bar3_xtop;  </span><br><span class="line"><span class="keyword">int</span> bar1_xbottom, bar2_xbottom, bar3_xbottom;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gotoxy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  </span><br><span class="line">	HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);  </span><br><span class="line">	COORD pos;  </span><br><span class="line">	pos.X = x;  </span><br><span class="line">	pos.Y = y;  </span><br><span class="line">	SetConsoleCursorPosition(handle, pos);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HideCursor</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	CONSOLE_CURSOR_INFO cursor_info = &#123; <span class="number">1</span>,<span class="number">0</span> &#125;;  </span><br><span class="line">	SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="built_in">memset</span>(canvas, <span class="number">0</span>, <span class="keyword">sizeof</span>(canvas));  </span><br><span class="line">	bird_x = High / <span class="number">2</span>;  </span><br><span class="line">	bird_y = <span class="number">3</span>;  </span><br><span class="line">	canvas[bird_x][bird_y] = <span class="number">-1</span>;  </span><br><span class="line">	  </span><br><span class="line">	bar1_y = Width / <span class="number">2</span> - <span class="number">5</span>;  </span><br><span class="line">	bar2_y = bar1_y + <span class="number">9</span>;  </span><br><span class="line">	bar3_y = bar2_y + <span class="number">9</span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">int</span> temp = rand() % <span class="keyword">int</span>(High * <span class="number">0.8</span>);  </span><br><span class="line">	bar1_xbottom = temp - High / <span class="number">10</span>;  </span><br><span class="line">	bar1_xtop = temp + High / <span class="number">10</span>;  </span><br><span class="line">  </span><br><span class="line">	temp = rand() % <span class="keyword">int</span>(High * <span class="number">0.8</span>);  </span><br><span class="line">	bar2_xbottom = temp - High / <span class="number">10</span>;  </span><br><span class="line">	bar2_xtop = temp + High / <span class="number">10</span>;  </span><br><span class="line">  </span><br><span class="line">	temp = rand() % <span class="keyword">int</span>(High * <span class="number">0.8</span>);  </span><br><span class="line">	bar3_xbottom = temp - High / <span class="number">10</span>;  </span><br><span class="line">	bar3_xtop = temp + High / <span class="number">10</span>;  </span><br><span class="line">  </span><br><span class="line">	canvas[bar1_xtop][bar1_y] = <span class="number">1</span>;  </span><br><span class="line">	canvas[bar1_xbottom][bar1_y] = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">	canvas[bar2_xtop][bar2_y] = <span class="number">1</span>;  </span><br><span class="line">	canvas[bar2_xbottom][bar2_y] = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">	canvas[bar3_xtop][bar3_y] = <span class="number">1</span>;  </span><br><span class="line">	canvas[bar3_xbottom][bar3_y] = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High; i++) &#123;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Width; j++) &#123;  </span><br><span class="line">			<span class="keyword">if</span> ((j == bar1_y) &amp;&amp; ((i &lt; bar1_xbottom) || (i &gt; bar1_xtop)))  </span><br><span class="line">				canvas[i][j] = <span class="number">1</span>;  </span><br><span class="line">			<span class="keyword">if</span> ((j == bar2_y) &amp;&amp; ((i &lt; bar2_xbottom) || (i &gt; bar2_xtop)))  </span><br><span class="line">				canvas[i][j] = <span class="number">1</span>;  </span><br><span class="line">			<span class="keyword">if</span> ((j == bar3_y) &amp;&amp; ((i &lt; bar3_xbottom) || (i &gt; bar3_xtop)))  </span><br><span class="line">				canvas[i][j] = <span class="number">1</span>;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	gotoxy(<span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High; i++) &#123;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Width; j++) &#123;  </span><br><span class="line">			<span class="keyword">if</span> (canvas[i][j] == <span class="number">-1</span>)  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;@&quot;</span>);  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (canvas[i][j] == <span class="number">1</span>)  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);  </span><br><span class="line">			<span class="keyword">else</span>  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">	&#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateWithInput</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	<span class="keyword">char</span> input;  </span><br><span class="line">	<span class="keyword">if</span> (_kbhit()) &#123;  </span><br><span class="line">		input = _getch();  </span><br><span class="line">		<span class="keyword">if</span> (input == <span class="string">&#x27; &#x27;</span>) &#123;  </span><br><span class="line">			canvas[bird_x][bird_y] = <span class="number">0</span>;  </span><br><span class="line">			bird_x -= <span class="number">3</span>;  </span><br><span class="line">			canvas[bird_x][bird_y] = <span class="number">-1</span>;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateWithoutInput</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	Sleep(<span class="number">150</span>);  </span><br><span class="line">	canvas[bird_x][bird_y] = <span class="number">0</span>;  </span><br><span class="line">	bird_x++;  </span><br><span class="line">	canvas[bird_x][bird_y] = <span class="number">-1</span>;  </span><br><span class="line">	  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	startup();  </span><br><span class="line">	HideCursor();  </span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">		show();  </span><br><span class="line">		updateWithInput();  </span><br><span class="line">		updateWithoutInput();  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>




<p>目前这样的障碍物是没办法动的，下一步我们让它动起来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateWithoutInput</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Sleep(<span class="number">200</span>);  </span><br><span class="line">    canvas[bird_x][bird_y] = <span class="number">0</span>;  </span><br><span class="line">    bird_x++;  </span><br><span class="line">    canvas[bird_x][bird_y] = <span class="number">-1</span>;    </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High; i++) &#123;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Width; j++) &#123;  </span><br><span class="line">			<span class="keyword">if</span> ((j == bar1_y) &amp;&amp; ((i &lt; bar1_xbottom) || (i &gt; bar1_xtop)))  </span><br><span class="line">				canvas[i][j] = <span class="number">0</span>;  </span><br><span class="line">			<span class="keyword">if</span> ((j == bar2_y) &amp;&amp; ((i &lt; bar2_xbottom) || (i &gt; bar2_xtop)))  </span><br><span class="line">				canvas[i][j] = <span class="number">0</span>;  </span><br><span class="line">			<span class="keyword">if</span> ((j == bar3_y) &amp;&amp; ((i &lt; bar3_xbottom) || (i &gt; bar3_xtop)))  </span><br><span class="line">				canvas[i][j] = <span class="number">0</span>;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   canvas[bar1_xtop][bar1_y] = <span class="number">0</span>;  </span><br><span class="line">   canvas[bar1_xbottom][bar1_y] = <span class="number">0</span>;  </span><br><span class="line">   bar1_y--;  </span><br><span class="line">   canvas[bar1_xtop][bar1_y] = <span class="number">1</span>;  </span><br><span class="line">   canvas[bar1_xbottom][bar1_y] = <span class="number">1</span>;  </span><br><span class="line">    	  </span><br><span class="line">    canvas[bar2_xtop][bar2_y] = <span class="number">0</span>;  </span><br><span class="line">    canvas[bar2_xbottom][bar2_y] = <span class="number">0</span>;  </span><br><span class="line">    bar2_y--;  </span><br><span class="line">    canvas[bar2_xtop][bar2_y] = <span class="number">1</span>;  </span><br><span class="line">    canvas[bar2_xbottom][bar2_y] = <span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">    canvas[bar3_xtop][bar3_y] = <span class="number">0</span>;  </span><br><span class="line">    canvas[bar3_xbottom][bar3_y] = <span class="number">0</span>;  </span><br><span class="line">    bar3_y--;  </span><br><span class="line">    canvas[bar3_xtop][bar3_y] = <span class="number">1</span>;  </span><br><span class="line">    canvas[bar3_xbottom][bar3_y] = <span class="number">1</span>;  </span><br><span class="line">	  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Width; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> ((j == bar1_y) &amp;&amp; ((i &lt; bar1_xbottom) || (i &gt; bar1_xtop)))  </span><br><span class="line">                canvas[i][j] = <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">if</span> ((j == bar2_y) &amp;&amp; ((i &lt; bar2_xbottom) || (i &gt; bar2_xtop)))  </span><br><span class="line">                canvas[i][j] = <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">if</span> ((j == bar3_y) &amp;&amp; ((i &lt; bar3_xbottom) || (i &gt; bar3_xtop)))  </span><br><span class="line">                canvas[i][j] = <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>


<p>其实只需要注意一点就好，就是在新位置绘画之前一定要先清除旧位置的内容。</p>
<h3 id="判断碰撞，记分，循环出现，细节处理"><a href="#判断碰撞，记分，循环出现，细节处理" class="headerlink" title="判断碰撞，记分，循环出现，细节处理"></a>判断碰撞，记分，循环出现，细节处理</h3><p>这是最后的内容了。</p>
<p>由于三个障碍物会循环出现，判断时要略微注意。</p>
<p>小鸟的碰撞和用户的输入无关，所以我们修改updateWithoutInput函数。</p>
<p>记分和游戏失败是同时出现的。小鸟过障碍物只会有两个结果，如果过得去就+1分，过不去则宣告游戏失败。</p>
<p>同时要注意，小鸟触底也算游戏失败，如果小鸟试图飞出屏幕，那么我们应该把它限制在最高位置。具体参见代码：（无力优化，有点冗长）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> High 20  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Width 40  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Barnum 3  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bird_x, bird_y;  </span><br><span class="line"><span class="keyword">int</span> canvas[High][Width];  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bar1_y, bar2_y, bar3_y;  </span><br><span class="line"><span class="keyword">int</span> bar1_xtop, bar2_xtop, bar3_xtop;  </span><br><span class="line"><span class="keyword">int</span> bar1_xbottom, bar2_xbottom, bar3_xbottom;  </span><br><span class="line"><span class="keyword">int</span> score;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gotoxy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  </span><br><span class="line">	HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);  </span><br><span class="line">	COORD pos;  </span><br><span class="line">	pos.X = x;  </span><br><span class="line">	pos.Y = y;  </span><br><span class="line">	SetConsoleCursorPosition(handle, pos);  </span><br><span class="line">&#125;  </span><br><span class="line">	  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HideCursor</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	CONSOLE_CURSOR_INFO cursor_info = &#123; <span class="number">1</span>,<span class="number">0</span> &#125;;  </span><br><span class="line">	SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info);  </span><br><span class="line">&#125;  </span><br><span class="line">	  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">		<span class="built_in">memset</span>(canvas, <span class="number">0</span>, <span class="keyword">sizeof</span>(canvas));  </span><br><span class="line">		bird_x = High / <span class="number">2</span>;  </span><br><span class="line">		bird_y = <span class="number">3</span>;  </span><br><span class="line">		canvas[bird_x][bird_y] = <span class="number">-1</span>;  </span><br><span class="line">		  </span><br><span class="line">		bar1_y = Width / <span class="number">2</span> - <span class="number">5</span>;  </span><br><span class="line">		bar2_y = bar1_y + <span class="number">10</span>;  </span><br><span class="line">		bar3_y = bar2_y + <span class="number">10</span>;  </span><br><span class="line">	  </span><br><span class="line">		<span class="keyword">int</span> temp = rand() % <span class="keyword">int</span>(High * <span class="number">0.8</span>);  </span><br><span class="line">		bar1_xbottom = temp - High / <span class="number">10</span>;  </span><br><span class="line">		bar1_xtop = temp + High / <span class="number">10</span>;  </span><br><span class="line">	  </span><br><span class="line">		temp = rand() % <span class="keyword">int</span>(High * <span class="number">0.8</span>);  </span><br><span class="line">		bar2_xbottom = temp - High / <span class="number">10</span>;  </span><br><span class="line">		bar2_xtop = temp + High / <span class="number">10</span>;  </span><br><span class="line">	  </span><br><span class="line">		temp = rand() % <span class="keyword">int</span>(High * <span class="number">0.8</span>);  </span><br><span class="line">		bar3_xbottom = temp - High / <span class="number">10</span>;  </span><br><span class="line">		bar3_xtop = temp + High / <span class="number">10</span>;  </span><br><span class="line">	  </span><br><span class="line">		canvas[bar1_xtop][bar1_y] = <span class="number">1</span>;  </span><br><span class="line">		canvas[bar1_xbottom][bar1_y] = <span class="number">1</span>;  </span><br><span class="line">	  </span><br><span class="line">		canvas[bar2_xtop][bar2_y] = <span class="number">1</span>;  </span><br><span class="line">		canvas[bar2_xbottom][bar2_y] = <span class="number">1</span>;  </span><br><span class="line">	  </span><br><span class="line">		canvas[bar3_xtop][bar3_y] = <span class="number">1</span>;  </span><br><span class="line">		canvas[bar3_xbottom][bar3_y] = <span class="number">1</span>;  </span><br><span class="line">	  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High; i++) &#123;  </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Width; j++) &#123;  </span><br><span class="line">				<span class="keyword">if</span> ((j == bar1_y) &amp;&amp; ((i &lt; bar1_xbottom) || (i &gt; bar1_xtop)))  </span><br><span class="line">					canvas[i][j] = <span class="number">1</span>;  </span><br><span class="line">				<span class="keyword">if</span> ((j == bar2_y) &amp;&amp; ((i &lt; bar2_xbottom) || (i &gt; bar2_xtop)))  </span><br><span class="line">					canvas[i][j] = <span class="number">1</span>;  </span><br><span class="line">				<span class="keyword">if</span> ((j == bar3_y) &amp;&amp; ((i &lt; bar3_xbottom) || (i &gt; bar3_xtop)))  </span><br><span class="line">					canvas[i][j] = <span class="number">1</span>;  </span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;  </span><br><span class="line">	  </span><br><span class="line">		score = <span class="number">0</span>;  </span><br><span class="line">	  </span><br><span class="line">	&#125;  </span><br><span class="line">	  </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">		gotoxy(<span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High; i++) &#123;  </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Width; j++) &#123;  </span><br><span class="line">				<span class="keyword">if</span> (canvas[i][j] == <span class="number">-1</span>)  </span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;@&quot;</span>);  </span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (canvas[i][j] == <span class="number">1</span>)  </span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);  </span><br><span class="line">				<span class="keyword">else</span>  </span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);  </span><br><span class="line">			&#125;  </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">		&#125;  </span><br><span class="line">	  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;得分： %d&quot;</span>, score);  </span><br><span class="line">	&#125;  </span><br><span class="line">	  </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">updateWithInput</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">		<span class="keyword">char</span> input;  </span><br><span class="line">		<span class="keyword">if</span> (_kbhit()) &#123;  </span><br><span class="line">			input = _getch();  </span><br><span class="line">			<span class="keyword">if</span> (input == <span class="string">&#x27; &#x27;</span>) &#123;  </span><br><span class="line">				canvas[bird_x][bird_y] = <span class="number">0</span>;  </span><br><span class="line">				<span class="keyword">if</span> (bird_x - <span class="number">3</span> &gt;= <span class="number">0</span>)  </span><br><span class="line">					bird_x -= <span class="number">3</span>;  </span><br><span class="line">				<span class="keyword">else</span>  </span><br><span class="line">					bird_x = <span class="number">0</span>;  </span><br><span class="line">				canvas[bird_x][bird_y] = <span class="number">-1</span>;  </span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	  </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">updateWithoutInput</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">		Sleep(<span class="number">200</span>);  </span><br><span class="line">		canvas[bird_x][bird_y] = <span class="number">0</span>;  </span><br><span class="line">		bird_x++;  </span><br><span class="line">		canvas[bird_x][bird_y] = <span class="number">-1</span>;  </span><br><span class="line">	  </span><br><span class="line">		<span class="keyword">if</span> (bird_x == High - <span class="number">1</span>) &#123;  </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;GAME OVER\n&quot;</span>);  </span><br><span class="line">			system(<span class="string">&quot;pause&quot;</span>);  </span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">		&#125;  </span><br><span class="line">	  </span><br><span class="line">		<span class="keyword">if</span> (bird_y == bar1_y) &#123;  </span><br><span class="line">			<span class="keyword">if</span> ((bird_x &gt;= bar1_xbottom) &amp;&amp; (bird_y &lt;= bar1_xtop))  </span><br><span class="line">				score++;  </span><br><span class="line">			<span class="keyword">else</span> &#123;  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;GAME OVER\n&quot;</span>);  </span><br><span class="line">				system(<span class="string">&quot;pause&quot;</span>);  </span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;  </span><br><span class="line">	  </span><br><span class="line">		<span class="keyword">if</span> (bird_y == bar2_y) &#123;  </span><br><span class="line">			<span class="keyword">if</span> ((bird_x &gt;= bar2_xbottom) &amp;&amp; (bird_y &lt;= bar2_xtop))  </span><br><span class="line">				score++;  </span><br><span class="line">			<span class="keyword">else</span> &#123;  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;GAME OVER\n&quot;</span>);  </span><br><span class="line">				system(<span class="string">&quot;pause&quot;</span>);  </span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;  </span><br><span class="line">	  </span><br><span class="line">		<span class="keyword">if</span> (bird_y == bar3_y) &#123;  </span><br><span class="line">			<span class="keyword">if</span> ((bird_x &gt;= bar3_xbottom) &amp;&amp; (bird_y &lt;= bar3_xtop))  </span><br><span class="line">				score++;  </span><br><span class="line">			<span class="keyword">else</span> &#123;  </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;GAME OVER\n&quot;</span>);  </span><br><span class="line">				system(<span class="string">&quot;pause&quot;</span>);  </span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High; i++) &#123;  </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Width; j++) &#123;  </span><br><span class="line">				<span class="keyword">if</span> ((j == bar1_y) &amp;&amp; ((i &lt; bar1_xbottom) || (i &gt; bar1_xtop)))  </span><br><span class="line">					canvas[i][j] = <span class="number">0</span>;  </span><br><span class="line">				<span class="keyword">if</span> ((j == bar2_y) &amp;&amp; ((i &lt; bar2_xbottom) || (i &gt; bar2_xtop)))  </span><br><span class="line">					canvas[i][j] = <span class="number">0</span>;  </span><br><span class="line">				<span class="keyword">if</span> ((j == bar3_y) &amp;&amp; ((i &lt; bar3_xbottom) || (i &gt; bar3_xtop)))  </span><br><span class="line">					canvas[i][j] = <span class="number">0</span>;  </span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;  </span><br><span class="line">	  </span><br><span class="line">		canvas[bar1_xtop][bar1_y] = <span class="number">0</span>;  </span><br><span class="line">		canvas[bar1_xbottom][bar1_y] = <span class="number">0</span>;  </span><br><span class="line">		bar1_y--;  </span><br><span class="line">		canvas[bar1_xtop][bar1_y] = <span class="number">1</span>;  </span><br><span class="line">		canvas[bar1_xbottom][bar1_y] = <span class="number">1</span>;  </span><br><span class="line">	  </span><br><span class="line">		canvas[bar2_xtop][bar2_y] = <span class="number">0</span>;  </span><br><span class="line">		canvas[bar2_xbottom][bar2_y] = <span class="number">0</span>;  </span><br><span class="line">		bar2_y--;  </span><br><span class="line">		canvas[bar2_xtop][bar2_y] = <span class="number">1</span>;  </span><br><span class="line">		canvas[bar2_xbottom][bar2_y] = <span class="number">1</span>;  </span><br><span class="line">	  </span><br><span class="line">		canvas[bar3_xtop][bar3_y] = <span class="number">0</span>;  </span><br><span class="line">		canvas[bar3_xbottom][bar3_y] = <span class="number">0</span>;  </span><br><span class="line">		bar3_y--;  </span><br><span class="line">		canvas[bar3_xtop][bar3_y] = <span class="number">1</span>;  </span><br><span class="line">		canvas[bar3_xbottom][bar3_y] = <span class="number">1</span>;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High; i++) &#123;  </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Width; j++) &#123;  </span><br><span class="line">				<span class="keyword">if</span> ((j == bar1_y) &amp;&amp; ((i &lt; bar1_xbottom) || (i &gt; bar1_xtop)))  </span><br><span class="line">					canvas[i][j] = <span class="number">1</span>;  </span><br><span class="line">				<span class="keyword">if</span> ((j == bar2_y) &amp;&amp; ((i &lt; bar2_xbottom) || (i &gt; bar2_xtop)))  </span><br><span class="line">					canvas[i][j] = <span class="number">1</span>;  </span><br><span class="line">				<span class="keyword">if</span> ((j == bar3_y) &amp;&amp; ((i &lt; bar3_xbottom) || (i &gt; bar3_xtop)))  </span><br><span class="line">					canvas[i][j] = <span class="number">1</span>;  </span><br><span class="line">			&#125;  </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span> (bar1_y &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High; i++) &#123;  </span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Width; j++) &#123;  </span><br><span class="line">					<span class="keyword">if</span> ((j == bar1_y) &amp;&amp; ((i &lt; bar1_xbottom) || (i &gt; bar1_xtop)))  </span><br><span class="line">						canvas[i][j] = <span class="number">0</span>;  </span><br><span class="line">				&#125;  </span><br><span class="line">			&#125;  </span><br><span class="line">			canvas[bar1_xtop][bar1_y] = <span class="number">0</span>;  </span><br><span class="line">        	canvas[bar1_xbottom][bar1_y] = <span class="number">0</span>;  </span><br><span class="line">        	bar1_y = Width;  </span><br><span class="line">			<span class="keyword">int</span> temp = rand() % <span class="keyword">int</span>(High * <span class="number">0.8</span>);  </span><br><span class="line">			bar1_xbottom = temp - High / <span class="number">10</span>;  </span><br><span class="line">			bar1_xtop = temp + High / <span class="number">10</span>;  </span><br><span class="line">	  </span><br><span class="line">			canvas[bar1_xtop][bar1_y] = <span class="number">1</span>;  </span><br><span class="line">			canvas[bar1_xbottom][bar1_y] = <span class="number">0</span>;  </span><br><span class="line">	  </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High; i++) &#123;  </span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Width; j++) &#123;  </span><br><span class="line">					<span class="keyword">if</span> ((j == bar1_y) &amp;&amp; ((i &lt; bar1_xbottom) || (i &gt; bar1_xtop)))  </span><br><span class="line">						canvas[i][j] = <span class="number">1</span>;  </span><br><span class="line">				&#125;  </span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;  </span><br><span class="line">		  </span><br><span class="line">		<span class="keyword">if</span> (bar2_y &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High; i++) &#123;  </span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Width; j++) &#123;  </span><br><span class="line">					<span class="keyword">if</span> ((j == bar2_y) &amp;&amp; ((i &lt; bar2_xbottom) || (i &gt; bar2_xtop)))  </span><br><span class="line">						canvas[i][j] = <span class="number">0</span>;  </span><br><span class="line">				&#125;  </span><br><span class="line">			&#125;  </span><br><span class="line">			canvas[bar2_xtop][bar2_y] = <span class="number">0</span>;  </span><br><span class="line">			canvas[bar2_xbottom][bar2_y] = <span class="number">0</span>;</span><br><span class="line">			bar2_y = Width;  </span><br><span class="line">			<span class="keyword">int</span> temp = rand() % <span class="keyword">int</span>(High * <span class="number">0.8</span>);  </span><br><span class="line">			bar2_xbottom = temp - High / <span class="number">10</span>;  </span><br><span class="line">			bar2_xtop = temp + High / <span class="number">10</span>;  </span><br><span class="line">	  </span><br><span class="line">			canvas[bar2_xtop][bar2_y] = <span class="number">1</span>;  </span><br><span class="line">			canvas[bar2_xbottom][bar2_y] = <span class="number">0</span>;  </span><br><span class="line">	  </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High; i++) &#123;  </span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Width; j++) &#123;  </span><br><span class="line">					<span class="keyword">if</span> ((j == bar2_y) &amp;&amp; ((i &lt; bar2_xbottom) || (i &gt; bar2_xtop)))  </span><br><span class="line">						canvas[i][j] = <span class="number">1</span>;  </span><br><span class="line">				&#125;  </span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;  </span><br><span class="line">	  </span><br><span class="line">		<span class="keyword">if</span> (bar3_y &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High; i++) &#123;  </span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Width; j++) &#123;  </span><br><span class="line">					<span class="keyword">if</span> ((j == bar3_y) &amp;&amp; ((i &lt; bar3_xbottom) || (i &gt; bar3_xtop)))  </span><br><span class="line">						canvas[i][j] = <span class="number">0</span>;  </span><br><span class="line">				&#125;  </span><br><span class="line">			&#125;  </span><br><span class="line">			canvas[bar3_xtop][bar3_y] = <span class="number">0</span>;  </span><br><span class="line">			canvas[bar3_xbottom][bar3_y] = <span class="number">0</span>;  </span><br><span class="line">			bar3_y = Width;  </span><br><span class="line">			<span class="keyword">int</span> temp = rand() % <span class="keyword">int</span>(High * <span class="number">0.8</span>);  </span><br><span class="line">			bar3_xbottom = temp - High / <span class="number">10</span>;  </span><br><span class="line">			bar3_xtop = temp + High / <span class="number">10</span>;  </span><br><span class="line">	  </span><br><span class="line">			canvas[bar3_xtop][bar3_y] = <span class="number">1</span>;  </span><br><span class="line">			canvas[bar3_xbottom][bar3_y] = <span class="number">0</span>;  </span><br><span class="line">	  </span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; High; i++) &#123;  </span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Width; j++) &#123;  </span><br><span class="line">					<span class="keyword">if</span> ((j == bar3_y) &amp;&amp; ((i &lt; bar3_xbottom) || (i &gt; bar3_xtop)))  </span><br><span class="line">						canvas[i][j] = <span class="number">1</span>;  </span><br><span class="line">				&#125;  </span><br><span class="line">			&#125;  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	  </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">		startup();  </span><br><span class="line">		HideCursor();  </span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">			show();  </span><br><span class="line">			updateWithInput();  </span><br><span class="line">			updateWithoutInput();  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">	&#125;  </span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2018/08/09/5b6c481eebfbd.jpg"></p>
<h2 id="easyX到底是个什么鬼东西？？？"><a href="#easyX到底是个什么鬼东西？？？" class="headerlink" title="easyX到底是个什么鬼东西？？？"></a>easyX到底是个什么鬼东西？？？</h2><p>它是一个图形库，很简单，很简陋的图形库。但是由于非常简单易用，所以通常被用来作为初学者接触图形编程或者游戏编程的一个工具。使用easyX可以做出一些很简单的2D游戏。</p>
<p>不过，麻雀虽小五脏俱全，easyX所附带的功能还是非常多的。具体的我会慢慢说。</p>
<p>目前来说它只适用于VC平台。</p>
<p>在easyX的官网<a href="https://www.easyx.cn/">https://www.easyx.cn/</a>可以找到它的下载链接和一些技术性帮助文档。</p>
<p>为方便安装，这里给出 <strong>官方文档</strong> 中提供的安装方法。</p>
<blockquote>
<p>安装<br>系统支持</p>
<p>操作系统版本：Windows XP(sp3) 及以上操作系统。<br>编译环境版本：Visual C++ 6.0 / 2008 ~ 2017(x86 &amp; x64)。</p>
<p>安装</p>
<p>请下载最新版 EasyX 安装程序，直接运行，并跟随提示安装即可。</p>
<p>安装程序会自动检测您已经安装的 VC 版本，并根据您的选择将对应的 .h 和 .lib 文件安装至 VC 的 include 和 lib<br>文件夹内。安装程序不会修改注册表或者您本机的其它任何文件。</p>
<p>卸载</p>
<p>由于安装程序并不改写注册表，因此您在“添加删除程序”中不会看到 EasyX<br>的卸载项。如需卸载，请再次执行对应版本的安装程序，并根据提示卸载。也可以手动将相关的 .h 和 .lib 删除，系统中不会残留任何垃圾信息。</p>
<p>手动安装方法</p>
<p>EasyX 安装程序是用 7-Zip 封装的自解压缩包程序。手动安装时，可以直接用 7-Zip<br>将安装文件解压，再根据下面的文件列表说明，将解压后的相关文件分别拷贝到 VC 对应的 include 和 lib 文件夹内。或者将所需的 include<br>和 lib 文件夹放到任意位置，然后在 VC 中增加 Lib 和 Include 的引用路径。</p>
<p>文件列表说明：</p>
<p>EasyX 安装程序<br>├ include<br>│ ├ easyx.h // 头文件<br>│ └ graphics.h // 头文件(模拟 BGI 绘图库)<br>├ lib<br>│ ├ VC6<br>│ │ └ x86<br>│ │ ├ EasyXa.lib // VC6 库文件(MBCS 版本)<br>│ │ └ EasyXw.lib // VC6 库文件(Unicode 版本)<br>│ ├ VC2013<br>│ │ ├ x64<br>│ │ │ ├ EasyXa.lib // VC2008 ~ 2013 库文件(x64, MBCS 版本)<br>│ │ │ └ EasyXw.lib // VC2008 ~ 2013 库文件(x64, Unicode 版本)<br>│ │ └ x86<br>│ │ ├ EasyXa.lib // VC2008 ~ 2013 库文件(x86, MBCS 版本)<br>│ │ └ EasyXw.lib // VC2008 ~ 2013 库文件(x86, Unicode 版本)<br>│ └ VC2017<br>│ ├ x64<br>│ │ ├ EasyXa.lib // VC2015 ~ 2017 库文件(x64, MBCS 版本)<br>│ │ └ EasyXw.lib // VC2015 ~ 2017 库文件(x64, Unicode 版本)<br>│ └ x86<br>│ ├ EasyXa.lib // VC2015 ~ 2017 库文件(x86, MBCS 版本)<br>│ └ EasyXw.lib // VC2015 ~ 2017 库文件(x86, Unicode 版本)<br>├ EasyX_Help.chm // 帮助文件<br>└ Setup.hta // 安装程序项目依赖</p>
<p>EasyX 库采用静态链接方式，不会为您的程序增加任何额外的 DLL 依赖。</p>
</blockquote>
<h2 id="这玩意怎么用啊"><a href="#这玩意怎么用啊" class="headerlink" title="这玩意怎么用啊"></a>这玩意怎么用啊</h2><p>简单。这个图形库很多功能都已经打包成了函数，只需要来一句#include&lt;graphics.h&gt;就可以愉快地使用easyX啦。</p>
<p>PS：一定要用好它附带的说明文档：</p>
<p><img src="https://i.loli.net/2018/08/09/5b6c3ea605bf2.png"></p>
<p>这里面有最官方并且最详细的解释说明。</p>
<h2 id="一个通俗易懂的例子"><a href="#一个通俗易懂的例子" class="headerlink" title="一个通俗易懂的例子"></a>一个通俗易懂的例子</h2><p>easyX自带的绘图函数有很多。这里简单举个例子。</p>
<p>一些最基本的图形，比如直线，矩形，圆，它都可以用对应的函数画出来。</p>
<p>这里要注意，它并不是直接把图像画到控制台那个大黑框里，而是需要先进行初始化窗体，然后在这个初始化后的窗体里进行绘画。<br> <del>（虽然也是大黑框</del></p>
<p>想要改变颜色的话也可以使用对应的函数。设置线条，填充，前景，背景……等等，都有对应的函数。当然，线条样式什么的也可以设定。</p>
<p>easyX把一些常用的颜色设定好了颜色常量，我们可以直接使用。如果你需要其它颜色，可以通过三原色设置函数RGB()来进行更多颜色设定，它接受三个0~255之间的整型参数。</p>
<p>给出一个简单的示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;graphics.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	initgraph(<span class="number">640</span>, <span class="number">480</span>);  </span><br><span class="line">	setcolor(GREEN);  </span><br><span class="line">	setfillcolor(YELLOW);  </span><br><span class="line">	fillcircle(<span class="number">233</span>, <span class="number">233</span>, <span class="number">100</span>);  </span><br><span class="line">	circle(<span class="number">233</span>, <span class="number">233</span>, <span class="number">200</span>);  </span><br><span class="line">	setcolor(RED);  </span><br><span class="line">	line(<span class="number">600</span>, <span class="number">0</span>, <span class="number">600</span>, <span class="number">480</span>);  </span><br><span class="line">	_getch();  </span><br><span class="line">	closegraph();  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>解释一下吧。initgraph函数用来初始化绘图窗体，setcolor是设置线条颜色，setfillcolor是设置填充颜色。</p>
<p>circle函数用来画一个“空心”圆，也就是不使用填充颜色的圆，它接受三个参数，前两个代表画布上的xy坐标（和之前说的一样），第三个代表半径，单位都是像素。</p>
<p>fillcircle同理，不过画的是“实心”圆。</p>
<p>line函数可以画一条直线。我们知道，两点确定一条直线，line函数就是这样，它接受四个参数，其实是代表两个点的坐标，然后它就可以画一条直线。</p>
<p>_getch就是让你按任意键退出的……</p>
<p>closegraph用来关闭图形界面。不关闭会发生什么呢？</p>
<p>实测，什么也不会发生。</p>
<p>这个程序执行效果是这样的：</p>
<p><img src="https://i.loli.net/2018/08/09/5b6c45d083889.png"></p>
<p>是不是很cooooooooooooooooooooooooooooooooool？（滑稽</p>
<p>其实好玩的，好康的（误，东西还有很多。</p>
<h2 id="使用easyx画一个动起来的小球"><a href="#使用easyx画一个动起来的小球" class="headerlink" title="使用easyx画一个动起来的小球"></a>使用easyx画一个动起来的小球</h2><p>首先让我们画一个不动的小球。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;graphics.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	initgraph(<span class="number">640</span>, <span class="number">480</span>);  </span><br><span class="line">	setcolor(LIGHTBLUE);<span class="comment">//颜色随意  </span></span><br><span class="line">	setfillcolor(BLUE);  </span><br><span class="line">	fillcircle(<span class="number">100</span>, <span class="number">100</span>, <span class="number">30</span>);  </span><br><span class="line">	_getch();  </span><br><span class="line">	closegraph();  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>还记得之前用数组作为画布时如何更新小球的位置吗？先清除原位置的绘画，再改变坐标，再在新位置上画上小球。使用easyX实现动画一般也分三个步骤：</p>
<pre><code>1. 绘制新图形
2. 延时
3. 清除旧图形</code></pre>
<p>给出一个很简单的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;graphics.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	initgraph(<span class="number">640</span>, <span class="number">480</span>);  </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">100</span>; x &lt; <span class="number">500</span>; x++) &#123;  </span><br><span class="line">		setcolor(LIGHTBLUE);  </span><br><span class="line">		setfillcolor(BLUE);  </span><br><span class="line">		fillcircle(x, <span class="number">100</span>, <span class="number">20</span>);  </span><br><span class="line">		Sleep(<span class="number">5</span>);  </span><br><span class="line">		setcolor(BLACK);  </span><br><span class="line">		setfillcolor(BLACK);  </span><br><span class="line">		fillcircle(x, <span class="number">100</span>, <span class="number">20</span>);  </span><br><span class="line">	&#125;  </span><br><span class="line">	_getch();  </span><br><span class="line">	closegraph();  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>诶？这里为什么不是先清除再绘制呢？</p>
<p>看一下这个例子，在每一次for循环中，我们先在这个位置打印出小球，然后立即删除小球，然后x增加，在新位置打印小球，再删除小球……由于人的视觉暂留现象，你看到的就是一个移动的小球。试想，对于每一次for，如果先删除再绘制，那岂不是删除操作就没有任何意义了？因为你每次都会试图删除一个不存在的小球，因为这个小球根本就没有绘制。</p>
<p>为啥要延时？</p>
<p>不延时小球跑那么快你看得清吗……</p>
<p>实际上，Sleep函数设定的值越低，动画就会看起来越流畅。但是会出现闪屏问题，这是我们不能接受的。</p>
<p>其实我们可以借助批量绘图函数来代替延时功能。它们分别是BeginBatchDraw(),FlushBatchDraw(),EndBatchDraw()。</p>
<p>BeginBatchDraw()用于开始绘图时，该命令执行后任何的绘图操作都暂时不会输出到屏幕上，直到遇到FlushBatchDraw()。EndBatchDraw()用来结束批量绘制，并且执行还没有完成的绘制任务。</p>
<p>下面我们用easyX改进反弹球。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;graphics.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> High 480  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Width 640  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> ball_x, ball_y;  </span><br><span class="line"><span class="keyword">int</span> ball_vx, ball_vy;  </span><br><span class="line"><span class="keyword">int</span> radius;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">initgraph(Width, High);  </span><br><span class="line">ball_x = Width / <span class="number">2</span>;  </span><br><span class="line">ball_y = High / <span class="number">2</span>;  </span><br><span class="line">ball_vx = <span class="number">1</span>;  </span><br><span class="line">ball_vy = <span class="number">1</span>;  </span><br><span class="line">radius = <span class="number">30</span>;  </span><br><span class="line">BeginBatchDraw();  </span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">	setcolor(BLACK);  </span><br><span class="line">	setfillcolor(BLACK);  </span><br><span class="line">	fillcircle(ball_x, ball_y, radius);  </span><br><span class="line">	ball_x += ball_vx;  </span><br><span class="line">	ball_y += ball_vy;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span> ((ball_x &lt;= radius) || (ball_x &gt;= Width - radius))  </span><br><span class="line">		ball_vx = -ball_vx;  </span><br><span class="line">	<span class="keyword">if</span> ((ball_y &lt;= radius) || (ball_y &gt;= High - radius))  </span><br><span class="line">		ball_vy = -ball_vy;  </span><br><span class="line">	  </span><br><span class="line">	setcolor(LIGHTBLUE);  </span><br><span class="line">	setfillcolor(BLUE);  </span><br><span class="line">	fillcircle(ball_x, ball_y, radius);  </span><br><span class="line">	FlushBatchDraw();  </span><br><span class="line">	Sleep(<span class="number">5</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">EndBatchDraw();  </span><br><span class="line">closegraph();  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>诶，这里怎么是先清除再绘制啊，博主你不是说这没有意义吗？</p>
<p>仔细看代码，我在执行完清除操作后， <strong>将小球位置进行了变动</strong><br>。来模拟一下这个过程，其实就不难理解了。第一遍循环，首先画一个黑球（这个黑球确实没有意义，但是只在这一遍循环中没有意义，你应该不会介意这个的），然后小球的坐标变化，在新位置画一个有颜色的球。然后下一遍循环会先把上一遍循环打印出的小球涂黑，再变化坐标，画一个新球……其实道理是一样的。</p>
<p>想添加方框？画就是了。然后修改一下边界判定，把方框那块大小“扣出去”就好啦。</p>
<p>其实写到这里，我发现已经没有其他内容了，才想起来，当时学到这里就被叫停了。</p>
]]></content>
      <categories>
        <category>C语言游戏开发</category>
      </categories>
  </entry>
</search>
