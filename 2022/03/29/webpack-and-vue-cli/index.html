<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="博客,前端博客,JavaScript,html5,css3,html,css,js,acm,noip,橙果工作室,shawnzhou,shawn zhou" />
   
  <meta name="description" content="ShawnZhou的小站" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    关于Webpack与Vue CLI的知识点整理 |  ShawnZhou的小站
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="ShawnZhou的小站" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-webpack-and-vue-cli"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  关于Webpack与Vue CLI的知识点整理
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2022/03/29/webpack-and-vue-cli/" class="article-date">
  <time datetime="2022-03-29T03:22:38.000Z" itemprop="datePublished">2022-03-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E9%82%A3%E4%BA%9B%E4%BA%8B/">前端开发那些事</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">12.5k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">44 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>这篇文章来梳理一下工程化的一部分内容。Webpack的内容很杂很碎，且版本更迭较快，理解核心思想才能不至于在版本更新中迷失自我。Vue CLI目前已经稳定在4.x版本，整理Vue CLI也算是对这个老牌的工具做个简单的总结，2021年Vite开始爆火，2022年Vite也将继续稳定发展，Vue CLI胜在一手稳定性，大型企业项目的首选，新的小型项目建议首选Vite，开发体验会更舒适。</p>
<p>本文采用的Webpack版本为4.x和5.x，Vue CLI的版本为4.x。行文风格偏理论介绍，实际项目配置其实资料和规范都是很容易查到的，这里就不会举太多例子了。</p>
<p><img src="https://shawnzhou-image.oss-cn-beijing.aliyuncs.com/blog/image6f5c8859706e126ab2b87b9b2eac8177.jpg"></p>
<a id="more"></a>

<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>自前端工程第二次大变革（Node.js问世）以来，以高效率开发和高性能应用为目的而生的前端新技术层出不穷，如新的JavaScript框架、CSS扩展语言，TypeScript等。尽管这些工具都可以方便我们开发前端项目，但它们都有一个共同的问题：浏览器并不能直接识别这些文件，需要使用工具将这些高级的代码转换成最基本的HTML、CSS、JavaScript，浏览器才可以正常执行，这样的工具叫做构建工具，或者称之为打包器亦可。</p>
<p>大部分构建工具都是使用JavaScript开发的。近年来，出现的构建工具有：</p>
<ul>
<li>Grunt：老牌构建工具，生态系统比较庞大，它可以自动运行给定的打包任务，优点是具有大量插件，但缺点是需要提供大量配置</li>
<li>Gulp：一个基于流的构建工具，Gulp通过管道的形式进行文件转换，API相对简单，缺点同Grunt，也需要大量配置</li>
<li>Webpack：模块化构建工具，可以通过使用较多的<code>CommonJS</code>（require）、<code>CMD</code>（define）、<code>AMD</code>（异步define）、<code>ESM</code>（import）等规范进行打包工作，缺点是只支持模块化项目（其实无伤大雅，因为现代Web项目几乎都是模块化的）</li>
<li>Rollup：利用ESM的巧妙设计，构建尽可能高效精简的JavaScript代码，目前Vite采用Rollup代替Webpack作为构建工具</li>
</ul>
<h3 id="整体概念"><a href="#整体概念" class="headerlink" title="整体概念"></a>整体概念</h3><p>Webpack是基于模块的，它会对你编写的各种js文件、vue文件、css，less文件等进行处理，Webpack会进行依赖分析，在Webpack内部会构建出一个依赖关系图，这个图中的每个节点都是一个模块，然后借助这个图去生成并输出静态资源。Webpack官方把打包产物称为<code>bundle</code>，意为一束、一捆、一套。</p>
<p>在正确使用npm安装了Webpack之后（即安装Webpack本体和它的CLI命令行），需要使用<code>webpack.config.js</code>文件控制Webpack的行为，此文件使用CommonJS来包裹所有的配置。</p>
<p>Webpack有四个核心概念，在学习Webpack前必须要熟悉这四个核心概念：</p>
<ul>
<li><p>入口（entry）：Webpack进行依赖分析的时候的起始点，以此为开始进行一个类似DFS的依赖分析。当然，入口也可以是多个。入口的默认值是<code>./src</code>。</p>
</li>
<li><p>输出（output）：此配置项决定Webpack要在哪里输出它的打包文件，以及决定这些文件如何命名，其默认值为<code>./dist</code>，基本上整个项目的编译产物都会被输出到此配置指定的文件夹里。</p>
</li>
<li><p>加载器（loader）：这是Webpack能够转换那些千奇百怪的代码的根源，通过npm安装不同的loader（有很多，用到什么就用什么，文档也很全），就可以用来打包各种浏览器不识别的代码，让它能够被识别。其实loader不仅可以转换代码，它可以转换任意类型的文件，比如图片也是可以的。可以在Webpack配置中的<code>module.rules</code>里面引入loader。</p>
<p>loader本质上是一个函数，输入的是代码文件的字符串，输出的是转化后的代码文件，它支持链式调用，打包的时候是按照配置的loader从后往前的顺序逐个处理。</p>
</li>
<li><p>插件（plugin）：插件可以借助Webpack引擎的能力，将自定义行为注入到Webpack的构建流程中，解决一些额外的功能，比如分离打包，压缩文件，代码混淆等。插件可以根据特定需求实现自定义。在配置文件里通过<code>plugins</code>配置项设置插件，它接收一个数组用来存放各种引入的插件。</p>
<p>plugin是在Webpack打包的某个时间点上去做一些操作，可以把Webpack理解为一个工厂生产线，代码需要经过一系列的工艺处理才能得到结果，plugin就好比是生产线上插入的一个功能，在打包进行到某个阶段时做一些特殊的处理。plugin的本质是一个类，使用的时候都是<code>new Plugin()</code>这种形式，这个类里面需要实现一个apply方法，在Webpack打包时会按顺序执行每个plugin的逻辑。</p>
</li>
</ul>
<p>此外，还有一个打包模式的配置项（mode），它告诉Webpack应该按什么样的模式来进行优化，其可选值为<code>none</code>，<code>development</code>，<code>production</code>。</p>
<ul>
<li>none：不启用任何默认优化选项</li>
<li>development：开发模式，这个模式下打包会更快，但不会进行代码优化</li>
<li>production：这是mode的默认值，打包速度略慢，但会开启<code>tree-sheaking</code>和代码压缩（这两个概念会在下文”性能优化“中讲到）。</li>
</ul>
<p>模式的切换可以通过配置文件修改，也可以在使用Webpack CLI命令的时候通过<code>--mode=xxxx</code>进行传递。</p>
<p>Webpack启动本地服务器使用的是<code>webpack-dev-server</code>简称wds。Vue CLI的本地调试服务也是基于wds的。可以在config里的<code>devServer</code>里配置wds的各种选项，比如静态文件目录、端口、启动压缩gzip，自动打开网页等。wds是基于Node.js编写的，可以在浏览器和服务器之间建立一个WebSocket长链接，从而可以自动加载页面。</p>
<h3 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h3><p>Webpack要做的事情是内容转换和资源合并，整个Webpack的构建流程包含三个阶段：初始化、构建、生成，有一点“要把大象装冰箱”的意味（</p>
<ul>
<li>初始化阶段：<ul>
<li>初始化参数：执行打包指令时，从默认配置、用户配置、Shell参数中读取所有的参数，将它们结合，得到最终的参数用于运行。</li>
<li>创建编译器对象：用上一步的参数创建一个编译器（compiler）对象</li>
<li>初始化编译环境：注入内置插件、注册模块工厂、初始化RuleSet、加载配置<ul>
<li>内置插件：各种用户加入的plugin</li>
<li>模块工厂：一个工厂函数，通过它的create方法去实例化module</li>
<li>RuleSet：是Webpack的规则集，用于在Webpack中配置匹配、修改和插入的规则。</li>
<li>配置：Webpack配置文件</li>
</ul>
</li>
<li>从入口开始编译：执行编译器对象的run方法，根据配置的入口找到所有的入口文件，首先将所有的入口文件作为一开始的依赖，然后以深度优先的方式开始进行依赖收集。</li>
<li>总的来说，依赖分析是依靠AST的。Webpack需要读到入口文件里的内容，然后使用<code>@babel/parser</code>把js代码转换成js对象，这种对象就是抽象语法树AST。从AST中可以提取CallExpression的arguments的value值，它是一个相对路径，然后需要用path库把它转换成绝对路径，根据绝对路径找到下一个依赖文件，再换换成AST，从AST中提取模块，反复迭代直到遍历完成。</li>
</ul>
</li>
<li>构建阶段：<ul>
<li>编译模块：首先分析入口文件的依赖，调用对应的loader把模块转换成JavaScript，再调用JavaScript解释器把内容都转成AST，找出模块依赖的模块，再递归寻找，直到所有的依赖都被遍历</li>
<li>构建关系图：遍历完成所有能触达的模块后，根据遍历的信息生成一个依赖关系图</li>
</ul>
</li>
<li>生成阶段：<ul>
<li>输出资源：根据入口和模块之间的依赖关系，将依赖组装成一个个<code>chunk</code>（释义为区块或者数据块），再把每个生成的chunk转成单独的文件加入到输出列表（此为默认配置，可以不让它全输出到一个文件里）</li>
<li>写入文件：确定好输出内容后，根据output配置确定的输出路径和文件名，把文件内容写入到文件系统</li>
</ul>
</li>
</ul>
<h3 id="构建产物"><a href="#构建产物" class="headerlink" title="构建产物"></a>构建产物</h3><p>以下构建产物的讨论基于v4版本。Webpack构建产物分两种情况：</p>
<ul>
<li>默认情况，所有内容打包到一个chunk里。<ul>
<li>此种方法会把读到所有模块依赖都放到一个作用域里，然后用一个modules数组保存，所有的模块按加载顺序加入数组，并按数组索引访问。</li>
<li>Webpack会自己实现引入的api，让浏览器支持代码里面的模块化写法（比如ESM和CommonJS）</li>
</ul>
</li>
</ul>
<p>对于默认情况，可以自己尝试一下打个包看看会发生什么。Webpack打包产物使用一个IIFE包裹，传参是一个数组（modules数组），数组的每一项都是源代码的模块代码。如果采用CommonJS写法，那么Webpack就会自己实现一个<code>require</code>和<code>module.exports</code>，前者被替换成<code>__webpack_require__</code>，后者不变，会由Webpack作为函数的参数传递给源代码。如果采用ESM写法，那么Webpack就会让<code>__webpack_require__</code>去模拟<code>import</code>，同时使用<code>__webpack_exports__</code>模拟<code>export</code>。如果混用ESM和CommonJS，Webpack就会同时模拟这两种方法。</p>
<ul>
<li>自定义情况，把代码打到多个chunk包里。<ul>
<li>当存在 import做动态加载、公共依赖、还有多个打包入口这三种里任意一个或多个的情况时，Webpack将尝试把代码打包成多个chunk。</li>
<li>Webpack可以根据设定好的条件自动拆分chunks：<ul>
<li>新的chunk可以被共享，或者来自<code>node_modules</code></li>
<li>新的chunk在进行压缩混淆之前的体积大于20kb</li>
<li>当按需加载chunk时，并行请求的最大数量&lt;=30</li>
<li>当加载初始化页面时，并发请求的最大数量&lt;=30</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>多个chunk的时候情况不太一样。可以分别分析一下：</p>
<ul>
<li>多个打包入口：这个是最直观的，由于打包入口有多个，所以最后输出时肯定会分成多个不同的包，不然多个入口的意义就失去了很多。多个入口分离多个包，如果使用了<code>html-webpack-plugin</code>，那么在入口html里将引入多个script标签。分离出来的多个包都包含同样的Webpack注入代码。</li>
<li>存在公共依赖：如果存在公共依赖，且在配置文件中配置了<code>optimization.splitChunks.chunks = &#39;all&#39;</code>，那么打包产物中将出现带有<code>vendors</code>字样的文件，其中就包含公共使用的依赖。（vendor原意为供应商，这里代表各种第三方依赖）如果你试图查看vendors输出的文件，会发现第一行代码是Webpack在window对象上注入的<code>webpackJsonp</code>，后续Webpack访问模块就是通过这个<code>webpackJsonp</code>，可以通过打开一个任意Webpack项目来验证，只要<code>window.webpackJsonp</code>有值，那就说明Webpack的分包是起作用的。这种情况的执行流程是，首先加载vendors包（把第三方依赖模块变成以Webpack可以解析的形式存储到全局对象<code>window[&#39;webpackJsonp&#39;]</code>内），然后把<code>window[&#39;webpackJsonp&#39;]</code>的代码传到打包产物代码里的modules里，之后的操作和单chunk一样。</li>
<li>import动态加载：这种方式可以称之为懒加载或者按需加载，因为在Webpack内通过<code>import()</code>函数可以让模块异步加载，且只有当使用到此模块时才执行加载操作。使用了import操作的JavaScript代码，结构和单chunk包是一样的，但遇到import函数时就会被替换成一个复杂的<code> __webpack_require__</code>操作，其步骤大概是这样的：<ul>
<li>首先使用<code> __webpack_require__</code>和模块在modules里的索引找到此按需引入的模块，然后它会返回一个Promise，如果Promise兑现说明加载成功，此时可以使用<code>thenable</code>方法，Webpack的实现也是这样的。</li>
<li>第一步替换之后，<code> __webpack_require__</code>会生成一个script标签，然后使用<code>document.head.appendChild</code>把它插入到DOM里，然后return一个Promise对象，此时的Promise是pending状态，等待模块加载。</li>
<li>模块下载完成后会直接解析执行，此时触发<code>webpackJsonpCallback</code>函数，它会把刚刚懒加载的模块内容push到modules数组里面，然后上一步的Promise状态就更改为兑现，下面的<code>__webpack_require__</code>可以继续执行。</li>
<li>在上一个<code> __webpack_require__</code>的then里面，它执行<code> __webpack_require__.bind(null, 模块索引)</code>，这一步就是正常解析了。（也就是两个<code> __webpack_require__</code>的作用不完全相同，实际上我在做笔记时省略了第一步时的一些细节，第一步实际上是<code> __webpack_require__.e</code>。完整实现可以去自己打个包看看），它实际上模拟了<code>module.exports</code>，这次<code> __webpack_require__</code>之后再接<code>thenable</code>方法就可以接收到具体参数。</li>
</ul>
</li>
</ul>
<p>如果采用生产环境模式打包，打包逻辑其实也是完全相同的，但其产物会进行压缩，一来压缩体积降低传输数据量，二来提高JavaScript执行速度。但即便是使用开发环境模式打包，Webpack的产物看起来也特别丑。其实是因为Webpack诞生于CommonJS出现后，ESM出现前，这时的浏览器只能通过script标签加载模块，且标签本身没有作用域，想要分割作用域只能通过闭包（也就是实现里采用的IIFE），每个模块都要封装成function，这样才能互不干扰。并且由于浏览器不支持cjs（cjs是同步的，浏览器访问服务端资源需要通过网络请求，如果弱网环境的话执行就会卡住），所以Webpack才要自己实现CommonJS的方法，相当于它本身提供了一个polyfill。即便现在有了ESM，但Webpack为了向前兼容，就保留了IIFE的写法，所以即便是新版的Webpack，产物看起来还是这么乱糟糟。</p>
<h3 id="特色功能"><a href="#特色功能" class="headerlink" title="特色功能"></a>特色功能</h3><h4 id="runtime和manifest"><a href="#runtime和manifest" class="headerlink" title="runtime和manifest"></a>runtime和manifest</h4><p>Webpack的打包产物中包含runtime和manifest。runtime是Webpack的运行时辅助工具，用于加载模块。</p>
<p>manifest是一组数据，记录模块和打包产物文件之间的映射关系，可以通过安装<code>webpack-manifest-plugin</code>来查看manifest，默认打包的话manifest是不可见的。</p>
<h4 id="Source-Map"><a href="#Source-Map" class="headerlink" title="Source Map"></a>Source Map</h4><p>由于Webpack在合并、编译压缩源代码后会破坏原有的代码结构，这就导致如果打包后出现bug，很难对着压缩后的代码进行调试。Source Map就是为了解决这个问题而生的。它可以在源文件和打包文件之间建立映射，本质是将每个代码字符的新旧位置对应起来，这样当运行的代码出现警告或报错时，通过Source Map就可以把报错位置转换到源代码的位置，以方便调试。但是Source Map本身会提升一部分打包体积，且有泄漏源代码的风险，所以是否启用需要根据实际情况灵活决定。</p>
<h4 id="HMR"><a href="#HMR" class="headerlink" title="HMR"></a>HMR</h4><p>其全称为Hot Module Replacement，模块热替换，也就是可以在Webpack项目运行时替换、新增或删除模块，且不需要重新刷新页面，开启HMR需要把<code>devServer.hot</code>改为true，并且添加<code>HotModuleReplacementPlugin</code>插件。样式文件的HMR由style-loader内部实现，Vue文件的HMR由vue-loader内部实现，js文件需要修改源代码，当<code>moudle.hot</code>为true时执行<code>module.hot.accept</code>方法接收更新通知。</p>
<p>HMR借助的是本地服务和浏览器之间建立的长连接websocket，当本地文件发生变化，可以立马告知浏览器热更新代码，此后HMR会监听webpack的编译结束，每次监听到编译结束，就会通过ws向浏览器发送通知，浏览器就可以拿到每次打包后的新hash值，然后做检查更新逻辑。</p>
<h4 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h4><p>tree-shaking是一种删除冗余代码的操作，具体来说是将一个webpack项目想象成一棵树，每个依赖都是树上的一些节点，实际上你可能依赖了某个模块后但只使用了模块中的一部分功能，这时候就需要tree-shaking来把无用的部分摇掉了。此技术在Rollup中率先实现，Webpack自2.0版本起也采用了tree-shaking技术。</p>
<p>tree-shaking是基于ESM的，它会分析模块之间的导入导出，确定哪些导出值没有被使用，这些没有被使用的导出值就会被删除掉。最早这个方法是在rollup中实现的，后来webpack也加入了tree-shaking。</p>
<p>可以先了解一下什么是DCE，DCE叫做Dead Code Elimination，也就是消灭“死代码”，可以把tree-shaking理解为是DCE的一种实现。传统的DCE通常会把符合以下条件的代码认作死代码，并将其消除：</p>
<ul>
<li>没办法到达或执行的代码</li>
<li>代码执行的结果没有被使用</li>
<li>代码产生的影响只对死变量有效（只写不读的变量就是死变量）</li>
</ul>
<p>对于tree-shaking来说，它消除无用代码的思路更偏重于以模块为单位，由于ESM的依赖关系是静态的，这就给依赖分析带来了便利。相比于CommonJS，它的require是可以动态引入模块的，只有执行代码时才能知道哪些代码没有被使用到，但ESM可以做到不执行就能优化掉无用代码。比如export的变量中同时有foo和bar，引入它们的代码中只使用到了foo，那么bar就会被tree-shaking删除。</p>
<p>整个tree-shaking的实现一共分为两步，第一步是标记所有模块中未使用的导出值，第二步是使用Terser删除这些没有用到的导出语句。</p>
<p>其中，第一步还分为以下三个子步骤（以下流程经过简化）：</p>
<ul>
<li>弄清楚每个模块的导出值，将所有导出语句转换为依赖对象，记录到<code>modules.dependcies</code>中。等webpack编译完成后有专门的插件从Webpack入口开始读取<code>ModuleGraph</code>中存储的模块信息，并开始遍历module对象，把所有找到的依赖对象都记录到<code>ModuleGraph</code>中</li>
<li>标记导出列表中哪些值有被用到，哪些没有。从Webpack入口开始遍历之前记录在<code>ModuleGraph</code>的依赖对象，每个对象都具有一个<code>exportInfo</code>数组，通过访问此数组来确定当前依赖对象有没有被其他对象使用，将已经被使用的对象打上标记</li>
<li>根据上一步的标记情况生成不同的打包代码，将使用过的对象和没被使用过的对象分别保存</li>
</ul>
<p>现在，模块导出列表中没有被使用的值都不会在<code>__webpack_exports__</code>对象中定义，这就变成了Dead Code，此后使用Terser把这些代码删除，即完成tree-shaking操作。</p>
<h4 id="webpack-bundle-analyzer"><a href="#webpack-bundle-analyzer" class="headerlink" title="webpack-bundle-analyzer"></a>webpack-bundle-analyzer</h4><p>这是一个图形化分析Webpack打包产物的插件，可以很直观的看到Webpack各个产物的大小，辅助我们进行打包优化。如果使用Vue CLI构建项目，则自带此插件。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="为什么要优化"><a href="#为什么要优化" class="headerlink" title="为什么要优化"></a>为什么要优化</h4><p>性能优化是一个永恒的话题。从HTTP的角度来看，请求的资源尽量少、请求速度尽量快是优化的目标之一。对于Webpack而言，对应的目标就是打包体积的优化。对于开发者而言，还有一个要关注的点就是打包时间。如果项目很小，构建速度并不是很慢，那么其实也不必太过关注性能的问题。但对于大部分企业级的前端项目来说，随着其架构的复杂和功能模块的增加，Webpack的构建时间将疯狂增长，这可能导致每次调试都要耗费一些时间，在快节奏的调试场景下，构建就成为了调试工作的瓶颈。</p>
<p>所以接下来就讨论这两个话题，构建速度提升和降低打包体积。</p>
<h4 id="构建速度提升"><a href="#构建速度提升" class="headerlink" title="构建速度提升"></a>构建速度提升</h4><p>谈到构建速度的优化，那必然要考虑构建的流程，要让构建速度得到提升，那就要细化到每个环节，考虑考虑在哪个环节是耗费时间的。</p>
<p>首先是需要获取依赖模块构建依赖关系图，那么搜索依赖项就是耗费时间的。然后需要根据配置的loader对每个依赖进行一次解析，并且其转换量通常不小，那么转换依赖项也是耗费时间的。在转换完成后，还需要把所有的代码打包到一个或多个文件里，为了减小白屏时间，Webpack还需要对代码进行一些压缩优化等操作。JavaScript压缩的时候计算量是非常大的，因为它需要把JS先转换成AST然后再去处理AST，最后把AST还原为JS，那么压缩代码操作也是耗费时间的。</p>
<p>此外，二次打包也是耗费时间的，这是对于打包之后再次改动而言。如果在打包后代码需要做小幅改动，那在没有特殊配置下所有文件都要重新打包，但其实此时项目中大部分打包产物都是可以二次利用的。</p>
<p>总的来说，构建速度提升的详细指标有以下四个：</p>
<ul>
<li>搜索依赖时间</li>
<li>loader解析时间</li>
<li>代码压缩时间</li>
<li>二次打包时间</li>
</ul>
<p>接下来就逐个记录一下每个指标的优化方式。</p>
<p>优化搜索时间可以从配置入手。Webpack打包时，会从entry出发，以深度优先的方式递归解析依赖，当项目量比较大的时候，这样的解析链路可能会很长，耗费的时间将大幅增加。Webpack中有一个配置项叫做<code>resolve.modules</code>，它用于配置Webpack去哪里找第三方模块，其默认值为<code>[&#39;node_modules&#39;]</code>，也就是它会先从node_modules里面找第三方模块，如果没有找到，则去它的父级目录，父级没有的话就去父级的父级…以此类推。它可以接收多个值，且允许使用绝对路径和相对路径，这里可以使用绝对路径（添加<code>__dirname</code>，利用<code>path.resolve</code>）来优化其寻找策略，减少模块的搜索层级。</p>
<p><code>resolve.extensions</code>是一个判别后缀的配置项，如果导入语句没有带后缀，那么Webpack会自动带上后缀去尝试询问它是否存在，查询的顺序是按照我们配置的<code>resolve.extensions</code>内容顺序查找，默认支持.js和.json，这里可以把常用的后缀写在前面（但不要写多，保证这个列表尽可能小，不然可能起到反向优化的效果），或者导入模块时默认都带后缀，从而降低尝试匹配的次数。</p>
<p>使用<code>resolve.alias</code>减少查找过程也是一种方式，alias意为别名，可以建立起一个标识符和原路径的映射关系，比如把@作为<code>./src</code>使用，当然也可以配置其他的路径，从而减少耗时的递归解析。</p>
<p>使用<code>resolve.noParse</code>可以让Webpack忽略对部分没采用模块化的文件的递归解析处理，比如jQuery，这样也可以节省一些构建时间。</p>
<p>总结：</p>
<ul>
<li>降低搜索依赖时间：<ul>
<li>配置<code>resolve.modules</code>以减少模块搜索层级</li>
<li>合理配置<code>resolve.extensions</code>以减少后缀匹配次数</li>
<li>配置<code>resolve.alias</code>以减少递归解析层次</li>
<li>配置<code>resolve.noParse</code>以不去解析非模块化的文件</li>
</ul>
</li>
</ul>
<p>运行在Node.js之上的Webpack是单线程的，也就是loader只能逐个文件处理，当Webpack需要转换大量文件时，耗费时间就略长。首先想到的是缩小loader解析范围，可以为它配置<code>include</code>和<code>exclude</code>，前者代表将符合条件的模块进行解析，后者代表排除符合条件的模块，同时存在时则<code>exclude</code>的优先级更高。此外，可以使用<code>thread-loader</code>来开启多进程打包，它可以让所有的loader都在一个单独的worker池中运行，以前还有<code>HappyPack</code>可以多进程打包，但它已经不再维护，所以不推荐使用。</p>
<p>总结：</p>
<ul>
<li>降低loader解析时间：<ul>
<li>缩小loader解析范围，合理使用<code>exclude</code>和<code>include</code>，将不需要解析的位置排除在外，解析需要解析的位置</li>
<li>使用<code>thread-loader</code>或<code>HappyPack</code>进行多进程打包，但后者目前已弃用</li>
</ul>
</li>
</ul>
<p>Webpack在生产环境模式打包会默认添加uglify等混淆操作，早期的Webpack使用的是<code>UglifyJsPlugin</code>，但在4.x版本已经废弃，换成了<code>terser-webpack-plugin</code>来优化代码。terser是一个用于ES6+的JavaScript解析器和压缩器，而且可以启动多进程压缩，并发运行的默认数量为<code>os.cpus().length - 1</code>。</p>
<p>总结：</p>
<ul>
<li>降低代码压缩时间：<ul>
<li>在<code>optimization.minimizer</code>中配置<code>new TerserPlugin</code>，且设置<code>parallel</code>为true。</li>
</ul>
</li>
</ul>
<p>对于二次打包，我们的目的是不要让没有改动过的文件再做改动，那么第一时间应该就能够想到缓存。我们可以开启对应loader或者plugin的缓存来提升二次构建的速度。比如把<code>babel-loader</code>和<code>terser-webpack-plugin</code>的缓存打开，可以有效降低二次打包的时间。还可以使用<code>cache-loader</code>或<code>HardSourceWebpackPlugin</code>来给模块提供一个中间缓存，不过这东西我还没用过，不知道实际效果怎么样。</p>
<p>此外，还可以使用预编译资源模块，听起来有点玄学，其实这玩意就是dll库，用于把一些长期不需要更新的第三方库抽离出来打包成dll文件，然后当需要导入这个模块时，这个模块就会从dll中获取。dll只需要被编译一次，就可以持续使用，它适用于一些基础库的版本，比如vue，react等，如果是一些需要经常更新的库则不适合使用。目前Webpack已经内置支持动态链接库，使用<code>webpack.DllPlugin</code>就额可以在第一次编译打包后生成一份不变的dll供其他模块引用。</p>
<p>总结：</p>
<ul>
<li>降低二次打包时间：<ul>
<li>打开loader和plugin的缓存，或者使用第三方缓存loader或plugin</li>
<li>使用动态链接库作为预编译资源模块</li>
</ul>
</li>
</ul>
<h4 id="降低打包体积"><a href="#降低打包体积" class="headerlink" title="降低打包体积"></a>降低打包体积</h4><p>打包体积直接决定着项目的加载速度，因为即便代码级别的优化做得再好，代码体积过大，在HTTP传输时所需时间也就变长，就会影响用户体验。所以说，我们的打包体积总是越小越好的。既然要考虑打包文件体积，那就要细分一下打包文件到底都有什么。其实无非就是HTML、CSS、JavaScript以及图片文件。</p>
<p>如果你使用了<code>webpack-bundle-analyzer</code>，就可以在优化前看到到底是谁在占用打包体积，方便对症下药。</p>
<p>压缩HTML虽然看起来不起眼，但却也是一种很值得做的事情。这个操作Webpack已经帮我们做了，所以其实并不需要太多配置，不过可以简单了解其原理。压缩HTML主要是通过把空格、回车、制表等空白字符删除，以及把注释删除，从而达到压缩的效果。这些字符对于我们阅读和编写代码是很有帮助的，但对于浏览器解析代码并没有什么帮助。这个压缩的比率其实很小，但其实并不能这样考虑。对于大型网站而言，其流量可能会相当大，如果通过优化让原来每1M的请求减少一个字节，那一整年节省的流量可能也要按TB来计算，即便每GB流量只按一毛钱，那么每年省下的流量费也不是小数目。这个道理其实也同样可以应用于其他资源。</p>
<p>压缩CSS使用的是，其默认使用<code>cssnano</code>作为压缩引擎，只需要在<code>optimization.minimizer</code>里配置一下<code>OptimizeCSSAssetsPlugin</code>就可以了。同时还可以使用<code>PurgeCSS</code>完成对无用css的去除，需要配合<code>purgecss-webpack-plugin</code>使用。</p>
<p>压缩JavaScript也是Webpack帮我们做到了，它使用<code>terser-webpack-plugin</code>完成代码压缩和混淆，同时可以开启<code>parallel</code>以加快压缩。</p>
<p>关键之处在于压缩图片文件。有时候一些图片的大小会远比js和css文件大，且过大的图片文件加载也会比较慢。我们倒是可以手动做图片压缩（比如使用tiny jpg，我的博客就是这么干的），但在Webpack里这个操作是可以自动化完成的，可以在<code>file-loader</code>之后引入<code>image-webpack-loader</code>，并提供对应格式的压缩选项，就可以对图片进行压缩。如果你或你的公司拥有个人CDN地址，也可以将这些图片资源分发到CDN上，在访问图片时通过CDN加速访问，同时也不至于占用代码文件的HTTP请求，做到静态文件分离。可以在output的<code>publicPath</code>中配置URL地址。</p>
<p>总结：</p>
<ul>
<li>压缩HTML：默认Webpack完成</li>
<li>压缩CSS：<code>optimize-css-assets-webpack-plugin</code>可以压缩CSS，<code>purgecss-webpack-plugin</code>可以去除没有用到的CSS</li>
<li>压缩JavaScript：默认Webpack完成，使用<code>terser-webpack-plugin</code></li>
<li>优化图片：使用<code>image-webpack-loader</code>，或者使用CDN</li>
</ul>
<h3 id="v4和v5的一些区别"><a href="#v4和v5的一些区别" class="headerlink" title="v4和v5的一些区别"></a>v4和v5的一些区别</h3><ul>
<li>代码压缩<ul>
<li>v4的代码压缩需要手动安装<code>terser-webpack-plugin</code>，需要额外配置</li>
<li>v5自带此插件，mode设置为production时自动开启</li>
</ul>
</li>
<li>缓存配置<ul>
<li>v4使用<code>hard-source-webpack-plugin</code>开启构建缓存</li>
<li>v5内部内置了cache缓存机制，通过配置即可开启缓存</li>
</ul>
</li>
<li>loader优化<ul>
<li>v4加载资源需要使用各种loader<ul>
<li><code>raw-loader</code>将文件导入为字符串</li>
<li><code>url-loader</code>将文件作为 data URI 内联到 bundle 中</li>
<li><code>file-loader</code>将文件发送到输出目录</li>
</ul>
</li>
<li>v5将一些常用loader替换为了资源模块<ul>
<li><code>asset/resource</code> 发送一个单独的文件并导出 URL。之前通过使用 <code>file-loader</code> 实现。</li>
<li><code>asset/inline</code> 导出一个资源的 data URI。之前通过使用 <code>url-loader</code> 实现。</li>
<li><code>asset/source</code> 导出资源的源代码。之前通过使用 <code>raw-loader</code> 实现。</li>
<li><code>asset</code> 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 <code>url-loader</code>，并且配置资源体积限制实现。</li>
</ul>
</li>
</ul>
</li>
<li>启动服务<ul>
<li>v4使用wds启动服务</li>
<li>v5内置webpack serve启动</li>
</ul>
</li>
</ul>
<h2 id="Vue-CLI"><a href="#Vue-CLI" class="headerlink" title="Vue CLI"></a>Vue CLI</h2><blockquote>
<p>Vue CLI是一个基于Vue.js进行快速开发的完整系统，致力于将 Vue 生态中的工具基础标准化。它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样你可以专注在撰写应用上，而不必花好几天去纠结配置的问题。</p>
<p>摘自Vue CLI的官方文档</p>
</blockquote>
<h3 id="何为CLI"><a href="#何为CLI" class="headerlink" title="何为CLI"></a>何为CLI</h3><p>在聊Vue CLI之前，我们应当知道什么是CLI。CLI的全称为Command Line Interface，即命令行交互界面，通常我们会将它称之为脚手架。我们为什么要在工程项目中使用脚手架呢？其目的有二：</p>
<ul>
<li>快速搭建项目的基本结构</li>
<li>为项目提供必要的规范和约定</li>
</ul>
<p>脚手架工具相当于是一种开箱即用的整合包，通过人为的提前预设好一系列工具和配置，做到搭建新项目时提高配置效率，为老项目统一开发风格和规范。</p>
<p>通常来讲，脚手架工具在安装后能够为用户提供一个命令，或能够通过其他交互方式向用户请求信息，这一步的目的是向用户询问一些简单的配置问题，并按照用户的要求生成对应的工程文件，有点像是定制点餐那样的风格。比如使用<code>vue create</code>命令的时候就能做到询问用户安装哪些特性（如babel，ts，pwa，eslint等），然后就可以按照预设，将这些定制的配置生成为对应的项目文件。</p>
<p>那么，Vue CLI为我们做了哪些呢？它同样拥有一个交互式界面，能够为新项目自由选择配置，同时拥有一个直观的图形化界面用来管理Vue CLI项目。Vue CLI里包含一个基于webpack和wds的CLI服务，可以用于加载其他的CLI插件，以及一个预设优化的webpack配置，还有<code>Vue CLI-service</code>的npm命令，支持npm run build/dev等。Vue CLI还支持添加各种CLI插件，·可以把插件理解为一些提前配置好的Webpack预设。</p>
<h3 id="从特色功能看前端工程化"><a href="#从特色功能看前端工程化" class="headerlink" title="从特色功能看前端工程化"></a>从特色功能看前端工程化</h3><p>如果仅仅是做配置整合和界面优化，那还不够。Vue CLI作为一个重要的前端工程化工具，自然有其特色之处。谈到前端工程化，我们通常会聊到什么？</p>
<blockquote>
<p>前端工程体系是一种服务，以项目迭代过程中的前端开发为主要服务对象，涉及开发、构建、部署等多个环节。</p>
<p>前端工程化的主要目标是解放生产力和提高生产效率，通过制定一系列的规范，借助工具和框架解决前端开发以及前后端协作开发过程中的痛点和难点问题。</p>
<p>摘自《前端工程化体系设计与实践》</p>
</blockquote>
<p>一个常规的前端DevOps过程包含基建、Git工作流和CI/CD，其中Vue CLI所负责的部分大多属于基建，为项目提供一个标准的脚手架。但Vue CLI所能提供的并不止基建。</p>
<p>在构建阶段，我们会考虑打包产物的ES兼容性问题。尽管现在绝大部分浏览器都已经支持ES6，但仍然有一小部分浏览器无法很好的对ES6代码做支持，一旦业务中需要接触到这部分盲区，那就需要考虑到兼顾旧浏览器的问题。Babel可以把ES6+的代码彻底转换成ES5代码，通过转译和垫片来保证产物中没有高阶特性，然而这通常意味着转义之后的产物体积会变得比较臃肿，且性能也会有所下降。为了支持旧浏览器而放弃对新浏览器的支持是得不偿失的，但Vue CLI提供了现代模式构建，也就是会同时打两个包，在生成的html中会同时引入这个兼容版本的js和全新版本的js。</p>
<blockquote>
<ul>
<li>现代版的包会通过 <code>&lt;script type=&quot;module&quot;&gt;</code> 在被支持的浏览器中加载；它们还会使用 <code>&lt;link rel=&quot;modulepreload&quot;&gt;</code> 进行预加载。</li>
<li>旧版的包会通过 <code>&lt;script nomodule&gt;</code> 加载，并会被支持 ES modules 的浏览器忽略。</li>
</ul>
</blockquote>
<p>Vue CLI支持零配置的快速原型开发，这使得你可以随时随地测试一个新想法或验证某些功能，而无需大动干戈的新建一个大项目，这在临时需要一个试验场测试一些特性时尤为有效。只需要安装全局扩展<code>npm install -g @vue/cli-service-global</code>就可以使用此功能。需要说明的是，零配置不是无配置，Vue CLI帮你省略掉了你并不需要过多关心的配置，可以将关注点更多的放在代码和业务上面，这个功能体现了一种关注点分离的思想，我们将问题做了合理的分解，配置的事情由Vue CLI去关注，业务的事情由程序员去关注，这样就实现了技术和业务的一种解耦。</p>
<p>一个优秀的软件项目应当是扩展性良好的，Vue CLI在扩展性方面也下足了功夫。Vue CLI是基于插件的架构，插件可以做到诸如以下此类功能：</p>
<ul>
<li>修改项目的Webpack配置，比如需要添加额外的loader和plugin</li>
<li>为<code>vue-cli-service</code>添加额外的命令，比如添加单元测试命令等</li>
<li>扩展依赖，修改package.json，当插件中需要额外的依赖时，在package中维护依赖是必要的</li>
<li>在项目中创建一些新文件，或者修改一些原有的文件</li>
<li>提示用户选择一个特定的选项（官方文档中有记载此功能，但我暂未发现在哪里可以应用）</li>
</ul>
<p>Vue CLI插件的本质是一个npm包，可以把插件想象成一种细粒度的整合包，每个插件都可以帮助你修改一系列功能。也就是说，原本你需要npm install后再新建配置文件修改配置并验证生效等等一系列的操作，只需要安装一个插件就能完成，Vue CLI的插件做到了前端工程化中解放生产力的作用。</p>
<p>然而，我们不应该滥用Vue CLI插件。插件的目的是为了帮助你完成“一系列”的操作，但如果你的需求只需一步安装导入即可完成，那倒也不用费劲为此寻找一个插件或自己开发一个插件，依然继续使用npm安装就可以了。总的来说，插件是一个处理依赖安装和功能扩展中无法自动化配置的解决方案，它的出现解决了一些生产效率方面的问题，但同时也引入了一些潜在的不可维护风险。这里建议的最佳实践是仅对复杂且常用的功能使用插件安装，或封装公司团队的标准插件以复用。</p>
<p>Vue CLI支持预设（preset），里面包含了创建新项目所需预定义的选项和插件，其配置文件是一个JSON对象。在<code>vue create</code>中保存的预设将会被放置在home目录（linux是<code>~</code>，windows是<code>C:/user/用户名</code>）下的<code>.vuerc</code>文件里，你可以修改这个文件。预设可以将你团队的一些标准配置提前配好，在新建项目时自动使用这些配置，从而可以做到新建后直接上手开发。</p>
<h3 id="原理浅析"><a href="#原理浅析" class="headerlink" title="原理浅析"></a>原理浅析</h3><p>我们把Vue CLI做一下拆分，探索一下它是如何设计的。整个Vue CLI分为多个独立的部分，可以把它们简单分为CLI，CLI服务和CLI插件。</p>
<p>CLI是一个纯正的脚手架工具，提供命令行的<code>vue</code>指令，诸如创建新项目，快速原型，GUI管理器等功能都包含在CLI中。CLI服务是一个Vue的开发环境，本质上是一系列依赖的集合，它构建于webpack和wds之上，提供的是<code>vue-cli-service</code>命令（要和上面的<code>vue</code>命令区分开），使用此命令可以运行一个Vue CLI项目。CLI插件在上文中说了很多，它是一个npm包，但对名称有限定。</p>
<ul>
<li>CLI</li>
</ul>
<p>CLI是如何做到提供一个新的指令的？关键在于下面两个配置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;bin&quot;: &#123;</span><br><span class="line">    &quot;vue&quot;: &quot;bin/vue.js&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /usr/bin/env node</span></span><br></pre></td></tr></table></figure>

<p>第一个是CLI的package.json文件，也就是指定某命令的入口文件，这里指定<code>vue</code>指令的入口文件为<code>bin/vue.js</code>，之后需要在这个文件的第一行写入第二个配置中的信息。这玩意是干嘛的？</p>
<p>开头的<code>#!</code>叫做Shebang，用于指明这个文件的解释程序，Node CLI应用必须使用这样的文件头，相当于指明这个文件要使用Node.js的服务运行。之后需要执行<code>npm link</code>将命令挂载到全局，接下来就可以正常使用此命令了。</p>
<p>CLI在启动时会首先判断用户的Node版本，如果版本与要求的不一致，那么将会退出程序，提示用户下载对应版本的Node。CLI使用chalk插件来向命令行显示彩色文字。</p>
<p>现在我们拥有自定义指令了，接下来还需要一个能够解析其多种命令的工具，这部分功能交由commander完成。commander是用来解析用户输入指令的工具，通过它的处理，可以获得用户输入的指令名称和后面跟带的参数配置等信息。在commander正常接收命令后便执行对应命令，比如执行create，此时需要启动一个交互式命令，这里采用的是inquirer来收集用户输入，然后根据用户的输入来处理流程，最后调用创建新项目的方法（本质上是文件的复制粘贴或者git clone）即可。</p>
<p>整个CLI的简单流程大概如上面所述，但其实内部细节还有很多，感兴趣可以自己去读读CLI的源码。</p>
<ul>
<li>CLI服务</li>
</ul>
<p>CLI提供的<code>vue-cli-service</code>指令在package文件中也有定义：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;bin&quot;: &#123;</span><br><span class="line">    &quot;vue-cli-service&quot;: &quot;bin/vue-cli-service.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>且仍然存在Node CLI文件头。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /usr/bin/env node</span></span><br></pre></td></tr></table></figure>

<p>第一步和CLI相同，也是判断Node的版本。之后它新实例化了一个Service对象，使用<code>process.argv.slice(2)</code>来接收，并使用minimist插件来格式化输入参数，将格式化的命令和参数输入到service.run函数中执行。此函数根据接收到的参数处理不同的命令，解析并执行不同的操作。</p>
<p>CLI服务包含有build，serve等操作的具体实现。serve操作将按照CLI配置启动wds，build相对复杂一些，但整体思路也是提供一系列配置然后启动webpack打包。这部分细节太复杂了，有机会的话可以再写一篇文章具体讲讲怎么做的。</p>
<ul>
<li>CLI插件</li>
</ul>
<p>CLI插件包含一个主要功能文件，并且能够可选的加入generator，prompt或Vue UI集成。并且由于CLI插件是一个npm包，所以还需要遵循一下npm包的规范，比如需要包含readme文件和package文件。</p>
<p>CLI插件的名字是固定的，它只能是 <code>vue-cli-plugin-&lt;name&gt;</code> 或者 <code>@scope/vue-cli-plugin-&lt;name&gt;</code> 这样的名字，否则它将无法被add方法安装，也不能在Vue UI中搜索到。</p>
<p>插件的主要功能文件（官方叫做service）可以用来修改webpack配置，创建新的<code>vue-cli-service</code>命令或者修改已有命令的行为，也可以为命令指定在哪个模式下运行。service会在Service实例被创建后自动加载。</p>
<p>prompt代表对话，在创建一个新项目或在已有项目中添加新插件时用于处理用户选项。对话逻辑放置于一个单独的js文件，对话实现使用inquirer。</p>
<p>使用命令行安装本地插件时，需要首先<code>npm install 插件</code> ，然后调用<code>vue invoke 插件名</code>来加载此插件，每次插件被修改后都要重复这两个步骤，但借助Vue UI就可以用图形化的方式管理插件。如果需要让插件实现UI集成，那还需要额外配置一下。UI集成功能也需要放置在一个单独的js文件中，借助UI可以实现执行npm任务，展示自定义配置，展示对话，开启i18n，且可以让Vue UI的插件搜索搜到你的插件。此部分的配置官方文档比较详细，这里就不展开多说了。</p>
<h3 id="自定义CLI"><a href="#自定义CLI" class="headerlink" title="自定义CLI"></a>自定义CLI</h3><p>我们可否以Vue CLI的思路为基础，自己造一个CLI？</p>
<p>当然可以，而且也不算重复造轮子。不同团队对项目的要求不一样，采用自研脚手架促进前端工程化体系建设是件很有意义的事。</p>
<p>自研CLI可以不仅局限于Vue，它就是一个封装好的工具集，可以做任何你想做的事情。封装业务组件，单元测试，发布系统，utils实用工具等等均可以包含在内。</p>
<p>整个CLI的流程和Vue CLI是类似的，需要支持自定义命令，自定义命令选项，支持交互式询问，美化CLI界面，能够提供一系列配置预设等。这里我就把简单的思路说一下。</p>
<p>第一大环节，初始化自定义指令</p>
<ul>
<li>新建一个空文件夹作为工作区域，并使用<code>npm init</code>初始化项目。</li>
<li>新建一个<code>index.js</code>作为入口文件，在最上方添加Node CLI文件头（上文有讲）</li>
<li>在package.json里配置bin选项，将自定义命令名称和index.js做个关联</li>
<li>使用<code>npm link</code>将这个项目和本地npm模块建立连接，测试自定义指令能否正常运行此js（可以console.log一个helloworld试试）</li>
</ul>
<p>第二大环节，使用commander处理用户指令</p>
<ul>
<li>npm安装commander</li>
<li>按照官网示例配置在index中引入commander，并增加自定义指令处理代码，其中包括：<ul>
<li>指定命令名</li>
<li>命令的描述</li>
<li>处理命令行参数</li>
<li>执行命令时调用的功能函数</li>
</ul>
</li>
</ul>
<p>第三大环节，实现功能函数中的交互式询问</p>
<p>（注意，并不是所有命令都需要交互式，只有诸如创建新项目这种需要用户选择选项的才需要，如果是需要开启本地服务器等就直接执行其他对应的业务代码就好了）</p>
<ul>
<li>npm安装inquirer</li>
<li>根据inquirer官网的示例配置修改成你想要的内容，包括：<ul>
<li>交互界面需要询问用户的问题</li>
<li>每个问题的备选答案</li>
<li>接收到答案后的处理程序</li>
<li>出现回答异常的捕获</li>
</ul>
</li>
</ul>
<p>第四大环节，美化CLI界面</p>
<p>你可以使用chalk等工具让CLI的输入变得丰富多彩，也可以通过打印字符画等操作凸显品牌。就维护性考虑，你可以在CLI工具里维护一个美化输出的utils库，把chalk封装一下。</p>
<ul>
<li>npm安装chalk</li>
<li>在console.log里调用chalk的加颜色方法</li>
</ul>
<p>如果你的业务操作需要诸如git clone或者下载代码等操作需要等待，那么你可以试试引入ora这个loading动效插件。</p>
<ul>
<li>npm安装ora</li>
<li>用ora新建一个spinner对象</li>
<li>在异步操作的开始让spinner启动</li>
<li>异步操作完成或失败时停止spinner</li>
</ul>
<p>第五大环节，提供配置预设</p>
<p>配置预设其实包含很多方面，代码模板、配置文件等都算，步骤大概如下：</p>
<ul>
<li>新建一个template文件夹用于存放默认模板和配置</li>
<li>当执行初始化操作时，将这个文件夹的文件复制到用户指定的新建项目的目录下，可以使用<code>Metalsmith</code>这个插件方便复制</li>
</ul>
<p>你可能不希望把template和CLI耦合在一起，你的模板也可能是放在git库中，那么需要一个clone项目到本地的工具。</p>
<ul>
<li>npm安装download-git-repo</li>
<li>需要下载时，调用下载方法</li>
<li>处理下载完成和下载失败的逻辑</li>
</ul>
<p>也许静态的模板无法满足你的要求，你希望模板配置能够随着用户的输入变化而变化，那这里可以采用ejs进行一个模板动态渲染。</p>
<ul>
<li>npm安装ejs</li>
<li>在复制之前加入额外的处理程序，获取配置并渲染ejs</li>
<li>复制新渲染之后的内容</li>
</ul>
<p>在此之外，你可能需要在Node.js中执行shell脚本，这里使用的是<code>child_process</code> 的spawn，实现从主进程的输出流连通到子进程的输出流，这个不需要安装，直接引入使用就可以。</p>
<p>最后，如果你想把你的CLI文件发布到npm或者私有npm，那么按照npm的发布操作即可将你的包正常发布。如果别人要使用，只需要<code>npm install 名称 -g</code>就可以把你的CLI安装在别人的电脑上，之后就可以正常使用了。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章断断续续的写了快一个月，中间因为在忙春招和学校的其他事，进度没有赶的特别快。文章很多内容其实展开的并没有很详细，更多像是一个笔记的形式吧，把一些提纲挈领记录下来，而不是长篇大论的去写到底要怎么做。详细去做的教程网上有很多，每个人的习惯也不尽相同，个人感觉实战还是要靠实际去敲和实际去钻研，而教程只能提供众多可行性中的一种范本，初学者完全可以跟着教程一步步走，但我更建议有机会的话要多去合理作死，合理瞎折腾，通过一点点制造错误和修改错误去学习技巧要比看教程按部就班的来效果好得多。</p>
<p>就写到这吧，准备面试去了。</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://shawnzhou.world/2022/03/29/webpack-and-vue-cli/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Webpack/" rel="tag">Webpack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">前端工程化</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/04/09/lan-qiao-cup-web-contest-2022/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            2022年第十三届蓝桥杯Web应用开发组省赛题解
          
        </div>
      </a>
    
    
      <a href="/2022/02/22/javascript-asynchronous-code/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">JavaScript异步编程知识点集锦</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "YolIyMzPHjxT49twQAhzxsQ8-gzGzoHsz",
    app_key: "Dtrq0zAmtB8CqcKdwVCk7JBn",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2018-2022
        <i class="ri-heart-fill heart_icon"></i> Shawn Zhou
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 框架强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://v1.cnzz.com/z_stat.php?id=1279352967&amp;web_id=1279352967'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/avatar1.png" alt="ShawnZhou的小站"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">图集</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>感谢打赏~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://shawnzhou.world/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://shawnzhou.world/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>